<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[置顶][Artical]思维问题</title>
    <url>/2100/01/01/%5B%E7%BD%AE%E9%A1%B6%5D%5BArtical%5D%E6%80%9D%E7%BB%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h3><p>在一个遥远的村庄中，有100个蓝眼睛的人和900个黑眼睛的人，他们都绝顶聪明并严格遵守规则</p>
<p>村子里没有任何反光的物件，也不准以任何方式讨论眼睛的颜色，但村中人都知道村子里有<strong>多种</strong>颜色的眼睛</p>
<p>村子里有一个奇怪的规定，如果任何人知道了自己眼睛的颜色，必须在正午12：00到广场上自杀</p>
<p>注意，所有人要在自杀开始前决定自己是否自杀，在自杀结束后才能知道有几个人自杀，也就是说可以认为自杀<strong>瞬间结束</strong>并且<strong>只能在正午12：00进行</strong></p>
<p>村里多年相安无事，一天，村里来了一个旅者，他不知道村里的规矩，随口说：“你们村里有蓝眼睛的人哎！”</p>
<p>会发生什么？</p>
<h3 id="分赃"><a href="#分赃" class="headerlink" title="分赃"></a>分赃</h3><p>你是海盗A，你还有4个同伙，分别为BCDE</p>
<p>你们有一天抢到了100个金币<strong>（金币最小计数单位是1个）</strong>，要进行分赃</p>
<p>分赃的规则如下：按照ABCDE的顺序依次提出分赃的方案，如果一个人提出的方案没有超过半数的<strong>活人</strong>认同，那么就把他丢下海去喂鲨鱼</p>
<p>如果所有的海盗都绝顶聪明，绝对贪婪和残暴；换句话说，他们的第一目标是保命，第二目标是拿钱，第三目标是杀死尽可能多的人，并会按照最佳策略行动</p>
<p>你要提出方案了，怎样才能拿到最多的金币呢？</p>
]]></content>
      <categories>
        <category>Artical</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>Artical</tag>
      </tags>
  </entry>
  <entry>
    <title>[置顶][Artical]短文随感</title>
    <url>/2100/01/01/%5B%E7%BD%AE%E9%A1%B6%5D%5BArtical%5D%E7%9F%AD%E6%96%87%E9%9A%8F%E6%84%9F/</url>
    <content><![CDATA[<h2 id="尊严"><a href="#尊严" class="headerlink" title="尊严"></a>尊严</h2><h6 id="读者2019-十二月上-卷首语-余秋雨"><a href="#读者2019-十二月上-卷首语-余秋雨" class="headerlink" title="读者2019 十二月上 卷首语 余秋雨"></a><em>读者2019 十二月上 卷首语 余秋雨</em></h6><p>第一，尊严，主要产生于以弱对强，以小对大，而不是反过来；<br>第二，尊严，主要产生于平静的自述，而不是声辩；<br>第三，尊严，主要产生于拒绝，而不是扩张</p>
<h2 id="没有归还的一天"><a href="#没有归还的一天" class="headerlink" title="没有归还的一天"></a>没有归还的一天</h2><h6 id="读者2019-十二月上-意-帕皮尼"><a href="#读者2019-十二月上-意-帕皮尼" class="headerlink" title="读者2019 十二月上 [意]帕皮尼"></a><em>读者2019 十二月上 [意]帕皮尼</em></h6><p>将自己的青春放到以后去花费，随之而来的代价是每次一个月时间的等待，碰到这样的机会看似幸运，实则是更深的不幸。你可以在老年的时候得到瞬间的无比欢悦，可是愉悦过后是无可救药的更深的绝望</p>
<p>这个交换的可怕之处就在于，你哪怕在以后花费青春的时候，也无可避免地想到自己身处老年，而当自己还拥有青春的时候就会觉得老年无比可怕；一个月时间的等待，更加使得老年的乐趣烟消云散；最终没有归还的一天，老妇人在镜前死去，是这个悲剧的集中体现，以小见大折射出老妇人绝望的老年生活</p>
<p>作者意在告诉我们，要融入当下，接纳自己的全部</p>
<h2 id="完美的生活"><a href="#完美的生活" class="headerlink" title="完美的生活"></a>完美的生活</h2><h6 id="读者2019-十二月上-日-星新一"><a href="#读者2019-十二月上-日-星新一" class="headerlink" title="读者2019 十二月上 [日]星新一"></a><em>读者2019 十二月上 [日]星新一</em></h6><p>警告过度智能化会导致人与人之间的冷漠</p>
<h2 id="格列佛游记"><a href="#格列佛游记" class="headerlink" title="格列佛游记"></a>格列佛游记</h2><h6 id="无法反驳的讽刺怎样养成"><a href="#无法反驳的讽刺怎样养成" class="headerlink" title="无法反驳的讽刺怎样养成"></a><em>无法反驳的讽刺怎样养成</em></h6><p>在巨人国游记中，作者借巨人之口对一切他想批判的东西发表不遗余力的批判，而在书中具有自我性质的“我”则站在和现实中的作者不同的一边，为这些事情竭力辩护；然而这样的辩护又充斥着无力感——这由人物体型大小的设计决定。在这里，正义好像化身为顶天立地的巨人，让那些小人的无力、邪恶、软弱充分暴露。</p>
<p>最巧妙的地方在于，书中的“我”经历了这些最终的论断是：“如果把生活在这么偏远地方的一位君王的善恶观提出来作为全人类的标准，那真是叫人难以忍受了。”作者明明站在巨人的一边，但在书中又化身为“我”，处处有刺，让反驳的人无从下口。</p>
]]></content>
      <categories>
        <category>Artical</category>
      </categories>
  </entry>
  <entry>
    <title>[SOJ840]小γ的使命</title>
    <url>/2020/02/26/%5BSOJ840%5D%E5%B0%8F%CE%B3%E7%9A%84%E4%BD%BF%E5%91%BD/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a5939291d35e39279fd4c67c656558599ddef0e2d592875fd0bd35eb65aac124">39b3ab97ad2fe4a6ababc42acd0b026e76dd316f9b0ae48f37a5a806e53974f1d0afda32c22f6aaa1dc8fb583635b686d93c44c4c0d8c790d8bd526bfdc4d9def1cd55af94208c87bffe4dddf6fa8672e6d61cdd2cc0c354b2c7964f783617f19dac6055fd874f924b53bb533632d0948ec2569f6c7ca09eeffc76747333013301b6e7f36e2b47be803487be4ce0fa814922eebbd20c764e38d31ad550cac5a7b04dc5540402485cafa52c4d21c2ea80758741c45b074d77e7dad66c0b168db0a628ad917e32e6257cef1c5aab79a896a8b17773472899b4903a50c5bea144b860313f63cd435847dfb2af442ca68ec2afce93305a88ea2ffb211e42b37945564a37809f680726937b78ce2274189b7d98a4201f0adc2bb2cb538ef4c2f9202d5e44d9565bc2e52bc344211765f7770762074d8f396527f273238c9329110045428f7a0b3f30d178c772d962eb2aeafb0b694b0acb78ab7512da63f00880bc819aee3df187cd3082c2a8552e9891bc8c4c82fd75b4503efd4743b295c783e5c218bb5dd81685aef75bdfeb6fa0aa43ac5e6516ecf1ca2aa980b3370aed589e82e87eddc24790bda0f0102179f6c65219d3bac6332b53bd051d27287462293325263009c6669826faad236c25c84d650cc03ad21729d2cfd2431c07eb8b23095e538465e5b4331bc8d1557aa46a3560fff2669d166026294b569f15db7af001c1901d8c0d80742f8a5f42527ce45e1820f1018d40a71bf2587acae47ad75c165495bb31d63eb70b9cecf3cb0070e049ee9718016e046d129884f5d503ded0475145f186e10a84b43f43b4139c4cc785eef4756b6efcc91f51646e4306820c61d9358be2ef1af1595f8cb62d4968e54a8d69b17907b2388a03b4e66a53dc446fb577f30dc7e7ceb81a993f8579686eb5e8150a3011e89acfb1c8f1dbbead7f5afc758eb53baae2e0b63cb3754eee37fdb955fab3a1a277e7b176a16387acc6a2da19510bfb288385397e225ce52b9f213a085c7453f362bd30269a6e0afcd01e8a7e45cdbd9075a3636831a137059a9f587952ab6517c679857e790c079f281f5ad3962be74eaef94b75f037d8deaf6eb6c1511e4aa093be6619b24f7ca6e430521eb8bedf5e4cbb7391452c65e5b8dc90ffdff8d60a174bb49d9a068e4baffd838dfabf844a7e9480192b22c7eb2d89dcfd90bfa05422fed3f4ad48ceba6b4bb3751f4a36eff856d313c4cac00191b3a7cdb2ad26be150e8f2b5776474ad773128afaefc436f0576702e5cb753411dafc5d4184fbafb4cd4d7620ad8f6508da7d5a88279115a814face1f04b3772580b94e2dbd3a4ac99183718fe95d968f87ad203909c501d86fb3c9ecadee9f3ff496db19aed40540b07dc29d7f56f02d038749fe3b55852d337afc115de41b5a4f01e42e4274b16ca3b7362b1fc877f429a63c5d93e8da4d843915a9e0c6ee1c7238fbefffd83133467a6d1234b8e0a3072317fe207dab077383fc52773b2bad59b54dd869e8e03423184ef50dd0c8a8394f599407be7e731412c9a0536be5f85edb7af8efb02e7103b7cf70c2aa72addcca3f1707e08777ea58479f37c3e202679266558a81bb8e52c9bff73789a7a297f4bc2fe4ef756367221fc864ad23aea5552ed6af80f0aa3b5b1ce2eddaf21a872e0200854ecbad9ba7af3fa999b3305a6292738b2e0cde50630ee9836b21a113f144bc3efd878a06b6ac73b071fce20defe63242e1f13a5f5a29c7fe99819e47422830cdad0e5cc10220d7ec5fcbb9ee8739168c9c785b72c165eeffee6572a7cda63720290fa3acba966fc782d98dce45777466485d8fa3e3a04bfca6bb1043e9273010147dc3b94c3877399b2a1cae1bee59f33418b2276449045c173c88da5a1e778cc4dca560425750b278a47c757373c7b6918a1516629ee3534933eb7f0ea32e94654df39067b8b4958d70c2e722992f90f0248dfba5a0886d697498cd68c1f3fe1926cb20d8118623976484079db0d02bcf97320b30b83af75e7e7a1d9cea05c266008c1ad9282d213e2875fa3cd8328c82205331261bb604689c7f846c31f574da8cce3be50a5e12e3b21dcef3ab8b306a4e8c216e6d9fcf93f1758d2930fe9b6b6af6555bffcaabd9889844bf726408a0bc2833769ca2447cda719fdf09ee00fcf33399d7a60da6423efca765adb6f406604eb771ba9d17ce34a4a1f07be60b2afbdfa9657156498d918a81843e9e0fc9d938b7e7f79e4bdd777998e0822847341cda8d02ef12e08985766d53b56533ee3b8eea621cf75a994b1118a772058021bac7fd492dfa616198c8dc7969779783832b8ee490e572b7c87786f69e90d0fc6a53479b37b8bf9968f25f0e79e226b8726b96efa9ddb5cc31bd998d62c445461feda9ba18a6ca7bca266f39734d8d5daec2c4142be2b0beac0cd2128abec0de4d000edcd1bdb67f7c776bf57528d4108986fc1b8e29152e8d11abe60e38ea748dfe4f05aed1434daa774414f879efa8c4109e6f299b0a1191985b22a67ccd547a93e86cc61cf179ad4eea4241f232b4946fb873fc7d83f8bc11bbd2ae2513a110a4df5851eb86751a0f7b1308f691152526ed3fb6779e4bfb98c9a5c3364559de943958fe455663f2b228b9efec2c4361ce0c89f779f06df6b8898300b032cd3878414387984b251085c83e3139490271f32f2b9d4585cbfcfdbc1a58afd2002df2e4b23261a4c1325a1ab5655a3967e44e8e9b0aef8995b60a2038fabd904fe40551ffd11a2bd106757cc51ad6d92f54ab5d03d39aa7b25ea0c0d603211ef2e15684fcbb607079390226fc5bd9798ef25b0c991808b85209eda1af41d7fd9d2ffe53efba77a1b6eb148c5252846451cab9a3f8aa71609895eb6d81a0a1fd8222015eeb78dddf78f7afb07a677c1272b65cd385abfdd087aaafde850df1c3024f2b2c3e7aca7d8e2d27079df3e7b95efca15a8f95b00e84c2fa3b0cfd7ccb8dcc06f3ada1a1d7e81c66d0b5d8757075f8b638f679baa5e0cd2caaa6ddb4cc46f2d3e41ff65b36b16e270fa6d84b78651797b576935339e04a4603fa23f67b6df440a1f0e38d9e9a56ece02cff8fe8c0d2aac377bf24452c9fdf467971fcfaad0fb74d32a71a3f1bc1d4a62e0761a368d64f9e4c9dfe3f19cad6dfba3f25cc6443f5266c5744136fa98ba67d7218c9e509a1c8258e59aba02ac7765af698fe0825efa5b75edfb32c6568e3045c2660d2a1547f601427312ee57e0b68cebf3c50c89825aa02de7285d7ef349efbb213999ed240e8b18a82a734d9cc5e8398b084b7b25a3361587db2cba9ac4aea846e4258b8772fdcc0d929fbc8cadf28801b86e16874d9fe691d607798351e56f4c8b169ef6cc5a21d81214a9ccf933f8de9ccf9047c07f848235cbf6a2fd30fdac00e75708af122132ac09f3b92be3ef0ef79b0a914a2942692ffe627b53cd47219aebff9496f2cafdfbbfe61d09fd8a9a146348f6e9ebf0a9acf649058f4f00f419d76c258d27ab8a6d34917eb869100236d355808d102ea7704529e374a4d04efa748e6f4dcda46fd7467c4c884d3871942b796681a5d0485f18f7d5a00a21ed2fee808424740fc7938098ff5ca13a527d87486c5a7a3fd09866f27765bfa38c5d165eea2c3b4402f2ce669783c4ca8ba364be582c3ce549982f120ba24bedbe14974c674399a5f1c31b1d3fbac2323b35786baa9dfd86b16e37997acd7ee264ea258e5b7853811a75591e3870d080a0f86270393f4b7e54ed5b7e0a13771cbed7dadb986303a749ff1fa5c521b2a9c6a6dcc4c016ab89442585ac89f6e530da0ad49103a0d071e5b8d1d80d63899c1dad657ddf726d980120e3f75a4a7db6ed0d202f9d48aec2925009322bede4a0090c4b1af3e89be0ac6d32387b2449ec701147bda01adeadafb5f88c734acb3a9689bdb98044347cf1be1d82faffffe9e07c9c3d7d1760e20b5c02c9f0b45c5bb04b37f2f3bcab011629312b1e7bfc7a7793b8612b113bb254ede0f58302989e831b2b554df177b9400c4a6c03d8b85e85827efd3cc88811ac08e7484a4453754e89e318b1cabce8f45aac4b6572cc00a686a41a822af577afa474f4e741cda3a0a10b026106871c68a29d2759c22fcfbd6353f82526e026d635fe5bce63bf15bf807c0e221f357908f92bc6932cbbc86235d8cf2d53456a1f77d20bb5af1677b48f7cbfb498a026792509e2b7b5d967a32cd97a2254392a16105050eceeb0d17a5cf00cd99ec52305ba6330f13898e6eac46c10326f508098f4eee06252684d595870c1d7cf677bfd93ffb81eae536062b8352c2d63098e1df9af67a397747b3c5aef737cfc318f1a8f7afb8fba95f13a7e92a193f0b0e01bd29fbf756e565035d5b1ec062ae770e6d9a1ee0bc725f9c5a9b4e867bf5a08ee766e58ea58c3b6c4b685b10c3b79be2d1bb7e6d3f890982dd357df8a579c2c62cd09fae14161500c1d7bfd33d454eb0bdd09f65f4bf4bd3cb373e9907c6f0aac99910c46ba603e4a4bca902207f5dba44f4a5dc8f6ca088a986e8bf6c9372299969bc5d38a205eb343211f75d48d036679d37075218a2e503753e969bb696de0209a929ebc1bfbc4d9a1fc8517f18f525a527dc4bcced7c8245d8c665eec67c9e281a7b224321a8ff23cddc388026965384683958e9e91fe00b08d4dcade89d84e6647c34b5acfd64a24654def1398e9b582b17897b3d8baee6d724af41e85d26b1668ebe96afe951d2b501e22ac86de52b1dc55e86c249f2b322c583de64463c2beb09c814f5dd57a1072cf0dde5562ae688cd7da037744a6286e36bb420bbacd4aa109e98b585472ec01db0d7128f122d883f9f3f40ea86096c25ede4c696ac116a52f3acd137d6edd76be3adc4da8e962aa18086e36747ab8672aa748fb355f8a3645d5f9f8ed5e1f56d175653e2cb6f07eb7aaa8e1ffd7dbd4216402a6be30166dc9fd29870b12caf7f444124ee2074c212d6e5dfa4daa80eaaa30d915aa6501cf46fe3ddf75b785ecf18f104b41512e64ebc871dde630085fc3d11e4c407d5f36e0dc9474d48179ad423ba3b3f3a01eede129b432ca9189a4dfbba2ef23a69d75e485f853e052edbfadeef3ce76736262a2a29edab09df0b1c2d2e4879afe0bf06d9da1f6f941c71a2004c2ada07645d440af8c6af528d6b344f5108414c79a60959bbaf71a5b9b392626dfc8faee01750179c4d399d958f84b171cb6762ad7f9d8e05be79e61a3d6947eb1d49208d1a321fd6fd0fedf41dbaa17c63f2aaa6fc11d94bd8f6fc98d805d62f20bf382c3f5efd4eca7dfb6cff83050ca4c4e44790014bf6fac5993cbf91251e8247acbffc39aeb15c96c2f0b689de7425a623a2e1d04adae335370b253cc638d3408b4f8548a55a84dcfb70242408f18dd76e2033b8225c61871d69f71139efb723dc783636ca27ede584b7f2463262d4dddc5e98f9f705eacd12d1065438ec1acd7b941fd747dc41c4621ffec2ec7a8ac952947f576a2c3368a7151f5d933701a1c2078005a924f1a24deee6fe8557d64545a4b3dd604438510723eb99674653ae74a58cee49c554a6577274385801a9f077fbf53a6e3fee0118cdc7b6531d87b91159c771e8fd08bcd348683ef42301438db5dc1822cbb26b0269bebbf4986670efc3dc5cbccdda944e0c3662fa893177495fada57f453c75b6f7232620af75237af85750e65fbd67c31b5506824bd861975a695c27dff51ec29ef22c91a5b9e5b228004076ce3eb5af5dd2399fbe771beade8c6e15d5bda40d4c9d3e43ecf92269df4391096b0a6548c4855aee42ff58820e9a7d0d59973ca2bc36582ab02e39ebda00cd1da5f4c3132accf478c4de21c9b91c9bc8aedc920edb31d986f71d9f36a351ee2881e8f25c67d578038f73b99f0a00e624be3b79019991fe6882d6cbb41ba6a4f9f844a1c779725913a150105031d5ca44663a9e09f09dd1e780708740ac62a368e9755b66162e9a961a660fe7753d89861c887de10a7e26f72564dc24bac402dc27e3f434e241456adff31ea0c39756eadfba3ede1782c1b287cee109e82dc934b106823cbbe2ebd666024d677b90bd431956de83a30dd50dc8fb6f226e058cf451cdef11a15bd824bf20d0f9837ca43a6aade990961730e2350a35bf3111db917e3bb5c180768e7a625aa60dbd128b385662347599ba3bd0208fc4790476b33316c8c6bc21415a7c68770cf35776a0029a24d6e3164b67afd16e39382676288528aef92e24ac081c7a6857ddafb699a4b59326a1a2cd3ac0ad8b885bcc891e28c4f2c03ae5653f001246031d3c01ac5216a5e5a564868a9df06c2b6b805ee33d5b268a8545faab477add59f1fa86c6bc5cea7340d7af37a2008fbcd328d35e12f13dcfeca980d4de3c6e7bbeb998f581a2b2399ce4add829269763c26a53d706fe67f4e6731320ced129ad9c9ece4cd3309fcda861242a0f8f6503cbefe5edbe72ecba57220b21e2335955a322f0bae7e82e6e2fb8520404282b94550590fb9f4d4ddef6d261c1894dd3250da12aadc1e2430593e3eb71d8a693bfda4e4ea24a5d506420232d1b4b5e7b881231a04a3370516ae540562a97f75bdbf018c59edcfa6f9787a07dda1d0b897c97a9133c82df5d9f057a88992a94c1b876bff14a3b3ded620b9754b7f205c1f66d7d971d6e3ebce059980f507569cb23cc924dbf8a2a14780df790a79fc5afd4d60b818bc70724529bce0dfe8334b8c4e2a603d1d67d3032ac28949c729f70fd45e3ff337bce41ec6c73357c95478f358c8858dfc5f94b6157fb86dec3f360d0d6c4a8bc89dd405c49b76ef1a06ec0530ca0f401c69944b77ea2f644df2e5f84072cded20677169e99d3c6b82b45194d05b5a0931bd1caf02ae4aaca20965b271a002e538ac151e38426e10d6b62b8afec17c16c2682f20b869304b96f371b8f061a870425ea874c2ae9af4c77b2f0b6ff0204c9999925ea9583db75767dc465683e1a916eb932f13316cd772126fc42b1b0ec592e5a9e60313f9313d0b4381c424d5a1c210777357c7e6241e51d2a3cd97231830e9f9b4b568168a6a8ba999a74651b56929ee5d0c7350081fadd370d92b773ce1b4715f11ba5a376ccd85b8031f3f9f1cda7644a7c56645308b6a3efe3c6ac14dd46a7bc061f1880956e7150d2b59bde4834be63a104736e74d55a0dfa27e8f5f3c1955248f60f4945cf2c05e6849cca4d2293c45fa37b82b52a573300e687902151afa220ac70dc032487b391a480875c0a432854262e01aa633ad83763f057b2ba7bdc5af122f38f69ca69979e18a5aa1b641f0b7ce1f8421708112207df72647aff487ad95af47894e33dad00b96c32cdbaa0cab6a1e2639b13ed0b7296f005b60ec349b7492cdaef19bd9ef3fc4387c219152571fa7598edb3d2064f7c28635d05f5b74c4461305799051911f42d24f7e9e884a5736c75fd6737ef5a9993db498b19d0ae34f9c91aa1bc44efbf7c589635eae32a09333c2d08ed1f0d44a5cbf7bc4aee31ac5f56049268920a8b1d4626c2a22ec3f9e60f2adaee1d678638f1f5f38306d2448fb8bfed198152d6f79a07db58524baf7a8f3740a03081c7574c0963fe4f3e18b21494d47683918b193a35f76ef88571e3153a6c5653a289386451f44171671dcb9b9068031929a10f3b97909c5f53fb684628435a30381c2791fd370b65e7595233b179b32f8cfbb0dd95b6529d5ba1f615b98e14c04c8a66eb646fcf9e8c6084a9b0e31e9c41fbe0c00f45d660d8f787441bf51fe24dac40eb46da9d9b6da951ad052846a6ce831b55ced0b6429d87d0af43253fb24e65bc3931095934c48c453d6bb8c1a44609e851a87bde68c93ff018ea72e8216f04dcc3ab440e969e89de8e867d335afc859deefdb8dcdd3df895d71c3a535c525bcc0b636c2313b9649fdd2127b9172d695f38f680e40f83b8dfaa0fb1a01e364d2f0209aaf450b84d9606a961bc6283e6e6a1f9b16517e87636b132b787790a5f4dac2c5ad7a25a97b81a959f03281a8911147233c2477ad2692116ea5fe28d23748da2c2e9ebf399661ceafe6db4e63b2de6f9f8cab53844c7f55b7ff536452635acd8fef905121f40a8874fac4e65d411ed75a337e7cfa531b6af522f8d6cef71c1939ec0f194b883c464ea0d3d41c571127d6c274d769e216ed92c1a5f63d17070283ff3eefb5c1f567432f616725025a53be906ed4813b8217d622440e1155c5bc9eefb0095aa8291efcb4c8b2da8de0ad9b41518cc7e72cc5b40f20a3b46efd720a95195d5e17f0d42915a15be5a937d10d0029ec9237436e0b961e53b9f174e6929ca90583c5b7cb3692defed3550bbd2e8e1783321a4998233ef850180098ec88e7306ff3c290bddc95e937a007810f7bf2d8334f0eecc4c0bcc3a6649c211b85468ce5767efdaabb7ef0559fdc314c76f59241e833c3dc4dc1b1d0ebd74e9d78229ce4baec1e5317664da689f397aca244fe08f335a8e3342d0ad59500add9a3a0c2e7cd2b74576b8a9f8ada1259c3f489dbb842dedd5ebab52f1074609adaa3664114b1d6c94d31f22186f94640dcc774588bdd49da1973a27592b5a9b9d5a789c8bc1a15af3d170386bcc7f0cda5e5ca753e41876bc946b824df7bcd62ebb83342a8c3b4671d892976293d65dd093fd11ec98d27df27f7ce002940a8b402e61406e94d1a5cf0fd32c01788bc8201db56f092118bff4d29a92714863ab596c189fbee566e7bccf649140a84a78060b9d2d8450bdcf85a34da9e72b0a64104da991f7095c6957c3c328847a8c41ca143382970e95ed743d784aec31de5c6d35bb6231f0ad0332033bf26351c91497bb7caeeed511171446f75b385328328e01a0e97085ee2eab1a7e0ac4de97b411a76494902f297a3b3a17b5de640c098606b8b500d1ce4b54007313386fd646b7b6918cf56a7bde93217b78b70127ec2dd15903c12c69d2cd9cc94fad53d0b6f0979b6ef57527b97053a25df2882032638aa1d8ac2e3ea391ef1d172b0bf6df3e2a4c5d795b873e78c2c7da12c5aadafe29bf1c8d46915af999462fea04331726f758bbf1b446b2213e5c8ddaebfd7ccf8c320714ad5825fbf43233e676142276b89fcef611740393231192de82ff92931a793870adaea9056cc6ea26049d1f3c5535ca5ba8f45c208f818e890ab052ab230348220f53e057bfe3d75866508ad1bd112901b167855fa71f7819c23571e7c13b16c7519942844a903e93e042e5d81a4c70ed25aaf570e99b9a368d3067c2b148e1b649764abe9a1f9d368aa6c7794ee4dad497296fc8fa9db7ee551cd684f4f2656ebd3d9e7db2cddb77bc1e34b8697db0dca48ec9b1f6c35b32432523da69f12bd622fdf4127d36c4bd8931c2b0234ee70091eb53e1d5fcf6bf6538db45efb49bc3f012d2d38785aacf4e5db1d590a78d775a54ecb456c2646146f0a6b1063056df2a30c75b7457088156d63c44a198d85d50a4786083dfc36a9e4fc9246dd5cb0c4abda56251f6a857949110c8a010f78e873b1128f05f4750755413dc9dc58f055078348fb27a3e0a09ce737988ce52064590eff789e9ad9050f03795708871ceafaabc2ace8c3092005a7e85a4e0ad2f6827ce06f479f558daf081695cb0371dfb7181618f97c6b6565a3793495390a01c6c2418827ac8170d4406137ec6f987e5915cc1620271e2a75fc28f75443ae266999bfd4d58b86c10351e1b38a43e6d3c42b1c09d1b5a3a8311427de6d9747fde697cbb564a32762455b092cdec995aaa9aa58a07d4c96acc0ff1f95369b96080369857cfbc2b28f16f4917835a687275bb7cebf743cd6e65149b8786268f0500560da2f3d0d57348e91e1031c5daf662a04cbeb9434ad4b2c95338c15f6c02ac648d7133f612b40d2613b10754319e74a389c3574722c370c4476894cf0257fd453a6fd2ef75a4f389592bc7509f099dbc10d652960b256042e088940bdeb9da5babc77863ec2ad36d36fc8b160bf6e201071e76fc0f8bd6f0f7747825072b6364feb8a4668131e9660b3ef5a45dee39ab2a750e8f1fdc65656d67d907a3f288f5873cee524a5ebf501e5d337b5e8501bfc2654712fa36975a324765327a4659bca184065497c0151920a006e28e78ffa9cb291e60c1c752cb9739298facd975abd9e7b8c5266042a2f316429af81651d5f7969815ee1e4707ccfef6068310ecfb6014cab4979e0388a7937b955473c701a451219435e7aacfd15e8410075b229353e877975278d80bb232ca8ad2145427750164db7cd6f6e8545b107be7dd5823d0de9e6fba5d79136dff7390f78ae828d349b2392d4b0bf494b116f8f3e504611c1918095bd5c5617ffae93343078a4ffdf64e3852206ac8c2658adcd757db2c803c7ea7c36f6a74bf9adfbc17b38cf7c8bdd853a85a068e3be724db4ffb3d85e34d86e2f426b8ba36a44acd9053083fc2e3c40ee3d697535dfeeba28159ed3fb36795f5d47d3929c4d215a2a97a19aa2c1ed5ed4b98ea7bb39bce885afa1fcdf4162cf5c982c4e149da096c66be52a91baa1dcfd88f9041d032204da7f93731ee0114f3f756772745591f656b96c342c38295bb4740f1903264c5b41f259685479188b58483e50751456d05c550a44bdfa09b12c8261ae8d096a97a1ba3c81583476ecca9f2a3bb984ba0020f68c48ab2834b676804ec5699ffb0707dbd9e00b33bd7157e813fff5854c8fa847d37487651c6491adfa978cc9634648cf33b75044f32a2bf0b5331ff7229dd48f8636592d5a7e1510a3cc254a020d0a5a0db200b05d729f6c22414e7526537369b00955c42ffd11f90815cc56aa12fa12676c743810dde00427f666ad1beee57922b2d381254e4f83d6f9bdc09985a633f9b1c6e5d174849f3bc2df1bf4ae0f7f864c7bc86f9784859cb961ca3bc8a8f1b590af895eac57c9ea966102865a3b1f98f0876bec97e5fafe3967514d14f1c8e573919666a2f5844bab624fe528d7370a940f1b1f9a19a4edfd7c7062f9697305982d4a5df064383faf1103a4cefec65851a300fe043fa8769477bc80c5c6c4ebeff56cdf45d5ef7ba273ba5ccac0b7e40aac5fbd0cdbb1ae36a3fa51bbb3d3b74e30ad0fcfc8300c56042e8ade71f0cdf0b6dd3bb46cb63718072a1c9d85ea1c8c15dc2abcfefc066bf220c612c77ca6423f73279175b6f9ed51a92b55c04bd5e7a199c6613655c232a15e99c85c3e55b7764d3a2c98ffb4fe75d5489d573713db629431867d6e0c7659f65a40aff7daf96f5bd8d4d88c9a42f31f34fc20d9c070638c1c7a9796b4466b7f142ecd3a84f049ab1907b7694119b239c88d2395a72b0dc53e409bda06d8381fcc2d14e11280384b03891543d4ef5efd9bce94a1e2701af9b9cb236470259a683ae53dd552d583ab055eefacf6d42b1baa127de8c7e3db6cac5af6ff3c39c0d02e7a4aac7bf05cf94e8a1866f010ab13f9b77869197166164a8942f904df645d9a92ba490930094e251e47615ed5c7354094318dc81d0dc02579f16d20f58d3a9ff8e6dacf7a6fb2e168f3f61e3ba005f7cffa9e76688601a423d637c270a867c94c4b1698ac84fbf5cd07ea28fd3dc3e9417d8e3cc902a0bbcb3f8c06fea90bcd94fe1147cba88ead9718bc92158da786123ea4d862eb4404d1adb2180cac816b5c6875539dec39cd65d1b2b05ac10674f991cf0117a04b51af55c41b886ca27c6fb7b55814bd2d09625508150461f6dab109d75b5a1e3cb10c0f29ba8da9631f358d04a43bdea133bc68274abed88b082853bfe6d63d7bb2389001df5ed49e12aa798257b5bae25dc3746423bd4609c3a082c13958da0285fa9880e6cb6367d71c2dc80084fed4e0c92d6b2a4ecbedd0111908f8d7b99633fafa5a2434a90c192b2b3c535d811293d140a9ffadbff0b39d36a9d88a743407a85db7cb89835b4864acc0b1cb7b2325f6deff6bce7f48dda8ec5a3f0abd73a17f0ba2eb374e1737ccf5d5689b0c1129b7d9919907a90a73f0a835759319db35c4f35622e583742a97f1a4807a6e500a9ddd29f6b7817f0f74512c3d27d5da39e7c04f225787265068eeb0842c5f8c32707055d6af304e0746cc2372b4537167e82cf883c9cec2e2b4c242053e4a19178a26f53a515528820e67257ebdd69287348d2b6a9f5e0673928fb9eb49cc5ef1b4c5a8ae732e9aff8e82da0d69513031cbe6b09e6d72495376c70dddbd137f73f916b6a3f759b3182d8345deed5a197811de02415cd50e50fb56654ec0b1957746d1ab39f1e01d3621195f04f874b3f8801d320af901c799de0b929252a7bf5f2ff91620a219be91ff7acee8f92b94421eba156992bcb91632e6ec5d9389375f04fab6d4c79ab85f8bc3327e3b3d8afdef91b8a70eb81f5a0e9ac763f768b0a90e9829dff3e52f9354d2e2b90dacf4025dc1717ca5d5092d5d0b22f6fb6b55302a7da95b823c93bf2b11bb03d952674209a04f739aa3c8b2bd3483e6f305f0abbd2ef1ab728e1b76b832cc8f6aef11ec04969cea29db580f89a38ef1432f704a6ec650b1c1d3093628871bb475df1b4d77f4cf8a7d788f3d766dfc7b96a6360e2efc61326c6b483f8d3aa14a62a08c978c0a9caa7dc3256ae7d34d350c062a1628aebf6efff41e764481419d16ab143a7ab934f46b17d769057bc00a8a38813a076e65fbfd8440cebdfbb86ee1629cfea0fc64497a0d24cedd9a03d265fe6a650fc5eec911c1b293be4a6f73a0d2fe1a62a863db62a9581ad20350b45b9c4b211d5b2944eba7368e19dc08d1e92a8335484a1878b7e1e94bd14ed9a05d85f3a9a1f03b097f88d5afbeb27eb52ee1d7facf457a23c9c5ab32578fc6f97d2cd70427d1061d694f6349d2ccef9f5f9346799e6c623833c76f01c30acd8e00e99553366302ecbfea1fe27809c63a2f5a4b7ede2605c38eb7a529b3ecfe4c6e676e6f1344581f9dbb49eb60bd13041df7dad3c4ea4e2dc32a40ba7a7ed7af195f93a777fbd0ffc9a6e35027580f56c42a7b504fe321febcd83d790db386f351aeb2831e10dda9171c03aa2d378213d8d0e92c4b1651cb818f236e0860203825bdcf0bf7df07ce157562541ac2210e61b346c21ed651aa7f471efb3e80f4d0c653957ea87831826974e53d58c6450ed5a7c051f4d2ad8eb42d6c62f165f82a06aa5657c7ed309ef49994127606143e06e508f62eccb175c6bde611b7cadd3ff0815882cc17a9feee8c2d71bf9ce55d51e042968fe60bb5999ea3415133ab3d9352365a8160eeda1a9844f497d7bbbb6872dbc1c076fcb03f19bd4c636d3d805c2b4cd0f40d33fc80751e1c3425c35e48ebaa6d207fc2bd2eb0dfd2b93604a71c19cb31b85dc78c1b3c7e91626fee298053ef8b0cf70267f61a33f1fe97213ad1a124b601917f520be170161bb15bae6f8c58464f48f46aa15364743eb4b1f408f1ad22ec3b22219b0435b8147beba3b158f9bc4835f5630e7964f4088c3bf25305b26ab985d10dc0669ffce481679193f1c11fad27b1e6d8f61a956d20b228b9557a6296bc08adada3ac83b7c17e2044610f61b4ad3439ba9a322b8544eae72eccfd33d144c32f4456e96e3a70f29ba43b001113ff100acc5d7f7469aee68fffa6631e9fb74490abdb66e89deafc78af3303cd9328344612d21044fe9f63b67ba9df147cd4b913248ddcee06efaa7f145c6e5f6f7378a8332c47e0d2e0e9bbf097e5f98c158fb0cc55dd7d401d054c48f8cc83c094d209e663dea598006d0d2bfb3c1298cc72cab5f5efaa93b9181bd8a53fb9417a9f7a332f1624573b2aea4d21e56222f108a230a25057211e70fb576509428bd39ad543864248ea9bb54a75851e408ea9e305b7a8b8f452e86aba90aa23b7de8fa0daaa0b3a974a0055c3aa9f091a8e6c712809d685f426265ce7082f87095892d1e94ee6ae8f2f2319084e5beaf77f82080f3a832e43e32279727ac661512668d991135adfc9b897093ac06a7664c054f611f3933e03b7c2f11f2db7dcfa080f84b011c8e742a7074902274dbae7dfb80f36fa23e2c7608ec8a3ce6d82d9820b0ee82a8c66d307267b16f9f9e84cd57f9cf8a6078efb9295db50a3b5cecea0cc03e0be8a73c1c1c62b34c3297dd1cfb08a9ae48c6bdfa7d68569731805bced3e5a84178a104d2fc0e525da2016d5ac13f5bddcb2b161842c161800498f90a73e8893593f476a0fb35de2ea6bc0b72a63824bb6b4bf0f44080d74ee36c2871b52fbbc3337f9083f1e0e5352f13117e62ce73b8e7da27027b8f53ee7189312686357f9904e0c2f869a046a1554a533a6eb6f72f6b6dac86b3266e27502c137af93a440b8a6b4d59705527dbf2755000ae56d1374cc61418aa8cc5f6fa2bc58136408df63dce01266fdee4e11353cfb842cba81d182c04b225555c37e503baef92687dd588c144986ab84861547a742282d6158f7be3ade3e4ed2aa4b234fe4dee47c8486bd4a9281f0a6d97dea55ad3a6aadb402c29ac2c1712dfbddd7d6db6c38963f0039e651b361a06bb78b921a7d9447f1dfaff10e925ce8005454ce50a8028c6f3352a5012c83a49b460341a63f33027940fa6c18d602d6d476d6da062efb52f4a8c410f51014617fa8ad517d1335546f614178032bf4485ab3de5b14056988d33340775a471d5050041320d96869435f4acee71ebe2ea930bfd723907d150315114507bf169e2bfdb7faec51592c1d647f4e661b524d4ecb60f6e6bac301b981f0964b93dbe840e9e8d4bfb5c6cdce11790a91172cbef60d690037d605c70263904ecba769f6c8a7420070932ea29a39c600264c56f82d0a0f184dcd951266448abb1016994f6899bb14a3643a293c8e1f13d5c87c0d3bb7fae9ad5e86609021271082b55b13d6aad87be31996eac98eba1d8a5e2b51f577327b229dbf4fa1135de4dfdd82440450cb166beaa3a0599f52c767cdcfd7ad91999b5c93cf4d3a35942443d7fa4666958482470936f7723015e340979847c5a689660eaa4a65fbdb8b6c98e1af13e7c452995a08f252976f569c34043580dc7dee69bd6af05917247e0375b4a10dbe7cde4e08a3d0912b67af0590611a452765a4de6c7512e76d29d8a7f3d9abb9c649c2dad5b21d97eef18818b9f6407ea739c837a7c6b59f760fdcf5c676dcb4d39f89cf3e68c57e5c0ca58df203c044b93eb52499c12dcf2dd206561adeff54eb68c84f78b2991b2c67fd41a1685b003ed49c20b0c55fa7b43df879b527177c49244f2ee05b15f9a858b2fbf34c53b5d0ee345cbd749a6e7bb41a89e26d592a1ec243957ae46ed767cf2603372ecbb4955e18715a3d9e897aff14e477cdf644cbce4a492d1a20b26e47d04357c5206ad8068b4c9f6db542df13dcca7be39775ba60550c710360558a6a753ef010ee4b31ad74f855ef99eac0c9c2d1dbc7031a4bb20b3d67b8c49e424c123b2addbe4fb78dc5a5127fd4d8e0fdc27db5169986de4ab1d8da609cdd70bbb7ed108a9cacb29e3917e9863249e63b48d524c43bd2019439b62c1d5f439255e21af7a97c0ae5d7cdf185b7362e7b5653491b6d2ea7457263dc07ced1070457c5e62f39363e47d2a921d786951b63ffbb9006f29544ff889541c4258ac1532747e868b2784c8ea37ae1391ef642e8b3f81b6f6b129d3a43c623e0dee0236c7d22463cc376d7672c293af7033f7715e416d3e39c544eec5d2d05676b9246d4cd33f7bd84972c69eef91af846d5de54c76be3567021654d41e99f3cf2ea32e8995139e46ce29befa3d83502a9bca16338bd5403f765cd9c2a3b7dec63fbd6a4831852e8fdd7340d9ae91bc6bf567c047ab1c09966ffba4599ac414429725a352707751cb39e76e795b62b91676b3e3b52f6e4280f2860230c35389bf6145c55efe80319b63f46d9e40d8d4fab45429bb1f661ff53fc93cbd5a8e4e2f03dbbd3abd75a1c647110483fcece3d57f357aab9fecb51981692aff57500fe93454141c2955ff788a9569ac4d129015d6acea1cc52b60f7594ddd3bbf7d2a84a4c29d4c845f6a96eab957edec319b094803124998f39a49c72d7805784fedb58c2d0e1c15c053224c2e50cdb5d7e8b1ec78d8a4881c538117817b80bfc621c306f2210228e5a05482791215404d1d714d812e1d8a7873c51c93352cae9407e36dcc461ca64c286bf052861b1c402487d355a52b79320e3aba8804f62d9f0b0473a504fbd123e35c995bb4eadd95815d402a7906316024588020914b5a23858f2f35515d8589fbbee65f504d8caebfc8573d6f0825a8289565f869f2f32f326a09ee609bbe0b089f31f11b6d23b8f184574b8983d0b0aa44c23567e4af0993028d1e2d40402be8d2aa7df23890aba39bc25ca9ef6f69277ca92380c6df68a090165bdc209eceea311657048935471c2058e3dce3d50b8844b3c336cadb55f21327949c8fb334be362d4086c42910276f0652be641f00e2c44c4e8e62ea4d5c48daa057fc2a18d3fb24499f33fda3de70360a4a2f36f7bf258f2a3e752d13d8f4eb6130b696b61c79ee3eb69ca8af08acaed0b12da977483aadd3ab5fbc1ab6d5c1afcdc1dc7a2b10658399313b6cbca57ede5bb2613a85d4eca83abb9786ac3268d45f7ce87f0431e3fbb793650a064a3453e6733800499514fd780c8fbf2833cd121870161a4f64bdd988f4a3f5b3551ca84cce45bbd0a8e99aef33320381cbb33917cca432115b9691c9ab22985548a9d89cc695d7845b9dd1ed29342da2f7f55e8a2128699b72c169f54933c64e982d5095569f5f799560a96b5b5ff6d91c11fe3830727b42a4e49aeff48915864b438c1aec06cc7de1b4a000e7f936cb771f75cf461d4013c3d41f3b0cb5a63984a0d58e0cd7f1dc6b7092ad7875da26bebead6d38ea85721a120ee63167741bd7a0165bbaa3b39ab12674b1203cdb28ec130234cdbe87e9d6b3510b07436bfbbb0665ce11467143c5854859c68ec72045029c894d770b4b14aec288c5d37794f6cd8f5ee4af39f91eff5fd9aa51d7c8bdfc759640e49ee89080a797e7266cea1aae16c7b4610470aebf077f0de909d022fb3c042ba7ae31434e292a96c4d2bbd917eb47ec3a2c857a92cab4c4f090a1ed8aa2a5cf0af5db698332fc452267e2ba09a35dc4f8c98be5bb5a49c3aa982128d815c41c727dcdd07574e69c583f76c0ff41e4b0ae3d34e7b1c803964eaf6591536cfe0a7a01ea119758affa7110507d8c8c892ced86fd6916198b36fcd7967cd35f614bac865cc3e7aa72c5e1416fbe2b849ed791ce0e927691f187842a1671d33add747fb9467950241c03b64fe025c5664d304968e3406323c82f132223a54abbe1b9041dbc26a04e4713d88b53083e41c5e12c17e14a7bb0d3b8534f008ffcaaf42a253cd0250b0270f32e39a3ca18a5d614a6f1cd91f957d06e3e6fc750a63f8529553971b62393850196e123bfdd845eafdeedca638de5cb8db630c5730689ff262eb824618aa41d957195e9c0243468f0eeee207730711cb27cb8ba7245a64c81122f80cab8a49a82302209c75389de1b0f4d6b74632b76c9d0109d6eee5430020045e6bd025fa83916d38208e95a33df31671600c70a50564edfdf8dc7c9f1cccdc520bb0236cdd1092a668736b0b3652dd2c3e5f83a4ee6fa064d236aa01515d5fef23f491dc23b3a3d605ada82582dc69ab98770aa7ed2fd46b48c6365acd8f4d59cfe0fa0cc48d2432f7db4cdb814110e53a71e46bd5587e0ef0be2b46b122630fb7153c8898319a3c678aa6793640594fdeb8c117e858ef9e2fccf706f9abb6487666ee04b8e61f2bdddd21854eee832f9a95497bc9c573f127636415241dd972a56c966c098a4f27d41ead58cc94361fbf3802d36ea28e07ff7893f6c226bc9a2d87c495f52e864f7af40dcb5db28d0e00387ac9e0b8779d3b8c2e1ed6c4a127a0a0abbb72593d702821652e78b8aca19b3c8f363ea5649a20b0958bbd90f70b25fbe9b083aac964cb180350987bc4f5a52bf55270a54bc7e2f7b83c2372d8a26f0a9a8c085e59de49b4b70a892b4606c7c709d89cb6e3f029d74490284eae979ae91d4243a0e749438ad1ef9a7ad11dcac24ef5415b43e3be2810d0976217b20b4767b8051870180b15b4b24a1a368f0453e34d38dc98d69919ea6a39676c3a7c721067c5c3dd4cf634137d6bb499d2ec37075b4682851c0c5d83c9d386f3c44df811f987373911e67e4c25cb9b43139b9e046a85c15a91dc2c2d3f62f14cdc471430613faaf04533d0e4e6bf34b51f108c0aebee1fef69a22791cf6ec47d51c625d38def509addc711326d03c86bacf485cd073aa121be651eb4f5a9ac1a74d17b5c8aa6da7b3bbf31f06260c61f0c6d89f2007d340db2d7b16969c4ff24279fb84a7addf76bdb38896ab3be1da556a069041fb2f5973fcd4b17229731df68218a8002d90174f82dbeef33d9689774d0416a7377cecc56cdd655203bea9493b01bda2b849d90a8c40f173df59b53ae30f8f12dcdf9aa6f9b45ce09ea828f85810ed4357dccfc3b67603a07e01d6fb2c38a1c456eaf228fe56fbd0a2b973962cc5d8d083e731b6aabe6b9a3d76a1fdb3a8e92cd089828f26ac9f84622b638027205a847fc12a214a3d69e57101bd2ab84ac82d9b5e68a2446cb44f40a85b1df1cecb0b0a61061f93243881bf912686f6c11c2515326083ec3f70f02dbebaebc08d988763f3674b3c2cb15afa2cc05395285d3dcdfcc1ff77a3877e0bc80b29221aabd960c3bba951357b6493464a2fc9c22d959fc774abc6e21a5f976ead28da7a62dd8f3ba9e1944bf580a48642b4cbe55902664e8b712508f630575932c9d5f27d639646ed3c40933c311865fa65dff1322c3c136dbe94c50be4238806bbc091758d6b2434aa5b6c11ae53bffcb174ac8fa53dc0748d40b9f5e7a35548a14c29a0fecac5939936815137959c810f486dcbe36c0c4cb1c88ab9d83436761fee516548f63ae9768810440c0b784ab00dae05c8156f629f17018e36e8d65808bd72a8b5ead119c377d16f7a58a9c77e98d50d09de3ff6bce4d65f117f152d9ccfe492b8d46ccaf0e1e104d6d1f94abb61cfea38ef8debc6320a328ada9e173ef84f20467a2c67623d66dd9cb85325c26f4b1292fea190ab6ba6125851ef8fe1afd469d05086f50c2ff2731809b2d55bcbed9aff1e003dec71e367ed7ff9d89dc01ae722fd78fab7dda1a8436f7ff9a9d991eeb32f22a0237c198ce3c192a2659b57ecb140535bf398f8e9d066c15019cb33d9414b484c5b23f85cbcdaaff24317f9b169d81366e0863ddfa35fd850c07ab0d9eef9b0ad1f11a42b38a406c688f2083c5450aac90e8c14d458ab60405ec39a146cd5244c898275dc08e65f548fd711cb9ec9aa86f0dd653b4abba0c6d352100cce32dc1b51dada9f3c046347bd05b1db97a7478447499b1b60b977c1da1427124deda43a50ec32b0d34a6cfcb343902df0a73c3e34a90d99638c4025c47c953ec71ba057f8b8c0f33222a3e32b7b11572ba19ac46f4aad48a8ca2ed8abddf68c36d705817fb93828d32916b62bf4e900b24e41ef88d2fb1b252caadb5c55900b5305d58d57a08492e42c737fe95a418dfd210c9f5fea1b26953588ad5ec37c75139b312c672e3c649ccaf3dec64dd3169bef1c9d78fe3944b064f487e5d6705a250d7091a1a4ef22db096162f32062892544b9e1186b88a2a71bbda1ebcdfa07ae8cc6d57a1605488741f52f5c4e743d1f3c8082da2697f4bf9949f5739a38ff67620a8a75d444330c2fee7d2b1a17562b2e15789f7b065e67e25109138be5745a2fc2d6abae60bf5e672c3e515aaff88808a813fee517f5230c84f0a32d76382b927d23388fd63fdb22a8be600f402402b4ba2b934cf5999bf17da1e2a43d5373160dd03e6abddf40b5129991967a28c0753323f8e75b47ad28d1cf2b8642261aefe2be81213f0a8d0cda34a508161f5eec16edcaf1e3e5ff2066828f3f20790c2f32552557cb4c0e5c78518bf0a631898f6d5fd93f2113857356cef0fd70e8a0033e93336f3e1e395e5506830a1b280e28f7a6427dafd86cc93ca13e936bfd639b72d7dc0af8ce185d916f4943b60188d5afd1ce8059fc17b21013a8e1537b64e430700bb67f0ed28535ab774582eb20cc99ce76e2b13edf6fa0c965bdd318aae24868e7ccdaef69062929baac384ac344d141a8005dfb6948c7b6d651ac6e8b78aca9dda4efa8829489e2f688883226f9ae2e12c9659da8c0dce13316cc1ada4f7fb0752cfadd550c8933c252d7275aa6ab7e144081f0ba8dede8e57d5143025cd7e079c4392ba12c528f975129d1d427045a5f28741943edf3bcdeb4a28a4268755664bba468c3163cd3de8482b82941732b421139773fa2bb1da1e9ee0b7f59b3a17431d298ddff20d8d576d1b3b9c5aba19650958589898f85314b59131685c821c15e91b00058d6b7de7d10944dc6c7bcd08d314b5c3b4bbd7436bfa478aa90a90faed89ead939f9c397df88b7694db6c2a4da96a744055c35715ca0d8cc298c4426e2ecbe5673ca328b782fa0d7ed9246b2221a374ddb0875695315c74319e3812dc3dc0cea7ef3d638e87de27bccd31ce3b557672feddfc307d396ec39cc59a8877fab6248def62b3720f0364ec19b7d91df2aacff738f23bf13d209ff991849069fcd906a816dcd439ae9cd93b6b394b559f1916ac18f0f777b90744243a7427aa1c95d5d2f3d85185d41a7b1185e4d6e090b8f04b20477e66020a186d9ba794dcc6bb41b25e48f763e3e7df15e40728a7bfbbf936883ce308fba8755ce2acf1e5fc4395dbce58386cec3800eb10b4ae1e60f0c7c6b79372f7ce4ba58f17ed6caf56e89e3755dd1ee366671bad5f565a296cbaf5ae8d0b08b52aeee06ab5c353a0fc6807b47cab9762d7f028eca0930feb23b3de295dd032477f41b50d8e0ae9ee3478fc62fa3e5c4bde1ff1ec7c15b28aeb9aaa550a336c824792610895f52a86e44c5c4717fd3fb64c56aa9c6384f9af19d77ab01c18c98c61b8c308f782f6d4bedf5ad682ffb70b86b52885c81fe10a9f833c7f3f0e7135d9be299234f2acfdc12a3b7349b924495c794cf0b7d2a73056c4f42abf44f2ed38585d15108b6453d224bd95883f2e21c6d5e8b802f849143cafb8b3b004f97f72dbdaab384ee7c8b2aedbd7ea662fea51d19b2852205c39d32894e0bd4025c22e357e2d23286736a5f4db368541ceb572c5dbe94b030b5dd4bb88533f592c68cb476f8c0cbb0a73fcd0b4b47006565dc34c182a882fe766c2c95ff1903ebafe35d14a813e6ae2eac35554460fa8f1e76a7e07809623eedf39c7884a91c2fff68e3315df0686d5d4abdeb95871721e4956047a0e39674db770fce17e48dc2c22e6506b2da60ab1f788f5e06a351d97d89c3da6076eff77d39d678d2be250d8c90d364e016e41b05ac3b941fb6745b4c21824229f14bfbdd9fe478a73dbf0fb935316247ce25935271867a593ade3f5d60328973f8aee94140c8abbb2a3e322b7c4e6e886d726185a9ed321902b031917149b90080c71f1801ebefccf64487a6776835911d8e083080d978b39add3d4ecbd1d85a3d4a6ba6a5ba4ded3055dca17164b16b672818f1f793a951fbaaff4a479631284fbfc13b7ad46b7e9c784552ac91abb6b0def927c8ebe62c378fc5de27e65cb78f8466fd996ecb9ce7498acbf9292a67e52f79ee81df19741b71547eccee4bd1636fbff137b8dec0e754f6d5ac6496de180eab51a856d70aaef9cf7a0fdc81e72d22054a7ebf2f5a61869a28fd80bfb866def96a4f18509efe0080358e71cf135f2e2172efbe32722052fc4f33989e605ec44131f99da93a5547e9c6e0428e7af0c03972f76a8aaa53132fd6d710b5b26cb120627d618bdab193bd0f014838a4b27c256fc22d325c3502fe742e530981cf14c23fab493d1d509f7f2ce5a321aeb89adfb5e770ae732ca38c3abfffc0c1af27efc093ccaad94695f7fa9e209b4f118f62a7e3aa63a9ead91773445e8364a117f9679e2d66acf067a7ad910c26f92c634cc1e517057747f99440f656281d810c48cd24efd6538a8070ca86b0d8534c287083c6b7589f4ba7fb2454f74f053e589fb2d9da2f4dd9af0df3d4c5c96518500acd65ebe368122540a204d11da0b9a8061a33192f3feb99e55067a5e8e4c3ea58dba655240e3db8cb9d0acc2f4c7d9be73b19de19068beb656925f99f571a43efd7146df2ccb802fcfceff0ed0c7a087277d53438a2ed6d0e1939d300160215f87554a59c41f8c510305aca594e75b33fad6ad412db1c3076313868e6c921de76abf58f40cdf02839833f8f8834625b37cba7b7fb07944a09224d9deac5eb42d52d342f7a258b7ca87dde8a078fbc94600f7f11aaa287ef76e71aef8bb5f1d5d4701d9075e192247a40ca1cbbe7316aab2ee020a07bacd81fb595282ea1edcfd9699b4e40e4c99f9ea4b3daeca82fe484132b82d9e9720f7931af77620628e68ddc501d6b7087eb9ce016779cb7f335a3a8d018982e99f37abebebfbf5f799075f7e985e4553f18025944f5041703fc0ae22f841c44a3524c50b46415608373634ef42e4351c7ad684342378060703933a911acf1a3c5ec68c7bf77b050c1fc4c09e0bd4bd06bcbb213b5f774c94d1ee176043df0261d76b76a31821374c93714231b10d586b9209e1d22e1bc7ee3e678092f28140a8e719541511d25c6ecbecc80bf92fdb93aaf048c01e3ea6b536803421e77afd999ba55caaadaab01424682ec2dbaf9d44ee2c382d58f105458cd8356f249e53427cd374553e1bad6ec1bf46a11a7152cb26a6e0d8300301e7064989183e2f5802b5a89fb02c68b1a8ec9b989116e0fa41429be129376f2a698ba2f758da7226597d332720e0a761948c9585ad6563d765ba7bf7eaf3bba1be9c5840bd6251fc3b34d6f34d64f3b17f015606c919047fc53b0e9e4fd46e27fd07f32ca7d86811f4a09c4b09add6871b20a2b85db7e3fb907b8f4db940aa7141bb23aea15c01d93db11bd911fcabcf03fcfc9e2d3bfc6bbf52ce72a33679b8863b00436e77cdd41074a65b2f33260fdbdc3e5ed6acb9ddf3f90cf0a84898cee277e9e4549e70c44ebadb28d7bce8eb7ec3f3ba8a59b285cd706c4b1e884b165a72c6eafa249bbca0396d86c55992d45b627cbcf2cba579f2fd0e05568ac1cfd910d295e432ba6a421828da797c4e9c3bb8a9fa8bfe7c972f98315ab46b80e300c58d67ad6834d0ed854e002479f47d5ce2cc8eff1aa96b8fdd250eb6d0b85bb7c1e967a8de81928eb4ce0ea21ee558824d73f0db57b08dbd11adbeb362cc6320a8617ef3012256ac0a603575a000fa62b77a07d6b9fbc640ff78fe8d8052e6664e7ff485ec35c4858c002a6c174a998cf0d1979c90b8bf4ecf0fab72085f519d49b8f1f94c35e06f9decedfd3b85eb0390811dd9ca724aa4463e2c832a67fb39ae9ff1d1a937612009c66ea80b43de777929a90a9c2256710d8b2970a925c04358dda429fed9babe127bd10883dd1ca96dcf1795b55602202565032e881ad754158bd68d9b025d4e5a2a2375dacfde477b6a506ded80797065e6a66127f988c231547520d9467e98872ebb22f53d3822e10589026b191f938cd4a1a1661b0b28685cca5607844cb968e480bc6fb8fbf33530f2cfd66413343d5d95580c922e06e1b2b4fa377589d789948c4048a8442dbc47c6158b6d2f2a197e3bc063484c394ae450c628543229731a8b6a0603ecfd8d3ee42c63b697ea9005f5906439c465e86af89e4813390885b9fef5097a805ec5b392cf19474ca53cecc021d545c1367b21d86d8d4a0130a40ff110c35a46e012c5ac5f0b9aa21e26b540111101cb40af2778c520e99a0f5c3c2576c033595a745340bdb303159bbfbca89dab1afe81063c9be0fed843c340bf21d9cc1426ddf5c4f00b19fd832fe151737879947f63b384771c7790c37a132efec03ae07e68d6ccecb01dc6b965401801ffff25637688f60bc889472a9f86dc24c992e44818796358a33788d0b5c7de752a1d09b94bed1b583ab1f99d8f1369394028d5b76946c640135327f01d55d9d3728d2b4c64e8109d688357f01b3bb4d9d765eaca3e3f45eb51c120cb371b84e34fe20f305cb4608c35dbb19bb4a3d225fdd6800ff3a2a7e5ccc1202bed18c0dada022c041e2a78fb4ef7c9f63f1b25b9be2f0ae2961b4dbd4b57eb3bccbd4d928c91f825c0e2418a35985253711039cf4435775be36509e79410ab32b8825c2abc852afb8009cb194ba3b0dcdc5bb2175c896b8b288e587a7de7ddfba90d1d79c1b3086e440df59bca9ac078bf5766fcce7c3c4e604ad0e7ce53625894f1eceeec68ceb0b3e864c3afacb34d3242c3f36a293a96535ad58652a6b5f17c5e7e074077838eed19e18dc04edfc79130752a4dfea46980c3cc53fa9cd97ce64463f4618c58044a2e6313095f29efc3898d7232e3cc73ceba2cd3bc51c5a9cae6486c5941dd573449cf2059633ac40035b1602bb5e8fed54b0587a3b42ab3882baeb96cf0d238a49c42e6f95beb429ae414f13b4f91892f4447ad9f98cf8185f0c9210b18c3d38049a103b7c177c8e22c392233aae4128ece6b6ccd44653fcae93aa5a1a8dcb8dd39daca269bc1fdcd75cb8fa0b822e1e55b95e45d944596b3087b4ab8a5775cfad2f1dd863234d52056f45bcbc513365dc2351f36b58024997f347357ea847db80093633820bcf428f9c92f0f67e19bedc52a6cea9327c81e143f2b8bbd5b59a3a23f71cf0a9f864b1834702f7011caa222a4932e5cb862780f1855af378959976ac67f13a48cba5428c373af45f9dacf8bbb01ea08f896025e8a3d7279fddefd0f97060a6459f1af0c4468a20e187c3ef2d30771ec082c42eb2a00ae6608f850e7b0814f5da6bdce5c0f3cd0977fc839c1e83f8e2559cc67734dd263e3ac703fa39721833e42d04a6488a20452603dd5e205c2deecf878c0031be744a48744aec1c59b42e6a0f73b26a10c3ffbe927191b92116b2b9ba1d2e597238139998d4b178cefdc9eded3a1cf7d7a91032b1d6cb8b0264c01474a881be0e5b9668a4f9e258daf8389b2017a87590c942c524295bcc4c5cf1f06773211c351dac72f3d84178e852c54f69df340b013f7d6d98ed4ded199055183f0cfbb2235e3d3bfa8eaaf1256edb6ccd8b18319badc077fb3f4f7c87d0e696000a2826b8802bd3771000117d31c9b315411b105dda7999c6010da318a8d5a6dad9f800b35aafc937dba4152427a0a6da73e3f4aa371fe8b0bc2eb78a79a3dfa94814ff8fe5da6748c03e9e7741e7f0e205d034e0d436269906833dfe6c80469b07e2e0833cb8e0b69f72a39d39905d5f45ff6d391fab95381993b0e6a456f6230772dfd5bfce70cf252913ae07463159821ebf2658fdfea6e9b8aea604bc28859968b798d9c621db9873dffbfc6cdb9980d7534e27529c7ecfc1af41d27a3611d81fce53b6b2d6630509c66ef6113556cfe8db837932aba42abbf37ba74133f0b6619c2b860964216dd3b83aa0c2ab7b4553b3606e4878db159354f9742efba8c3088413c0d55fb9be69f75ad18b12b4892ec43c7cdca115dce55c7014446b828563480c2ea024ac06db06183b62028799c80f4c760e6f2a5dd5edd3f07a9fcf1854edc8d6b77962bce679940e12893ceb502b39e2831ed76f0176e316f383ba02887c3044b11f71c9f896edf3c4aed46391382b737be078d8c0c237be82503ef12edc41b3fc26d63aae6e54c00678806b6b591cab472942caf1c1b2782be0f6a3b561858df0c4b5cd3d35f074757aa27216defab983cc053989b2d468ff82bacbf902c08e8da7b0d379873478974111a291f74017256da16bba1dc3b84e6bbfe3232da269c66dc715b17e41b0b3dbfa375382d3e4407fac8d7de9b0056ff593928d09c5ce4f712f4e2d6989ddee9b60a158077f62862c4aff58bc8adab44065e3e780763db3673b96ac5102af0f5892d80e2993d2969256646b26f07461a4466fab9d1f48a9c88560b6ca5ff5181a68d195b7775900e5d9bbb42c2ea48bc64d37f2e062a32ec3dd9ef057ca407e4508180f01005708cecadd38b5f1eef91278d083db19accaf76f88f6939e520bc8fdc0729551e5546fdd8990f28bb70aa6adb86f6176b2a1ef2c9ec6ad944493503192787eff00b160ad4815f1a37563ab16405ad60ae4bb4a05868c2afa93b74c7a5167b2b7adbc5c686ddd4e0863258caf1c92fc588459d50db17925d0c609533eac2e27eca12790deab6cbc1d06f9b81194303f36458ca0723aa4ad82fc6f840c09c330160d8c0121a902c38f5e519f73bad7762c9ab34153fe9de79d7e62a3a60aecab338a535a3e12a38b83191ff91910db1c7943bd5beb90041264a38c4f8f2b5bc202fff63cda1c21629dc9a98af9bf74197259caaf827cd7e4e25e7b0b98303eae22f477890d79907b01015cbc62b529f74551b800353f1a26ad29d4acf87250612eb9f881dcd6903634235307514a6f32cf3ba57aa720c33f30f46b87713194785607d1dbfd2b199c84dfeecdb2b497eefc30cffe6b3a8a0355f14165099057c4942f5983c83cf47482f9cc4e6e9a2d2e90af0faf707b97c25c138f8eb5bd2199a776570f1ce2b3daf1ac245b93a34de63f75e5bd4eb6dc4943f801cd1fdf1cb8791e4b837efe056a0cf87c7d908c330a93b3c772a508caf11906b631e831eb43209594b8407179c852102867c5ef16ec72ac4c3e9a7624ac361b940a2ab45fab219ebff8d9480d1e4194139426c04aeb9d18eb8d2712d7ec8853290c03ab85f88aaf8fec483e275993741ddd42d05ca3356e52eb85d25d508eec381bd3223daa2d1235f1e89f9ff8b1ecc49d5cd1207770f3c7c3ee4d1fff9cc3f6176a7eb1f3764bf1da872734b5b93ce364a8657b764113d504d28e22176e5feeeb0ba72b4962128d7b965a5289d90be5b5f4f01a1544a9c7efd711b02729866d91ba2292b77bb8f57fcd02dfbb6c514ca44b0348b96c8cc99aa1526781042a73da7ec95d8e365df154b5d6edd50076e731373864d9c0c4dcbb889dd2d91afa75539d9749bcd73b586448db64bf1aa34fd8b00fec4cc1c8fad9301d59217b3afe50fcfd13e0d245e8a2829924062ba1878658988f5cb42fb91e3c7f88c70317d374ab6d15050be655ed1827c23bff75d93ef66695a14563496b5b39065bc2a8e43ad2e69be37c022560d09c711fe13c00c5d45759412c8a1e7d1d9bab6d9eb15635542743dca9988d71facea8a4845304717a4a9af977148b85b239c636b2abead61119ac036b3fc82d8c3ab1e8cf77508bfc3afd7b4ecc12ddbdca8cff3d3fa49c9dbed16a9f5918a7137002253e7a473487352370d0569f7e5e888c90f6ec896438054aa2443c008806a4ecde2951fabb9b1278794a57184dfc6865a771beadc29929c3652f251af0bc103c3e0d0611a9a5d8c2523cb94aac5b72a048ff3fc59c7cf22d46325c1fa0c45acab19343baee1d8672a27bcdf266d18e8c2934c9d5b16849a2a73434cb0fe2ec392e451aab8059645f6c05b530632b0d531e98c6f2cd7572ea82d9c119945ea5964c33d5774a0aadf5fceab4a4d37fa34f4cf7cfda14ca18fda2695fb455d178fffd1da7d63c98e96f408b7149a40baba7836e3f7809fe48a117bc8012c948f6f74cd62789a6f5a0bd770c8794e49c1d828262f23793c356354418065f67f1c73a4776226a2718a5e536fa72adaa3e280ae762b58165af3b1d1aedc2a31841eb7a3f8074a1957915776eefab898e9</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线段树</tag>
        <tag>向量</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>[ARC080F]Prime Flip</title>
    <url>/2020/02/25/%5BARC080F%5DPrime%20Flip/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出01序列，其中1的个数不超过100</p>
<p>每次翻转长度为奇质数的序列</p>
<p>问最小的步数使得序列全为0</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先差分，所有为1的位置两两匹配</p>
<p>由于长度只能为奇数，按照位置的奇偶分类，二分图匹配</p>
<p>一开始只连质数的边（奇质数1步），剩下的奇偶性相同偶数2步，再剩下的奇偶性不同要3步</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>没必要写最小费用最大流的好吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxP = <span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">204</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; p; <span class="keyword">bool</span> isp[maxP + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">install</span><span class="params">()</span></span>&#123;</span><br><span class="line">	isp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxP; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isp[i]) p.push_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size() &amp;&amp; i * p[j] &lt;= maxP; j++)&#123;</span><br><span class="line">			isp[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn * maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mat[maxn]; <span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (mat[v] == <span class="number">-1</span> || dfs(mat[v]))&#123;</span><br><span class="line">			mat[v] = cur; mat[cur] = v;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; x[<span class="number">2</span>]; <span class="keyword">int</span> n, c[maxP + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	install();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a); c[a]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxP + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (c[i] != c[i - <span class="number">1</span>]) x[i &amp; <span class="number">1</span>].push_back(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x[<span class="number">0</span>].size(); i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x[<span class="number">1</span>].size(); j++)</span><br><span class="line">			<span class="keyword">if</span> (!isp[<span class="built_in">abs</span>(x[<span class="number">1</span>][j] - x[<span class="number">0</span>][i])]) addedge(i, j + x[<span class="number">0</span>].size());</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(mat, <span class="number">-1</span>, <span class="keyword">sizeof</span> mat);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x[<span class="number">0</span>].size() + x[<span class="number">1</span>].size(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (mat[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">			flow += dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow + (x[<span class="number">0</span>].size() - flow) / <span class="number">2</span> * <span class="number">2</span> + (x[<span class="number">1</span>].size() - flow) / <span class="number">2</span> * <span class="number">2</span> + (x[<span class="number">0</span>].size() - flow) % <span class="number">2</span> * <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>线性筛</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>[国家集训队]人员雇佣</title>
    <url>/2020/02/24/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E4%BA%BA%E5%91%98%E9%9B%87%E4%BD%A3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有n个人，每个人都可以选择雇佣或不雇佣，雇佣需要$\{A_i\}$</p>
<p>如果两个人都被雇佣则会产生$E_{i,j}$的贡献，若只有一人被雇佣则产生$-E_{i,j}$的贡献</p>
<p>问最大收益</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$<S,x,A_x>,<i,j,E_{i,j}>,<x,T,\sum E_x>$</p>
<p>最小割模型，一个人要不付给他钱要不放弃收益</p>
<p>当且仅当其中一人被雇佣，中间的边要割</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt; LL f;</span><br><span class="line">&#125;e[maxn * maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[e[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (dep[T] != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, LL Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	LL flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to; now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			LL tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			e[i].f -= tmp; e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">			<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line">LL maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		ins(S, i, a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		LL s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> e, j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e); ans += e; s += e;</span><br><span class="line">			ins(i, j, e * <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ins(i, T, s);</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans - maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>[十二省联考2019]异或粽子</title>
    <url>/2020/02/20/%5B%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%5D%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求序列$\{a_i\}$中连续异或和的前k大的和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>前缀和，每次在堆里找最大的分裂</p>
<p>用可持久化Trie维护</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>Trie边界没弄好，写挂了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> son[<span class="number">2</span>], v, tim;</span><br><span class="line">		A()&#123;</span><br><span class="line">			tim = <span class="number">-1</span>;</span><br><span class="line">			v = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;a[maxn * <span class="number">50</span>];</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL x, <span class="keyword">int</span> dep, <span class="keyword">int</span> tim)</span></span>&#123;</span><br><span class="line">		a[v] = a[u]; a[v].v++;</span><br><span class="line">		<span class="keyword">if</span> (dep &lt; <span class="number">0</span>)&#123; a[v].tim = tim; <span class="keyword">return</span>; &#125;</span><br><span class="line">		<span class="keyword">int</span> d = (x &gt;&gt; (<span class="number">1l</span>l * dep)) &amp; <span class="number">1l</span>l;</span><br><span class="line">		insert(a[u].son[d], a[v].son[d] = ++tot, x, dep - <span class="number">1</span>, tim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> dep, LL x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep &lt; <span class="number">0</span>) <span class="keyword">return</span> a[v].tim;</span><br><span class="line">		<span class="keyword">int</span> d = (x &gt;&gt; (<span class="number">1l</span>l * dep)) &amp; <span class="number">1l</span>l;</span><br><span class="line">		<span class="keyword">if</span> (a[a[v].son[d ^ <span class="number">1</span>]].v - a[a[u].son[d ^ <span class="number">1</span>]].v != <span class="number">0</span>) <span class="keyword">return</span> find(a[u].son[d ^ <span class="number">1</span>], a[v].son[d ^ <span class="number">1</span>], dep - <span class="number">1</span>, x);</span><br><span class="line">		<span class="keyword">return</span> find(a[u].son[d], a[v].son[d], dep - <span class="number">1</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t; <span class="keyword">int</span> rt[maxn];</span><br><span class="line"><span class="keyword">int</span> n, k; LL a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s, l, r, pos;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(A x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a[s] ^ a[pos]) &lt; (a[x.s] ^ a[x.pos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; priority_queue &lt;A&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("17.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k); t.insert(<span class="number">0</span>, rt[<span class="number">0</span>] = ++t.tot, <span class="number">0</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i); a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">		t.insert(rt[i - <span class="number">1</span>], rt[i] = ++t.tot, a[i], <span class="number">32</span>, i);</span><br><span class="line">	&#125; LL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		q.push(A&#123;i - <span class="number">1</span>, i, n, t.find(rt[i - <span class="number">1</span>], rt[n], <span class="number">32</span>, a[i - <span class="number">1</span>])&#125;);</span><br><span class="line">	<span class="keyword">while</span> (k--)&#123;</span><br><span class="line">		A now = q.top(); q.pop();</span><br><span class="line">		res += (a[now.s] ^ a[now.pos]);</span><br><span class="line">		<span class="keyword">if</span> (now.l &lt; now.pos) q.push(A&#123;now.s, now.l, now.pos - <span class="number">1</span>, t.find(rt[now.l - <span class="number">1</span>], rt[now.pos - <span class="number">1</span>], <span class="number">32</span>, a[now.s])&#125;);</span><br><span class="line">		<span class="keyword">if</span> (now.pos &lt; now.r) q.push(A&#123;now.s, now.pos + <span class="number">1</span>, now.r, t.find(rt[now.pos], rt[now.r], <span class="number">32</span>, a[now.s])&#125;);</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>十二省联考</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>堆</tag>
        <tag>可持久化</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]可持久化Trie</title>
    <url>/2020/02/20/%5B%E6%A8%A1%E6%9D%BF%5D%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于序列$\{a_i\}$，支持以下操作：</p>
<p>1.在序列后添加一个数$x$</p>
<p>2.给出$l,r,x$，求出一个$p\in[l,r]$，使得$\oplus_{p\leq i\leq n} a_i\space xor\space x$最大</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>前缀和，求$a_{l-2}$到$a_{r-1}$异或$x\space xor\space a_{cnt}$的max</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>边界条件没弄好，要先从a[u]继承</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> son[<span class="number">2</span>], v, tim;</span><br><span class="line">		A()&#123;tim = <span class="number">-1</span>; v = <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;a[maxn * <span class="number">30</span>]; <span class="keyword">int</span> tot = <span class="number">0</span>; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> tim)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep == <span class="number">0</span>)&#123;</span><br><span class="line">			a[v].v = a[u].v + <span class="number">1</span>;</span><br><span class="line">			a[v].tim = tim;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[v] = a[u]; a[v].v++;</span><br><span class="line">		<span class="keyword">int</span> d = (x &gt;&gt; (dep - <span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">		insert(a[u].son[d], a[v].son[d] = ++tot, x, dep - <span class="number">1</span>, tim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> dep, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[v].tim != <span class="number">-1</span>) <span class="keyword">return</span> a[v].tim;</span><br><span class="line">		<span class="keyword">int</span> d = (x &gt;&gt; (dep - <span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[a[v].son[d ^ <span class="number">1</span>]].v - a[a[u].son[d ^ <span class="number">1</span>]].v != <span class="number">0</span>) <span class="keyword">return</span> find(a[u].son[d ^ <span class="number">1</span>], a[v].son[d ^ <span class="number">1</span>], dep - <span class="number">1</span>, x);</span><br><span class="line">		<span class="keyword">return</span> find(a[u].son[d], a[v].son[d], dep - <span class="number">1</span>, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">int</span> a[maxn], rt[maxn], n, Q, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q); t.insert(<span class="number">0</span>, rt[<span class="number">0</span>] = ++t.tot, <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i); a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">		t.insert(rt[i - <span class="number">1</span>], rt[i] = ++t.tot, a[i], <span class="number">20</span>, i);</span><br><span class="line">	&#125; cnt = n;</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">char</span> opt[<span class="number">5</span>]; <span class="keyword">int</span> l, r, x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">			t.insert(rt[cnt], rt[cnt + <span class="number">1</span>] = ++t.tot, x, <span class="number">20</span>, cnt + <span class="number">1</span>);</span><br><span class="line">			a[cnt + <span class="number">1</span>] = x ^ a[cnt]; ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">			<span class="keyword">int</span> pos = t.find(rt[min(<span class="number">0</span>, l - <span class="number">2</span>)], rt[r - <span class="number">1</span>], <span class="number">20</span>, x ^ a[cnt]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a[pos] ^ x ^ a[cnt]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC005D]K Perm Counting</title>
    <url>/2020/02/17/%5BAGC005D%5DK%20Perm%20Counting/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求所有n阶排列中，满足$\forall |i-a_i|\not=k$的排列数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>转变为容斥问题，可以发现题目等价于二分图</p>
<p>现在要解决的就是二分图匹大小为$k$的方案数</p>
<p>猛然发现二分图由一些链构成，那么每条链分开来Dp，最后再卷积合并即可</p>
<p><strong>插播，可以不Dp，就是$C_{i-j}^{j}$，把j个点先取出来再接回去​</strong></p>
<p>$ans=\sum_{i=0}^{n} (-1)^{i}\cdot g(i)\cdot (n-i)!​$</p>
<p>FFT什么的就懒得写了</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>算ans的时候没加mo导致爆负</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">924844033</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][<span class="number">2</span>], g[<span class="number">2</span>][maxn], n, k;</span><br><span class="line"><span class="keyword">int</span> fac[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k); fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mo;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / k; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i / <span class="number">2</span>; j++)&#123;</span><br><span class="line">			f[i + <span class="number">1</span>][j][<span class="number">0</span>] = (f[i][j][<span class="number">1</span>] + f[i][j][<span class="number">0</span>]) % mo;</span><br><span class="line">			f[i + <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>] = f[i][j][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	printf("%d\n", (f[n / k + 1][5][0] + f[n / k + 1][5][1]));</span></span><br><span class="line">	<span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= k; s++)&#123;</span><br><span class="line">		<span class="keyword">int</span> len = (n - s) / k + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len / <span class="number">2</span>; j++)</span><br><span class="line">				g[T ^ <span class="number">1</span>][i + j] = (g[T ^ <span class="number">1</span>][i + j] + <span class="number">1l</span>l * g[T][i] * (f[len][j][<span class="number">0</span>] + f[len][j][<span class="number">1</span>]) % mo) % mo;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) g[T][i] = <span class="number">0</span>; T ^= <span class="number">1</span>;</span><br><span class="line">		cnt += len / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len / <span class="number">2</span>; j++)</span><br><span class="line">				g[T ^ <span class="number">1</span>][i + j] = (g[T ^ <span class="number">1</span>][i + j] + <span class="number">1l</span>l * g[T][i] * (f[len][j][<span class="number">0</span>] + f[len][j][<span class="number">1</span>]) % mo) % mo;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) g[T][i] = <span class="number">0</span>; T ^= <span class="number">1</span>;</span><br><span class="line">		cnt += len / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		ans = (ans + mo + ((i &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>) * <span class="number">1l</span>l * g[T][i] % mo * fac[n - i] % mo) % mo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC002F]Leftmost Ball</title>
    <url>/2020/02/14/%5BAGC002F%5DLeftmost%20Ball/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$种颜色每种各$k$个球排列，每种颜色最左边的球染成白色，问不同颜色序列数</p>
<p>$n,k\leq 2000$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题目的idea就是把每种颜色的后k-1个球一起算</p>
<p>令$f_{i,j}$为已经出现了i种颜色，有j个白球的方案，容易知道$i\leq j$</p>
<p>下一个放白球：$f_{i,j}+=f_{i,j-1}$</p>
<p>下一个放别的颜色：$f_{i,j}+=f_{i-1,j}\cdot (n-i+1)\cdot S​$</p>
<p>我们来看在$f_{i-1,j}$的时候后面还有几个位置：$n\cdot k-(i-1)\cdot (k-1)-j$,那么$S=C_{pos-1}^{k-1}$</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>算位置i没-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL f[<span class="number">2005</span>][<span class="number">2005</span>], fac[maxn], inv[maxn];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n] * inv[n - m] % mo * inv[m] % mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">1</span>; x %= mo;</span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = res * x % mo;</span><br><span class="line">		x = x * x % mo;</span><br><span class="line">		t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, k; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * k; i++) fac[i] = fac[i - <span class="number">1</span>] * i % mo;</span><br><span class="line">	inv[n * k] = <span class="built_in">pow</span>(fac[n * k], mo - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n * k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mo;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (j != <span class="number">0</span>) f[i][j] = (f[i][j] + f[i][j - <span class="number">1</span>]) % mo;</span><br><span class="line">			<span class="keyword">if</span> (i != <span class="number">0</span>) f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j] * (n - i + <span class="number">1</span>) % mo * C(n * k - (i - <span class="number">1</span>) * (k - <span class="number">1</span>) - j - <span class="number">1</span>, k - <span class="number">2</span>) % mo) % mo;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC002E]Candy Piles</title>
    <url>/2020/02/13/%5BAGC002E%5DCandy%20Piles/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$n$堆糖果$\{a_i\}$，每次可以吃掉一颗或者把最多的一堆吃完，问先手的胜负</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>把糖果排列成这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100000000000</span><br><span class="line">111000000000</span><br><span class="line">001100000</span><br><span class="line">0001</span><br><span class="line">000</span><br></pre></td></tr></table></figure></p>
<p>行动被描述为一条折线，往下是吃完一堆，往右是吃一颗</p>
<p>然后会发现左上-右下对角线上胜负态相同</p>
<p>找到对角线上离边界最近的，若与其中一条边界相距距离为奇数则必胜</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">	sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i + <span class="number">1</span> &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">int</span> ans = <span class="number">0</span>, j = i;</span><br><span class="line">			<span class="keyword">while</span> (a[j + <span class="number">1</span>] == i) ++j;</span><br><span class="line">			ans = ((a[i] - i) &amp; <span class="number">1</span>) | ((j - i) &amp; <span class="number">1</span>); </span><br><span class="line">			<span class="keyword">if</span> (ans) <span class="built_in">puts</span>(<span class="string">"First"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Second"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>博弈论</tag>
        <tag>杨氏图</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC002D]Stamp Rally</title>
    <url>/2020/02/13/%5BAGC002D%5DStamp%20Rally/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在无向图中，Q次询问从x,y出发到达恰好z个点经过的边编号的最大值的Min</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大值最小，显然二分</p>
<p>分开二分太慢了，我们就一起二分</p>
<p>用堆会有两个log，过不去</p>
<p>可以在push的时候保证有序，同一深度的从左到右处理</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>开始用堆T掉</p>
<p>ask里面可能有些询问先退出，因此不能用askl确定位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, u[maxn], v[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn], sz[maxn], x[maxn], y[maxn], z[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x] == x ? x : f[x] = getf(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum[maxn], ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, askl, askr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;A&gt; vec[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ask[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sz[getf(x[id])] + (getf(x[id]) != getf(y[id])) * sz[getf(y[id])];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, u + i, v + i);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, x + i, y + i, z + i);</span><br><span class="line">		ans[i] = INF; ask[<span class="number">0</span>].push_back(i);</span><br><span class="line">	&#125; vec[<span class="number">0</span>].push_back(A&#123;<span class="number">1</span>, m, <span class="number">0</span>, Q&#125;);</span><br><span class="line">	<span class="keyword">int</span> now, D = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!vec[D].empty())&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i, sz[i] = <span class="number">1</span>; now = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[D].size(); j++)&#123;</span><br><span class="line">			A cur = vec[D][j]; <span class="keyword">int</span> mid = cur.l + cur.r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (cur.l == cur.r)&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = cur.askl; i &lt; cur.askr; i++)&#123;</span><br><span class="line"><span class="comment">//					if (mid == 5) printf("!%d\n", ask[D][i]);</span></span><br><span class="line">					ans[ask[D][i]] = min(ans[ask[D][i]], cur.l);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>; i &lt;= mid; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (sz[u[i]] &gt; sz[v[i]]) swap(u[i], v[i]); </span><br><span class="line">				<span class="keyword">if</span> (getf(u[i]) != getf(v[i]))</span><br><span class="line">					sz[getf(v[i])] += sz[getf(u[i])],</span><br><span class="line">					f[getf(u[i])] = getf(v[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			now = mid;</span><br><span class="line">			<span class="keyword">int</span> cnt[<span class="number">2</span>]; cnt[<span class="number">0</span>] = <span class="number">0</span>, cnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = cur.askl; i &lt; cur.askr; i++)</span><br><span class="line">				<span class="keyword">if</span> (calc(ask[D][i]) &gt;= z[ask[D][i]])&#123;</span><br><span class="line">					ask[D ^ <span class="number">1</span>].push_back(ask[D][i]), ++cnt[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//					if (ask[D][i] == 5) puts("(1)");</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt; <span class="number">0</span>) vec[D ^ <span class="number">1</span>].push_back(A&#123;cur.l, mid, ask[D ^ <span class="number">1</span>].size() - cnt[<span class="number">0</span>], ask[D ^ <span class="number">1</span>].size()&#125;);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = cur.askl; i &lt; cur.askr; i++)</span><br><span class="line">				<span class="keyword">if</span> (calc(ask[D][i]) &lt; z[ask[D][i]])&#123;</span><br><span class="line">					ask[D ^ <span class="number">1</span>].push_back(ask[D][i]), ++cnt[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//					if (ask[D][i] == 5) puts("(2)"), printf("(())%d\n", ask[D ^ 1].size());</span></span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) vec[D ^ <span class="number">1</span>].push_back(A&#123;mid + <span class="number">1</span>, cur.r, ask[D ^ <span class="number">1</span>].size() - cnt[<span class="number">1</span>], ask[D ^ <span class="number">1</span>].size()&#125;); </span><br><span class="line">		&#125;</span><br><span class="line">		vec[D].clear(); ask[D].clear(); D ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>idea</tag>
        <tag>整体二分</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC003F]Fraction of Fractal</title>
    <url>/2020/02/12/%5BAGC003F%5DFraction%20of%20Fractal/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出n*m的网格，求其k级分形后的联通快个数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>神仙题</p>
<p>发现分形之后连通性与上下左右重复的黑块个数有关，设为$cnt_{0/1}$，设原网格中黑格有$v$个</p>
<p>如果两个都大于0，那么答案就是1；如果两个都是0，那么答案就是$v^{k-1}$</p>
<p>若只有其中一个大于0，设其为$cnt$，对应方向上相邻的黑格对数为$lnk$</p>
<p>把整个原网格看做一个点，最终看成一个图，那么这个图一定由一些同方向的链构成，$ans=|V|-|E|$</p>
<p>递推式</p>
<script type="math/tex; mode=display">
\begin{align}
&V_k=V_{k-1}\cdot v, V_1 = 1\\
&E_k=E_{k-1}\cdot v（大方块之间） + V^{k-1}\cdot lnk(大方块内部), E_1 = 0
\end{align}</script><p>手动求通项即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> LL mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt[<span class="number">2</span>], lnk[<span class="number">2</span>], V;</span><br><span class="line"><span class="keyword">char</span> str[maxn][maxn]; LL k;</span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x, LL t)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">1</span>; x %= mo;</span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = res * x % mo;</span><br><span class="line">		x = x * x % mo;</span><br><span class="line">		t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (str[i][<span class="number">1</span>] == <span class="string">'#'</span> &amp;&amp; str[i][m] == <span class="string">'#'</span>) cnt[<span class="number">0</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		<span class="keyword">if</span> (str[<span class="number">1</span>][j] == <span class="string">'#'</span> &amp;&amp; str[n][j] == <span class="string">'#'</span>) cnt[<span class="number">1</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			V += (str[i][j] == <span class="string">'#'</span>); </span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'#'</span> &amp;&amp; str[i][j + <span class="number">1</span>] == <span class="string">'#'</span>) lnk[<span class="number">0</span>]++;</span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'#'</span> &amp;&amp; str[i + <span class="number">1</span>][j] == <span class="string">'#'</span>) lnk[<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; cnt[<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="built_in">pow</span>(V, k - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		LL ans = <span class="built_in">pow</span>(V, k - <span class="number">1</span>) - <span class="number">1l</span>l * lnk[<span class="number">0</span>] * (<span class="built_in">pow</span>(V, k - <span class="number">1</span>) - <span class="built_in">pow</span>(cnt[<span class="number">0</span>], k - <span class="number">1</span>)) % mo * <span class="built_in">pow</span>(V - cnt[<span class="number">0</span>], mo - <span class="number">2</span>) % mo;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans + mo) % mo);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		LL ans = <span class="built_in">pow</span>(V, k - <span class="number">1</span>) - <span class="number">1l</span>l * lnk[<span class="number">1</span>] * (<span class="built_in">pow</span>(V, k - <span class="number">1</span>) - <span class="built_in">pow</span>(cnt[<span class="number">1</span>], k - <span class="number">1</span>)) % mo * <span class="built_in">pow</span>(V - cnt[<span class="number">1</span>], mo - <span class="number">2</span>) % mo;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans + mo) % mo);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>数学</tag>
        <tag>线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC003E]Sequential operations on Sequence</title>
    <url>/2020/02/12/%5BAGC003E%5DSequential%20operations%20on%20Sequence/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>把序列S无限次复制，再取前$q_i$位，形成新的S</p>
<p>如此操作Q次，原序列是1~n，问最终每种数字在序列中出现的次数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑倒回去操作，$k_i​$表示第i次操作后的序列在最终序列中的完整出现次数</p>
<p>k很好维护，考虑维护每次操作多余的部分，分散到之前的序列的k上，长度小的序列一定是它的前缀</p>
<p>当长度小于n的时候直接差分加答案即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>work里没用LL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL a[maxn], k[maxn], res[maxn]; <span class="keyword">int</span> n, Q, cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(LL x, LL v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= a[<span class="number">1</span>])&#123;</span><br><span class="line">		res[<span class="number">1</span>] += v;</span><br><span class="line">		res[x + <span class="number">1</span>] -= v;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> t = upper_bound(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, x) - a;</span><br><span class="line">	k[t - <span class="number">1</span>] += v * (x / a[t - <span class="number">1</span>]);</span><br><span class="line">	work(x % a[t - <span class="number">1</span>], v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">	a[cnt = <span class="number">1</span>] = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">		LL x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">		<span class="keyword">while</span> (cnt &gt; <span class="number">0</span> &amp;&amp; a[cnt] &gt;= x) cnt--;</span><br><span class="line">		a[++cnt] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	k[cnt] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">2</span>; i--)&#123;</span><br><span class="line">		k[i - <span class="number">1</span>] += k[i] * (a[i] / a[i - <span class="number">1</span>]);</span><br><span class="line">		work(a[i] % a[i - <span class="number">1</span>], k[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	res[<span class="number">0</span>] = k[<span class="number">1</span>];</span><br><span class="line">	res[a[<span class="number">1</span>] + <span class="number">1</span>] -= k[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		res[i] += res[i - <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld "</span>, res[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC003D]Anticube</title>
    <url>/2020/02/08/%5BAGC003D%5DAnticube/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$n$个数中选出$Max$个数，使得它们任意两个相乘不为立方数</p>
<p>求$Max$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>在本题中，$a_i=p_1^{k_1}\cdots p_x^{k_x}$和$a_i=p_1^{k_1\space mod\space 3}\cdots p_x^{k_x\space mod\space 3}$等价</p>
<p>令$b_i=\frac{p_1^{3}\cdots p_x^3}{a_i}$</p>
<p>发现冲突一定是互相的，当有冲突，取较多的，本身是立方数的分开考虑</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxP = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL a[maxn], b[maxn]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">map</span> &lt;LL, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="built_in">vector</span> &lt;LL&gt; p;</span><br><span class="line"><span class="keyword">bool</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">install</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxP; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!f[i]) p.push_back(i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.size() &amp;&amp; i * p[j] &lt;= maxP; j++)&#123;</span><br><span class="line">			f[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">split</span><span class="params">(LL &amp;x)</span></span>&#123;</span><br><span class="line">	LL res1 = <span class="number">1</span>, res2 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (x % p[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (x % p[i] == <span class="number">0</span>) ++cnt, x /= p[i];</span><br><span class="line">		cnt %= <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (cnt == <span class="number">2</span>) res1 = res1 * p[i] * p[i], res2 = res2 * p[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) res1 = res1 * p[i], res2 = res2 * p[i] * p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> ((LL)<span class="built_in">sqrt</span>(x) * (LL)<span class="built_in">sqrt</span>(x) == x) res1 *= x, res2 *= (LL)<span class="built_in">sqrt</span>(x);</span><br><span class="line">		<span class="keyword">else</span> res1 *= x, res2 *= x * x;</span><br><span class="line">	&#125;</span><br><span class="line">	x = res1;</span><br><span class="line">	<span class="keyword">return</span> res2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); install();</span><br><span class="line"><span class="comment">//	for (int i = 0; i &lt; 20; i++) printf("%d\n", p[i]);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">		b[i] = split(a[i]);</span><br><span class="line">		m[a[i]]++;</span><br><span class="line">	&#125; <span class="keyword">int</span> ans = (m[<span class="number">1</span>] != <span class="number">0</span>); m[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (m[b[i]] != <span class="number">0</span>) ans += max(m[a[i]], m[b[i]]), m[a[i]] = <span class="number">0</span>, m[b[i]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> ans += m[a[i]], m[a[i]] = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC004F]Namori</title>
    <url>/2020/02/08/%5BAGC004F%5DNamori/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵树或基环树，开始每个节点都是白色</p>
<p>每次可以选择相连的颜色相同的节点反转颜色，求最小次数，使得节点全黑</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑树，分深度奇偶考虑，等价地认为深度奇数上有一个球，偶数上有一个洞</p>
<p>令那么$s_u$为子树中球/洞的个数，那么$ans=\sum|s_i|$，若根节点s不为0则无解</p>
<p>对于基环树，把一条边放到最后考虑，顺序没关系，随便断开一条边</p>
<p>对于奇环，两个点深度奇偶相同，一起变颜色可以多出两个球/洞</p>
<p>对于偶环，两个点深度就不同，深度小的一个点$(设为cv)$可以把球给另外一个点，绕一圈再回来还给它，那么环上的点(cv除外)可以加或减同一个数，要使$\sum |s_i-k|$最小，显然k是这些数的中位数时最优</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>sf变量混淆</p>
<p>(dep[cu]-dep[cv])%2没加括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s[maxn], dep[maxn], f[maxn]; <span class="keyword">int</span> cu, cv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dep[cur] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	f[cur] = fa;</span><br><span class="line">	<span class="keyword">if</span> (dep[cur] &amp; <span class="number">1</span>) s[cur] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> s[cur] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v != fa)&#123;</span><br><span class="line">			<span class="keyword">if</span> (dep[v])&#123;</span><br><span class="line">				<span class="keyword">if</span> (cu == <span class="number">0</span>) cu = cur, cv = v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> dfs(v, cur), s[cur] += s[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[<span class="number">1</span>] != <span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="built_in">abs</span>(s[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[<span class="number">1</span>] % <span class="number">2</span> != <span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="keyword">int</span> t = -s[<span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">abs</span>(t);</span><br><span class="line">	<span class="keyword">for</span> (; cu; cu = f[cu]) s[cu] += t;</span><br><span class="line">	<span class="keyword">for</span> (; cv; cv = f[cv]) s[cv] += t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += <span class="built_in">abs</span>(s[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[<span class="number">1</span>] != <span class="number">0</span>)&#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="keyword">for</span> (; cu != cv; cu = f[cu]) dep[cu] = <span class="number">0</span>, v.push_back(s[cu]);</span><br><span class="line">	sort(v.begin(), v.end());</span><br><span class="line">	<span class="keyword">int</span> mid = v[(v.size() - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">abs</span>(mid);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (dep[i] != <span class="number">0</span>) ans += <span class="built_in">abs</span>(s[i]);</span><br><span class="line">		<span class="keyword">else</span> ans += <span class="built_in">abs</span>(s[i] - mid);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		addedge(u, v); addedge(v, u);</span><br><span class="line">	&#125; dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (m == n - <span class="number">1</span>) work1();</span><br><span class="line">	<span class="keyword">if</span> ((dep[cu] - dep[cv]) % <span class="number">2</span> == <span class="number">0</span>) work2();</span><br><span class="line">	work3();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC004E]Salvage Robots</title>
    <url>/2020/02/07/%5BAGC004E%5DSalvage%20Robots/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n*m的方阵中有一些机器人和一个出口</p>
<p>命令所有机器人向同一个方向移动，出界则死，进出口则活，问最多就出几个机器人</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>转化为整个方阵的行动，如果知道方阵已经向四个方向移动的格数，就可以知道哪些机器人死了</p>
<p>动态规划，每次加一列或者一行</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>一开始在想前缀和，但是救活的不一定是一个矩形，很可能是很多个矩形拼起来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ex, ey; <span class="keyword">char</span> str[maxn][maxn]; </span><br><span class="line"><span class="keyword">short</span> f[maxn][maxn][maxn][maxn], p[maxn][maxn], q[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">max</span><span class="params">(<span class="keyword">short</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> y;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("1.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//	freopen("1.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			p[i][j] = p[i][j - <span class="number">1</span>]; q[i][j] = q[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'E'</span>) ex = i, ey = j;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (str[i][j] == <span class="string">'o'</span>) p[i][j]++, q[i][j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ex - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= ey - <span class="number">1</span>; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= n - ex; x++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= m - ey; y++)&#123;</span><br><span class="line">					<span class="keyword">int</span> L = max(ex - i, x + <span class="number">1</span>), R = min(n - i, ex + x);</span><br><span class="line">					<span class="keyword">if</span> (L &lt;= R)&#123;</span><br><span class="line">						f[i][j + <span class="number">1</span>][x][y] = max(f[i][j + <span class="number">1</span>][x][y], f[i][j][x][y] + (ey - j - <span class="number">1</span> &gt;= y + <span class="number">1</span>) * (q[R][ey - j - <span class="number">1</span>] - q[L - <span class="number">1</span>][ey - j - <span class="number">1</span>]));</span><br><span class="line">						f[i][j][x][y + <span class="number">1</span>] = max(f[i][j][x][y + <span class="number">1</span>], f[i][j][x][y] + (m - j &gt;= ey + y + <span class="number">1</span>) * (q[R][ey + y + <span class="number">1</span>] - q[L - <span class="number">1</span>][ey + y + <span class="number">1</span>]));</span><br><span class="line">					&#125;</span><br><span class="line">					L = max(ey - j, y + <span class="number">1</span>), R = min(m - j, ey + y);</span><br><span class="line">					<span class="keyword">if</span> (L &lt;= R)&#123;</span><br><span class="line">						f[i + <span class="number">1</span>][j][x][y] = max(f[i + <span class="number">1</span>][j][x][y], f[i][j][x][y] + (ex - i - <span class="number">1</span> &gt;= x + <span class="number">1</span>) * (p[ex - i - <span class="number">1</span>][R] - p[ex - i - <span class="number">1</span>][L - <span class="number">1</span>]));</span><br><span class="line">						f[i][j][x + <span class="number">1</span>][y] = max(f[i][j][x + <span class="number">1</span>][y], f[i][j][x][y] + (n - i &gt;= ex + x + <span class="number">1</span>) * (p[ex + x + <span class="number">1</span>][R] - p[ex + x + <span class="number">1</span>][L - <span class="number">1</span>]));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[ex - <span class="number">1</span>][ey - <span class="number">1</span>][n - ex][m - ey]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>动态规划Dp</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC004D]Teleporter</title>
    <url>/2020/02/05/%5BAGC004D%5DTeleporter/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>每个点有一条出边，保证所有点都能到1</p>
<p>修改Min条边的终点，使得每个点都存在到1的长度为$k$的路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>1必须连1自己</p>
<p>自下而上dep到k的时候就挂到1上</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>挂上去的时候dep=-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dep[maxn], n, k, ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		dfs(v, cur);</span><br><span class="line">		dep[cur] = max(dep[cur], dep[v] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fa != <span class="number">1</span> &amp;&amp; dep[cur] == k - <span class="number">1</span> &amp;&amp; cur != <span class="number">1</span>) dep[cur] = <span class="number">-1</span>, ++ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">1</span>] != <span class="number">1</span>) a[<span class="number">1</span>] = <span class="number">1</span>, ++ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">		addedge(a[i], i);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>[Artical]Dilworth定理</title>
    <url>/2020/02/04/%5BArtical%5DDilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h3 id="关于Dilworth定理的证明"><a href="#关于Dilworth定理的证明" class="headerlink" title="关于Dilworth定理的证明"></a>关于Dilworth定理的证明</h3><p>Dilworth定理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于一个DAG而言，最小链覆盖的数量=最长反链的长度</span><br></pre></td></tr></table></figure></p>
<p>设$G=(V,E)$，最长反链长度=$k$，$|V|=n$</p>
<p>设最小链覆盖中划分为$S_C=\{C_1\dots C_k\}$这k条互不相交的链，$C_i$中的元素为$\{a_{i,j}\}​$</p>
<p>设最长反链有$r​$条为$S_A=\{A_1\dots A_r\}​$，且$A_i​$中的元素为$\{b_{i,j}\}​$</p>
<h4 id="第一步，证明-k-leq-S-C"><a href="#第一步，证明-k-leq-S-C" class="headerlink" title="第一步，证明$k\leq|S_C|$"></a>第一步，证明$k\leq|S_C|$</h4><p>根据最小链覆盖的性质，$\forall_{C_i\in S_C,C_j\in S_C,i\not =j},存在 a_{i,x}与a_{j,y}不可比(*)$，不然这两条链完全可以合并，不符合最小链覆盖的定义</p>
<p>如果$k&gt;|S_C|​$，那么根据抽屉原理，总会有两个一条反链中的元素处在同一条链中，二者可比，与假设不符</p>
<p>因此$k\leq|S_C|$</p>
<h4 id="第二步，证明-k-S-C"><a href="#第二步，证明-k-S-C" class="headerlink" title="第二步，证明$k= |S_C|$"></a>第二步，证明$k= |S_C|$</h4><p>(1)当$|V|=0​$和$|V|=1​$的时候命题显然成立；</p>
<p>(2)设当$|V|&lt;n$时命题均成立；</p>
<p>(3)只需证明当$|V|=n$时命题成立即可</p>
<p>由于$G$是DAG，那么一定有一个极大元，设为$X$；考虑$G’=G-X​$，其他定义同上</p>
<h5 id="3-1-证明-S-C’-leq-S-C-leq-S-C’-1"><a href="#3-1-证明-S-C’-leq-S-C-leq-S-C’-1" class="headerlink" title="3.1 证明$|S_C’|\leq |S_C|\leq |S_C’|+1$"></a>3.1 证明$|S_C’|\leq |S_C|\leq |S_C’|+1$</h5><p>显然，$|S_C|\geq |S_C’|$，由于$X$是极大元，不可能把两条链合并；</p>
<p>并且$|S_C|\leq |S_C’|+1$，把$X$单独成链，就是一种一定可行构造方案，其他的方案均不是最小</p>
<h5 id="3-2-证明当-V-n-命题成立"><a href="#3-2-证明当-V-n-命题成立" class="headerlink" title="3.2 证明当$|V|=n$命题成立"></a>3.2 证明当$|V|=n$命题成立</h5><p>令$B=\{maxC’_1,maxC’_2,\dots,maxC’_{k’}\}$，$B$一定是反链，若其中两个元素可比，则与(*)相悖</p>
<p>1‘ 如果$B​$中的元素和$X​$都不可比，那么$k=k’+1​$，又因为$k=k’+1=|S_C’|+1\leq|S_C|,|S_C|\leq |S_C’|+1​$，故$|S_C|=|S’_C|+1​$，$|S_C| =k​$成立</p>
<p>2’ 如果$B​$中有元素和$X​$可比，设其中之一为$b_i​$，那么$C’_i\bigcup X​$是一条链，（$b_i​$是max了），$G’-C’_i​$的最小链覆盖变为$k’-1​$，由前文的假设，最长反链也是$k’-1​$</p>
<p><strong>说明</strong>：如果$G’-C’_i$能构造出更小的方案，那么$G’$一定也有更好方案</p>
<p>对于$G $，最小链覆盖由那$k’-1$条链加上$(C’_i\bigcup X)$这条链共$k’ $条链的方案一定可行，又因为$|S_C|\geq |S_C’|=k’$，故$|S_C|=k’​$</p>
<p>原来$G’$中的长度为$k’$的反链仍然成立，又因为$k\leq |S_C|=k’$，这就是$G$中最长的反链，即$k=k’$，此时$|S_C|=k​$也成立</p>
<p>综上，当$|V|=n​$时命题成立</p>
<h4 id="综上，命题成立"><a href="#综上，命题成立" class="headerlink" title="综上，命题成立"></a>综上，命题成立</h4>]]></content>
      <categories>
        <category>Artical</category>
      </categories>
      <tags>
        <tag>Artical</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>[POI2010]MOS-Bridges</title>
    <url>/2020/02/03/%5BPOI2010%5DMOS-Bridges/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在无向联通图中，每条无向边正向和反向权值不同，将其全部定向，使得存在从1开始的欧拉回路</p>
<p>求该回路上边权最大值的最小值，输出方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>二分答案转化为判定性问题</p>
<p>先贪心地定向，按照较小的来，然后调整反向边，使这个图符合度数限制，网络流判定（把度数给别人）</p>
<p>输出方案的时候，同一次遍历中，晚遍历的边晚访问；不同次的遍历中，晚遍历的边早访问</p>
<p>两个deque维护即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>输出方案挂了好几次，一开始没有考虑两种情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">4</span>]; <span class="keyword">int</span> now[maxn], head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (dep[v] == <span class="number">0</span> &amp;&amp; e[i].f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dep[v] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			flow += tmp;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	maxflow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, u[maxn], v[maxn], a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> Min = INF, Max = <span class="number">0</span>, dex[maxn], last[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dex, <span class="number">0</span>, <span class="keyword">sizeof</span> dex);</span><br><span class="line">	tot = <span class="number">1</span>; <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; mid &amp;&amp; b[i] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= mid) dex[u[i]]--, dex[v[i]]++;</span><br><span class="line">		<span class="keyword">if</span> (b[i] &lt;= mid) ins(v[i], u[i], <span class="number">1</span>), last[i] = tot - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> last[i] = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (dex[i] &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (dex[i] &gt; <span class="number">0</span>) ins(S, i, dex[i] &gt;&gt; <span class="number">1</span>), sum += dex[i];</span><br><span class="line">		<span class="keyword">else</span> ins(i, T, (-dex[i]) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="keyword">return</span> maxflow == (sum &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SPJ&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> to, nxt;</span><br><span class="line">	&#125;e[::maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> head[maxn], dex[maxn], tot = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">		head[u] = tot; ++dex[u]; ++dex[v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> vis[maxn];</span><br><span class="line">	<span class="built_in">deque</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; v[maxn], t[maxn];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dex[cur] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		dex[cur]--;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">				vis[i] = <span class="number">1</span>; t[cur].push_back(make_pair(i,e[i].to));</span><br><span class="line">				dex[e[i].to]--; dfs(e[i].to);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ::n; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (dex[i] != <span class="number">0</span>) dfs(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">while</span> (!t[j].empty())&#123;</span><br><span class="line"><span class="comment">//					if (j == 2) printf("%d\n", t[j].back().first);</span></span><br><span class="line">					v[j].push_front(t[j].back()), t[j].pop_back();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (!v[cur].empty())&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, v[cur].front().first); <span class="keyword">int</span> tmp = v[cur].front().second;</span><br><span class="line">			v[cur].pop_front(); cur = tmp;</span><br><span class="line">		&#125; <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, u + i, v + i, a + i, b + i);</span><br><span class="line">		Min = min(Min, min(a[i], b[i])); Max = max(Max, max(a[i], b[i]));</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; b[i]) swap(u[i], v[i]), swap(a[i], b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = Min, r = Max, ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (check(mid))&#123;</span><br><span class="line">			ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memset</span>(SPJ::head, <span class="number">0</span>, <span class="keyword">sizeof</span> SPJ::head); SPJ::tot = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(SPJ::dex, <span class="number">0</span>, <span class="keyword">sizeof</span> SPJ::dex); </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">				<span class="keyword">if</span> (last[i] != <span class="number">0</span> &amp;&amp; e[last[i]].f == <span class="number">0</span>) SPJ::addedge(v[i], u[i]);</span><br><span class="line">				<span class="keyword">else</span> SPJ::addedge(u[i], v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"NIE"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">if</span> (ans != <span class="number">-1</span>) SPJ::solve();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 6</span></span><br><span class="line"><span class="comment">1 2 1 100</span></span><br><span class="line"><span class="comment">2 3 1 100</span></span><br><span class="line"><span class="comment">3 1 1 100</span></span><br><span class="line"><span class="comment">2 4 1 100</span></span><br><span class="line"><span class="comment">4 5 1 100</span></span><br><span class="line"><span class="comment">5 2 1 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>POI</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>构造</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2007]紧急疏散</title>
    <url>/2020/02/02/%5BHNOI2007%5D%E7%B4%A7%E6%80%A5%E7%96%8F%E6%95%A3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$n*m$的矩阵内有空地、墙和门</p>
<p>初始时空地均站有一人；门一个时刻只能疏散一人；墙不能走</p>
<p>每个时刻人可以往上下左右四个方向动，问最小时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>按照时间分层建图</p>
<p>门-&gt;T的边每次流量是1，空地-&gt;门不用控制，相当于在门里等着<strong>升天</strong></p>
<p>枚举答案，直接在残余网络上跑</p>
<p>最坏情况下时间是400，超过就是不可能</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>没加当前弧</p>
<p>数组小了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID(i, j) ((i - 1) * m + j)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P ((tim - 1) * N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">80005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">80001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">4</span>]; <span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>; <span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[e[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to; now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			flow += tmp;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, N, cnt; <span class="keyword">char</span> g[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("1.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); N = n * m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (g[i][j] == <span class="string">'.'</span>) ins(S, ID(i, j), <span class="number">1</span>), ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> tim = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (++tim)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (g[i][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> (g[i][j] != <span class="string">'D'</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">						<span class="keyword">int</span> tx = i + dx[k], ty = j + dy[k];</span><br><span class="line">						<span class="keyword">if</span> (tx &lt; <span class="number">1</span> || tx &gt; n || ty &lt; <span class="number">1</span> || ty &gt; m || g[tx][ty] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">						ins(ID(i, j) + P, ID(tx, ty) + tim * N, INF);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (g[i][j] == <span class="string">'D'</span>) ins(ID(i, j) + tim * N, T, <span class="number">1</span>);</span><br><span class="line">				ins(ID(i, j) + P, ID(i, j) + tim * N, INF);</span><br><span class="line">			&#125;</span><br><span class="line">		Dinic();</span><br><span class="line">		<span class="keyword">if</span> (maxflow == cnt) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (tim &gt; <span class="number">400</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tim);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HNOI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>时间分层</tag>
      </tags>
  </entry>
  <entry>
    <title>[TJOI2015]组合数学</title>
    <url>/2020/02/02/%5BTJOI2015%5D%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$n*m$的网格中每个格子有一些财宝，每次从左上向右下行走，经过的时候如果格子中有财宝则可以捡起一个</p>
<p>问最小次数，捡完所有财宝</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果把矩阵看成图，显然是个DAG，答案就是最小链覆盖</p>
<p>考虑<strong><em>Dilworth</em></strong>，最小链覆盖=最长反链</p>
<p>反链一定从左下-&gt;右上，Dp即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>最后要输出Max，可以不经过(1,m)的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, a[maxn][maxn], n, m;</span><br><span class="line">LL f[maxn][maxn], Max[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a[i] + j);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">				f[i][j] = Max[i + <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">				Max[i][j] = max(max(Max[i + <span class="number">1</span>][j], Max[i][j - <span class="number">1</span>]), f[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Max[<span class="number">1</span>][m]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TJOI</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>动态规划Dp</tag>
        <tag>网络流</tag>
        <tag>Dilworth</tag>
      </tags>
  </entry>
  <entry>
    <title>[BZOJ2406]矩阵</title>
    <url>/2020/02/01/%5BBZOJ2406%5D%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定$n*m$矩阵$\mathbb{A}$，求$\mathbb{B}$，$b_{i,j}\in[L,R]$，使得$max_{j=1}^{m}\{|\sum_{i=1}^{n}(a_{i,j}-b_{i,j})|\}$和$max_{i=1}^{n}\{|\sum_{j=1}^{m}(a_{i,j}-b_{i,j})|\}$中的max最小</p>
<p>输出这个最小值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大值最小化，按照套路是二分答案，现在变成可行性问题</p>
<p>给每一行每一列建一个节点，每一行的取值显然在$[suml_{i}-mid,suml_i+mid]$之间，分给m列的时候值又在$[L,R]​$之间，每一列也有与行类似的取值范围，容易想到建两层的网络图，转化为有源汇有上下界的可行流判定问题</p>
<p><img src="https://i.loli.net/2020/02/01/PpZdSgWq6ONFV1I.jpg" alt=""></p>
<p>超级源点和汇点流满就是可行</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br></pre></td></tr></table></figure>
<p>把这句话放到if外面大概慢了100倍，求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SS = <span class="number">403</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TT = <span class="number">404</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> d[<span class="number">405</span>], head[<span class="number">405</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	d[u] -= l; d[v] += l;</span><br><span class="line">	addedge(u, v, r - l); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[<span class="number">405</span>], now[<span class="number">405</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(SS);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[SS] = <span class="number">1</span>; <span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == <span class="number">0</span>)&#123;</span><br><span class="line">				dep[v] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[TT] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == TT) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		now[cur] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			flow += tmp;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	maxflow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(SS, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, l[<span class="number">205</span>], c[<span class="number">205</span>], L, R;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="keyword">int</span> S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		ins(S, i, l[i] - mid, l[i] + mid);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) ins(i, j + n, L, R);</span><br><span class="line">	&#125; <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ins(i + n, T, c[i] - mid, c[i] + mid);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) sum += d[i], addedge(SS, i, d[i]), addedge(i, SS, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) addedge(i, TT, -d[i]), addedge(TT, i, <span class="number">0</span>);</span><br><span class="line">	addedge(T, S, INF);</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="keyword">return</span> maxflow == sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> a, j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			l[i] += a; c[j] += a;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">4e5</span>, ans;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>网络流</tag>
        <tag>上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]试题库问题</title>
    <url>/2020/02/01/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>每一道题目可以属于不同知识点（只能选择一个），选出$m$道题目组成试卷，使得每个知识点都恰好达到要求的题目数，求一组方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>网络流建两层的图，最后看中间边的流量</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>没有判last!=0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">20004</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == <span class="number">0</span>)&#123;</span><br><span class="line">				dep[v] = dep[cur] + <span class="number">1</span>; q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			flow += tmp;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k, n, last[<span class="number">2005</span>][<span class="number">25</span>], H = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("2.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h, i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">		ins(i + n, T, h); H += h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		ins(S, i, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v, j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v); ins(i, v + n, <span class="number">1</span>); last[i][v] = tot - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="keyword">if</span> (maxflow &lt; H) <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//		printf("flow = %d\n", maxflow);</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d:"</span>, i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (e[last[j][i]].f == <span class="number">0</span> &amp;&amp; last[j][i] != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" %d"</span>, j);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]软件补丁问题</title>
    <url>/2020/02/01/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>电脑一开始有$n$个病毒，现在有$m$个补丁可以使用</p>
<p>每个补丁只有在当前电脑包含某些病毒并不包含某些病毒时才能生效，它会消除某些错误并带入新的错误</p>
<p>每个补丁有消耗的时间，求最小时间消除所有病毒</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>病毒数量很小$(n\leq 20)$，直接把病毒有无装压，作为图中节点；补丁视为边，炮最短路即可</p>
<p>你问我为什么这题在网络流24题里？</p>
<p><img src="https://i.loli.net/2020/02/01/h5CelX2fFRMd6zj.jpg" alt=""></p>
<p><em>夫妻肺片里应该没有二位吧</em></p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>priority_queue 默认大根</p>
<p>vis数组开小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, b[<span class="number">2</span>][<span class="number">105</span>], f[<span class="number">2</span>][<span class="number">105</span>], t[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">25</span>]; <span class="keyword">int</span> dis[(<span class="number">1</span> &lt;&lt; <span class="number">21</span>)]; <span class="keyword">bool</span> vis[(<span class="number">1</span> &lt;&lt; <span class="number">21</span>)];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">	priority_queue &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(make_pair(<span class="number">0</span>, S));</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis); dis[S] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.top().second; q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[cur] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> ((cur &amp; b[<span class="number">0</span>][i]) == b[<span class="number">0</span>][i] &amp;&amp; (cur &amp; b[<span class="number">1</span>][i]) == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> v = ((cur | f[<span class="number">0</span>][i]) | f[<span class="number">1</span>][i]) ^ f[<span class="number">0</span>][i];</span><br><span class="line">				<span class="keyword">if</span> (dis[v] &gt; dis[cur] + t[i])&#123;</span><br><span class="line">					dis[v] = dis[cur] + t[i];</span><br><span class="line">					<span class="keyword">if</span> (!vis[v]) q.push(make_pair(-dis[v], v));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, t + i, s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (s[j] == <span class="string">'+'</span>) b[<span class="number">0</span>][i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[j] == <span class="string">'-'</span>) b[<span class="number">1</span>][i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (s[j] == <span class="string">'-'</span>) f[<span class="number">0</span>][i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (s[j] == <span class="string">'+'</span>) f[<span class="number">1</span>][i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">	&#125;</span><br><span class="line">	Dijkstra((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (dis[<span class="number">0</span>] == INF) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]家园</title>
    <url>/2020/01/31/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E5%AE%B6%E5%9B%AD/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$m$艘飞船在地球、月球和$n$个空间站间周期性地穿梭，第i艘船的容量为$h_i$</p>
<p>地球上有$k$个人，求最少的时间，把他们全部转移到月球上</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>关于每一个时间点建一层图，飞船穿梭以其容量为流量连边即可</p>
<p>每次加入新的边可以在原来的残余网络上继续跑Dinic</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>忘记判断方案存在性</p>
<p>当前弧优化，不加T一个点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">50001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D (tim * (n + 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P ((tim - 1) * (n + 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pre r[i][(tim - 1) % r[i].size()]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Now r[i][tim % r[i].size()]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, h[<span class="number">25</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; r[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[e[i].to] == <span class="number">0</span>)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to; now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[x] == x ? x : f[x] = getf(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("2.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i] = i; f[T] = T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> tmp, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, h + i, &amp;tmp);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x, j = <span class="number">0</span>; j &lt; tmp; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">-1</span>) x = T;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; r[i].size(); k++)</span><br><span class="line">				<span class="keyword">if</span> (getf(r[i][k]) != getf(x)) f[getf(r[i][k])] = getf(x);</span><br><span class="line">			r[i].push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (getf(<span class="number">0</span>) != getf(T))&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (int i = 1; i &lt;= m; i++)&#123;</span></span><br><span class="line"><span class="comment">//		for (int j = 0; j &lt; r[i].size(); j++) printf("%d ", r[i][j]);</span></span><br><span class="line"><span class="comment">//		puts("");</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	ins(S, <span class="number">0</span>, k);</span><br><span class="line">	<span class="keyword">int</span> tim = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (maxflow &lt; k)&#123;</span><br><span class="line">		++tim;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">if</span> (Pre != T)&#123;</span><br><span class="line">				<span class="keyword">if</span> (Now == T) ins(Pre + P, T, h[i]);</span><br><span class="line">				<span class="keyword">else</span> ins(Pre + P, Now + D, h[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">			ins(i + P, i + D, INF);</span><br><span class="line">		Dinic();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tim);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>时间分层</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]魔术球问题</title>
    <url>/2020/01/30/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$n$个柱子上依次放入$1…ans$的球，使得每根柱子的球上大下小，且所有相邻的球相加为完全平方数</p>
<p>求最大的$ans$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>把每一根柱子看成一条路径，相加为平方数则连边</p>
<p>网络流最小路径覆盖问题，用给定的路径覆盖尽可能多的点</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>r开得太小</p>
<p>整数二分l<strong>&lt;=</strong>r</p>
<p>及时记录答案</p>
<p>以前写的输出方案是错的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, f;</span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">    head[u] = tot; e[tot].from = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn]; <span class="keyword">int</span> T = <span class="number">5001</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">            <span class="keyword">if</span> (!dep[e[i].to] &amp;&amp; e[i].f)&#123;</span><br><span class="line">                dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">                q.push(e[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rec[maxn], upper[maxn], mid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow; </span><br><span class="line">        <span class="keyword">if</span> (dep[e[i].to] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(e[i].to, min(Max - flow, e[i].f));</span><br><span class="line">            e[i].f -= tmp;</span><br><span class="line">            e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">            flow += tmp;</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != T &amp;&amp; cur &lt;= mid) rec[cur] = e[i].to - mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs())&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">int</span> tmp = dfs(<span class="number">0</span>, INF)) maxflow += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>, last[maxn], cnt;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span> e); tot = <span class="number">1</span>; maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head); <span class="built_in">memset</span>(rec, <span class="number">0</span>, <span class="keyword">sizeof</span> rec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; i++) ins(<span class="number">0</span>, i, <span class="number">1</span>), ins(i + mid, T, <span class="number">1</span>), last[i] = tot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= mid; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = i + j;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(tmp) * (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(tmp) == tmp) ins(i, j + mid, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        Dinic();</span><br><span class="line">        <span class="keyword">if</span> (mid - maxflow &lt;= n)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; mid)&#123;</span><br><span class="line">            	ans = mid; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) v[i].clear(); cnt = <span class="number">0</span>;</span><br><span class="line">            	<span class="keyword">bool</span> vis[maxn]; <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">			    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ans; i++)&#123;</span><br><span class="line">					<span class="keyword">if</span> (vis[i] || e[last[i]].f == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">int</span> cur = i; ++cnt;</span><br><span class="line">					<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">						v[cnt].push_back(cur); vis[cur] = <span class="number">1</span>; <span class="keyword">bool</span> f = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> j = head[cur]; j; j = e[j].nxt)</span><br><span class="line">							<span class="keyword">if</span> (e[j].f == <span class="number">0</span> &amp;&amp; e[j].to != <span class="number">0</span>)&#123;</span><br><span class="line">								f = <span class="number">1</span>, cur = e[j].to - ans;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						<span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); j++)</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"%d "</span>, v[i][j]);</span><br><span class="line">    	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1218C]Jumping Transformers</title>
    <url>/2020/01/30/%5BCF1218C%5DJumping%20Transformers/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="640fcd95e1cb883de99745cf5d11c17859ac9116203ff76c55c2d96451d49a5f">56642207b18260fa3cfad3f3995ff646593879568d784f2e8ad75e6883999a87b145f2c737e97385573b061dca7c7da0bffb0fd8dfd3dcd744067af6c79ad78be02834e0110693fb387251db63d5b6e6be4051092ae6fb5f8669678eb67d4063f4efcaaa2689a7729e0d7d7b88fd37eb59cbb34516c22d5e32eab33c961fc24fe46c3fd1acfbb23f9e0387ba41272275fbc3b872cee40781a125afcf850e67ae1d79a5dbd2a520adb863ea2b3eb1a08a5d31ed5fc897445c3590dd7ceccb959da8c8be70c84434e98157ee0fb21a0e4f15d807bc9be60a4c8b52ddec0f27f1a1828ba69be12a5dfc0c0761b0dbed7c8f94292ea7b1b2ea1a5cedc32ba0e64d58d5a41c3fa6d4ed0738a6bb983b85a1a6de79a4872c1b65edc43e02390b0ae220a25441e0edb7f3fd4a1027222686e1e73ce35e44795f8ea77065d94aa73fc271b43531789858267a53a2dd3ff1becd9ea4dd97933f0a2e9f7b77fceb453f54c8cc0354925e8ca478784454025848a753bb8bc47044063d5471830b116eb13da705647db5c9c7f6aa68227269d978745e5425c6d24926b7fe62d85b7699f10684344377e44e3415e392dc4434fcd1eecc8a142ba80e99c42a292bf36c1848eb7dd960604f14897e7b8670d2f4208001499381493d961c82493a26673842ff7317c12224a81dee553b1aad1f78cea9dcdec1f912f5271c430c1f01c5c8ed46aa376c65823a79133fc5c6fdfbec20952c615b22b8a14b5a0b2aacd19b1e4b118f528e516768f7f36c526a90dfc478bf406ee036d8046c5f6bad1782b8f29129963f4e27228c801191f15a312f8dee4ad16329a5a6a15ec836a24a99387137e6a61932f1e2689f650f4683eef4db86ab5d09857677d0e32d365ec25a6d92b9c9bb74d9a8e99c2cf3ca0ad55c1ceb5616d30ddfbbc17ee24d2575a6342693305d3d53099496c0e435f8a452cd44acd0190e19668d18309f345ff3f68765271331e50817be0a1d5021ec691d97f84924f5ed42320b7fe4f025ea350121ee12c9185dd6375f1fd618a0c8690e033181ddedfee5b750ee8d446652c5aba58994371c9fdf11e7edd6cf266edcd3b70cf90aca4d91066dcfc2a5ab260c35eab5db557a1e5fa164b74a4a61c51e4bb464644c5f45213803d3488a2231247ad0720641554a260e338bd735933e5462e61820860aa21f3a9510b74451eeebace45c2016a76fe129ab7e767117da8ac23df683670ad3fd1cbf96b954a33eaee0fed2f6ddbcdb92143584b860754896e74e4d38af70676fb9e83130a7e546ddce0fe62c05a113b370bbe12e35ce740f45769367c99c0bf113faff8b5e73af86c8ec9d43e234bbc1c95e1a5467b3edc8dba3f520ce8ca5494194a1c3f6aeecc7f22484d796a7cfb77a3f9d80d87244225e3371b798d95c1b5191f09bce7060eb406b4ef13d01a5d1b79e1cd9de8ed41fcaa5b90eb3d9d920b901ef94d18cd329d6d749e593a937ece75611e2d6329d0503320771f3d8ec373ef824e1a25009f84964928ae86b31588d3bdbbc5d9d295361997173d3bf01adc1310ec3af32e4a4afdc2f4e2dba17866e452f9bc98e3fd479ba05c85a928c20ece3d5da449aed65f8c37f1834da97949f09e5df500651aee57b3c4398412370e9881c668b39cb90eeb5c7f2425dea17127e4cb7a48d92952d8b81972eef987b6c22c83bf70e5f8f96858386a08d912db757116eb4a2e2d60ff33049c754b8b7a2f333e217ba2e59648b478d31a8f98ea0c28b444d0752e0accafe2d909b8075a29ad38d2d6c6ea4887ea9d7ea19775089faa00866fe07ac4fe76bf99bddd98abe57316fa50e0db4b93696663d9242f397771108eeb3a1829731269c764015154a0e67bcbb45402c2affcf4de5dd533ea6cc48acd3790059c27fccae25ab7ca816357ff0ad3df5872896543a63b7f87ac8d6ed50eebf0b7e863c04798e3e37e2faaec7e9515637725eb9808b96468ef017af46a8c328ecf4d12778491b45f2286ff4b0c2be989784bc6dbaa268218b7dcc89e8bebd15b4c5861e9a20ee778da08ae125efe9ebfa67ef146f58fecc8c1959ccb4d145a1c09222820a6fd3a30e8f7c012edd2c086162bb0bd399eefaf29088059b2865a2b1fad0fb2583e0393a094c991065b4888427d575269665f52907c113e5b577a507e46282f8a8ddc541585e47fb308e27b8948c417bee562db26b35bce4082b0a898c55443967a089910542bf0e851b9e377a2c7f3883c79b13f58af856c87b756b6b69113250391295e631e5e2c51a741e0b4cf95e3605fe40e024ea1f7d4dceaabc371414a30bb734c8ecbe8880754e4d0417f3c4a3981f025da2d89e0728cf4e61a533b878c6c9b1d5fd649ae56af4347fc288e7d11e36b0784c0fb28d5114ad3450c98765eb969452c81e27cd20c3aa430c02fce62843115bc99779269893b1aa66abb95febd800f9b405842bd70075cb5f2945e359e49f84e8ae604cc2b0ad4d7d21d4fed5e945f2ca4dbea7ae0128161551985cd4fc1f1f1b6933ee8b3281c11fbc7e5d741298b4e877011aeaadddcb5e373f3faad4aa836507d3344e77336e9bff432088001803a8a9cfd537acce3daa23ca6e5a5a91d19d5dcc855ecd3ac4b35a6ea2810385b2307c3c5b7556532454200a670bc962b993ad35bdcdfdccfa2f65974c7443a3cdc9ab17515f627790c7062c87e101bef9306b736d6315bb7ec2fdfccb78faa8ebabba6281b3668937ad5b4e23a38b42683a2344633a9b4ac7e9a152d47c1a6a4580d74e34fe5b12efe711ac19a1d57d382550d9e9e5a67addd78ae598e69d5bf7540136a3d4773ba3123ae00954255ba6c52264d0df9d85d03c89c6bd74b596aef1bc1500656d816af6e7403174b71ee52f7f6193c66186d019dfc0d2cdb316475142cba1ba4168bc638e4dfbe8d14b8b609b51cbe697f575939af05563af07c492ff730b45391675f32a5c71a793e8a2b1735e588a175b5f1b4d7a3627d85668c758bdb54ca7a7ae2ca22eb8c56ec0cd28cdcaeacde8a8bd946308f2aa1d0edde8c50c41fefe9beda3ddc5ffd6b45fd2be1ca099af1c1058e0eb5ceac61862b341d67869e211a0eb666af6cc6e0814128655efa1e249ab60946bd0019b7a0723d33f1eb2fecbbe0ee961f9cc1607ff13a750757246c56947f1ae44c167a71ccbd4f221f19e4e3931cad5942bb677d125f5e287eaed34d3d17a899f428bedd088cdc3ee67ad7d0b8265052c3ff8ff6ac8d8958b6f309d5f3e436448e01dfe4ac6ed0eca9a4414b3287051cfee0b639030e7ef50b069b481055db46f45a1ce298ac11c4b1cfe8e8b2f7d009793ccb35a28dd9720bc0f580f022f9d29dcebc7efe78df8060e5b4de4089466bf79c0eeb4ed8239aacc7af0b17b437c24ebf386aef872eef6aedadf8c3a5f14e4620f5b17e37bfa37e47b106a1599e61f15d086145bc24160ebf68b9bc7c954710afe4d90147bd4bdb4260c9e886814c1536ef7eda5b26c2c6bef299d04ae113e3aeb781007d68883bcc0fc3ab9842838f368cae37a823d5f0d8d18a0156a32baea9c09df8ecca60622946d5c9e869b802ea8d5d15e01ecfe56d16f112d0d43bbf537e2e875a7fa1841bb676b8cdddc2db9710a823200ac1d403baabd8a1fe86bc1221809ecf0aa60aae1df9a43c5e56a12c6ddea9bece3f5720781c4bbba3dfbd56be39100a0f904bd1b7a4c7de0dc8aafa3522311fa5c621df3644ee98a20da74eaa1961783c26e3b53f69664fcea9c4a96cb469ae45e787fde712593c0fdccef00b72deb4d5fc25c21ab9cb2efbb465e8e926b442d9787475166b6051e55e10be6681d888d975156909f1650359069c269a3b66a978f9b6aed7264ed8dc5245f8212fafe13a04e2ddb72eb025ba5961c8fb4ec0c4f562811057ed892ed7d3c09e25c9a4808b3724fe66967f16c513decc879a45f5c6b9e79501de1525f76be99b9d1f6d7b3babe5daa6e55884247254d17ffa103d325c80490844bab1e9babc6801bdee05cf9f5b355f0af56a9224c810e019cdcbe825a71a60471123e7bb28729a4add790c217f147af27042cb89757e383a6805cf2b5c19727cd049a8aa80de0894c7dbedbe12f21085c35733680d77d5fedef83bdbd31c85906ec6d561bc333ad430d49e42cff4d4365b02afddc465301d82d46c71746b0631a2e44f0233116b1b383567b662a5837cbed55a7d548fe8811632ccffefaf464b3b3439c9da1c75efcbce35f1ee50c38b42c542ecc16afb82e87c868dca3e5b312165d2fa63903b22fcff021c48c2650b0307368e9b4f5994295071c689d55e8ba2b3f6195d4c269e4a968878a1de42ac28fd5232a3eb4b990ce1ffcdd245db4878acab4114f6b1f7a0988596db4489d39146ee734ad59ce8c0fa28cd557835695ace036568a04ac9e13fdeb6ddf91315800315f85620820eb7d434d9ae755e5ffaf33c40f3ee23a68997622f1c6c55d2a9af25a6940acb760bc7949832078bdf3108d1122cf9d2ba71eede7ff8f72e780a713f74bde0d3f27d08d75c684621e0c1305b6e86b39f3d48438c05e9e3c91e9005aa2f14b36d0635798c105eae9b2f650370f500ca0a02ee4ec2c592ecaed133579411bd796918ec5ec54573a7cf796c52441a3ea0c15b7f4f2fd4aeda595f75f5e69c0f876adc3105d724020de8b240d1f5b71e4da189ad32deb896b29ac87e350004f56e55d4096fdb21702540c508001d065a3367af4e7863296639ef26b69a1d1a03c2fe44261dac1140e1341188677e611fc6d17d42fb7cc49cf73b2b0f2a7a1fbee5e0ae3c37e0fef631bc8036788fe775ec0552460de14fb81e51670d076db0eec7c2d12a683794d6ee0f9f7c204b636fa2a487a687c5c9ea1757f5e0af583ff6c1fc5e524ae4853d92c1a09cd09899a4ee0aaf3da9d2d4e2715d8b9f5a55017e7899ab871fb2a3f4151eb4fffdbe01edef9052dcd2be40482a9d5887cb0c2e2056ce667ba9c9baef8397f425431ebc42a0ab342d3ca9e0bfd11a024ad0cba8050811949906de554de95d1ebd379a9cde1dea4f229003bcd6e64c4dccfcfc72a864bf19a7e2a5a12ac53db9a296dcf93fbe3234cfd319d23bbf2eef7aecd93c0814becd7ffbcef62bd355faee4a2d7f455532e0876a94ba0584e66531d9b02d94f37bc0142b57b7ad8da0df677fed7ea52a7f9c109fcc38db178a7df841dc7072abe1a3251ad9d7d21a1ad976143536f1e25d7d98408e10f8ca4fa8698f30a2f062261cabacc50c5b933046d77568646978426504c23de9c7c7fa87cfeaaff57e31cae238deeca5352a9edbbce48502cd9b39c0abb920a579e5d551be6bf482b8e41ac7eec2129b5355eee384e3562c1c3e07e0e888af36576b887bc83df2ddaace801e540535c29b0e753dc0db6b434e1765c47ecd6e2f749d8ef08f6911be0433a543e6f90500a01e8a60609f02875acef7a9f6c96f109ff15ea8a9026594deaef51f65afc21ae319782a977778f0cb94b22de6b21bef5f58286b9fd93385cd5cbe7ce30cc59aa7293b0774e76efa18e1ec09cd3ed9e198d6ffe96e1cb529757bc6de46026e26d14fb92f77d90aedc16dca76df251c4f66f65203bfd86d01b5e420dc15d19948fad0b31d865f12490d9f3edba485388e7ea7ed99d8e68ad1da9d187abe992b01ab0ae764c526ab48fc8245ea326639558aa1e6a212d9ba7720d4116aa0625043942bf60361edc286f8ff5711dcef53591febea9d98c3dec8f1785ada2e62e3f1922d03e0ee1c0d65b06b9795706ae35a3bda1dd9a998bfee6a38f3fd66a7e4e66bde920e74f48dcd17a7ae98c0ba809ec0c03136a736308c03c2f99dc2019820f379734ed20b0f73ddfe56f1ebad3fe20c85d21128c5abccf3dc3d597124bbb4810dd18f677b5e7570f08ca3787e8ecb0f2897f53c99318201a0219702ca3cbbfaf4a34865073696da69a93781deff3d3b90f9b27496af88fbbd0df5f47126214eeb22695fe05302c02a8a0673c0734833407de3b3efe6b6f770ec24265b493d17d0e854066b6eb6f8e57e212a07b522d91b8e88077f59560060c20842a7aca10b97b27e3f3421e7a393019862687b38dd15ef590972de6b0923fd0fea279a7e68d5575d83429cca62f4a597f24e9cf998664494f0992d77cb45017938d836c9b610ed41ec97c033ba5a3f93aecc1d6d51c05577b388c1402157b9ddbc7fb57d19e99e2dea89c5738b959ba74644dd3158c2b423894839506ba1f679fa9dfca9f1e82945788052b9785163ab3262dd5bc057a93a8e2a8b88188f7288d092555f241f71972c5f4c5f0fb0c51fd76fe2402455274b7642620fe345f28add67f8d5bca1057c312359c6ff572c6d0261fac891d62031c3305c496e37dda07719e6369c0b9806e44ed0bf9a8b54f074505e1c4d7a0886d5b769091395bd092cf5d6c65c8fc3ff122b80a3a5d83063f521e252d20218fffc31e1f01a496c344b8919eaac68c8e65db48d4b0d4972a1bb90f1f69278a3df5705a4390972453ce820133f661544924c99659a235bd7e3bb825bc120f9e590e0d01a5f131a8569648dc288db0f9905adbd129d5e0fd05d34f62682b04263062d90b4ef93f01db2854b2ab6091ea6cfabe3542187b93a6c8a76058840228b7f428c75af59d946eca609aefee038fbe270dd501fbc3467b07302493c0545474b64edd25a31ef3c8e429f6c284e8506f5b7a47a0741a3b11ad77c71913d751bec438d9f8ff99053c981ceec035f492dda905607b197cb2ab7ef3ac1cfd2548cfacfc6f85e8ad5772c9ef238288a3c92f19be2170d4d076c49aa494d5b91b5c62d83dc95b1deb73e358d8524474acf462119fe53d3250ac4bab7e642aa670256ea9022552d47f43541758f178c31e77dd935f147c0cf5838a6d529a25a0484fee41b771dd7c04abeaa443a987aa0b516d4e0e3081be55d57728919c9a8763ed904ed0f4f7c1b930706123564459ebff28c1e2493503e66f89b10c95bfd44e18c9d8dcabda29b11872faf639f3c91aaa3c4394c99e030e849c61f31b98bba575e9734e649fdfe3ac4c4bf1000213b5fe21c4c4dd27e6a46ac465bd8d8eaea75870cab7d53bd7a7e2f6793ba7578df9e59a527ccf72193a118ede85239d6c4628db1e38ffc65bc09e2311a9cd99a91e26f76f71f44d7b5bb1f1510f43661171a8f8e4527c9e887474610651c3ce56a70a93fff93fd4503cdabf8d5f77d6ccb35e2ede54fc9e76ae1b569a4d905c9e569f3d659f2562eabe5747041fd71cb6c7ffcddaa67daa9c68459795d669857256c72aeced27b182eb8a5eb383d645e5c1301c9b7d61ca61769b0e29794f2b6e1ff7ae4cf8a43e3753572f0418c2714619da1f24614ad160ec4efa77568c3419c05567fa7fb0a45b7e68f692e9fe20eede6feac7919ab54410008f5ed871bfbdce9331c9aa46b502be1d881fe4d4e6030bfb67e515ab53d1b88ae738289d21160e79298bc6c71bfc9ac54ca471cb98f0bfac20fe0d711846242b6274e57d9f763d7bafc6379b8f8963e400cace20c969e960f080ff090e40100dcadc52cc74047f7c1310f1e90114ae0f2f57000cad924e34cf13d29db3b400bf2bf8340b743488f98541bc679d92d7b633eacea812b10e5f3310e0822218f3706cba9461eb608b6bc78eee637d94e3557aa48c7dd89642a18ed9998e18ebde5e05b49438e3f2b64253ef4812e74aa3b10d0304516f1ce5f2955e2e6008bb99b4f48ceea4e829fec8a951e9e13860659d4d6543e96e56fb18a6ac283d3396311ed651229b23e7e75815b8e654485591ea67dbf53d2ae5f7a121c4bef22664511e2b03e7d4a7fbfd7f37c4caee5a6bee9e09057a22db9f52d491b3b255a15d0039a9275acd9e71f388a03088f320660e77effbcb0d5bf8503b0c7c408d7d02a76a2430b79e912923d284a8f8a3e732d85e982b1bb5c16408fc2bc73af7a86137083f4bd4710510e202efed6056269ecb216bb290aab6be019475af54d3545bee6425c5ccabc3569e7fce7b34a37042b5ba3391905cfc0e5a94c2994f8d220fb175084624103125c84fa7817ab40a2dbcce5915ebe37b102cdd689850e32ce5cfb9194c93fb52e51f0e2e9e895014cd06af66e893356e4ba414b90c22d24a2c9b2685b6cb14faf9c567800ed7385ec581cbc5aab29baaf17c1829a24a121da05835a62230a1cedccd6433d6af227fe19f24b8112ad90d95d718285b5b560014329d101b85b38e644c9577909cf5b6110c34e075bc0b4170852c53a15374caf6d6807c525c9a07516488b4914aab2e4e4bd79f73e275071fa02a74c5dcc6f1108054f2d5e2b343c7da9ff605af41240ec41e109d167a6bb50d7428b090fe020416d7d0542a37ac2d064023ba97a6b7618e0c611af7e80a4626144a93d3ba3ac88c674d7a66e6d1b73a3f9ea535e3f56c11e9c1f038457f537f7d9a8216194222b7674fbc57f248986386873f25464467c695eafa01446fe54c636b24d8b5753281c50f323e54a4057a683abc1c1d225131e8638fcf4acec779305170925050f64e940fe7ebaf6a1d6481cc2e0e253dc1d712b40feaa80f3e2fd4f79f37e59e08619761085426960e1802155b7741ebc06b858fa6a573190fcc12715aff168d831e0b6d7dfedc94fbe84b3f7c97e90f06ca78051a75beaf19be841b20b80546d20fdf6c381596d30125a3520281cfe47ef0a7c8768f7a8d626630a8adb9aaf8a27bc02dc6be0e1aa3ca7c6cb94d7ea289daaab82077fc9c3b6c744ab53492f9f00f13a5f4d23818bddbb52797bc39be2f99fa02ca07959d93e7129608d2adfb3fcde5024028a41340fde48f179d800d5c569258c2414ef7ac60e5663f0427bea322e392f87c6dc943a3db97d2601b07d51833731f180bab5496ecb9352750b6b9df19cae5c92c75f46a8b35ae3184797728994c655153e45dbd4ae13696486590aaa909da233832c7d6d57c100597ef7de5ca38873aa06ce99412888128d32e204a784fd0010bc20b06c0bc5a6bb804d612c14ce0979360f9247ab04552ed5acdb3d70c63e000ee39e2108929a5a27960731b20195834ecc17fe8b2f8068b9e417d72d26cc8f62dc7c0415213437744b6913509353eab855e8da527d001326270342afe58a27d72836cb0ed2d62bab576e91f240d9255bce3dfd61e898f04d1a8e75ce3cc4e910842b15f97be34702bce7d024a9897be8a86cecd42ca6fa7ca81903420ba7e1ce044042c4adb3b6ae26a3c18ceb020c1c06ac2d6e6763440d2db0309433f0656fdf55d7b9f8197ab3d94061ebfe99e96f417af43026a0c45f65d0ce6431f86ae3978c72ef6fa9c9d8d095c2195534d21fb69064469f2c13e734bfa9a0bb0e3c2924ec5a2a3166eacb70ef888df8458b4911eeb9ea2b75d341cf1c952b8ada4baf7700e78edcc9f47c33520f840c490dce86e397e6ff219ad5904549bc22a9b8e8fafae2a5541260f1ee19da98d5120394eedd97fc8912c1bfd8abb67c9d2e143219772adfc5ecffe45edfe640ad2ce58a2b4c489cbd052acbbe3aa26682165eef066d2abed6fefdce84e2733686bb083aff4b0a07cb50a9228caaea9cda6811a32d53eced7233215f5a891cffef1e7dbedee7a8776b9fa06c5d6afb2e04f001f7d1568520f22941fffc22be4c4e20677d6a66bfe5d827904f4bf6e3c131fbd35d863c046e55187e55a080d4288ccfec7002d2402db3d4189a5eaa368a304ce64f726feb725f79c78d659d942e3a7e58c508e2119754bd33f1dcc158dc525bd57d6d75564378130694788d4f057210aa096d626a17e6c55873904065d393d89054de6fe2e10ecf7ef1d49f2d793ad87b3ac274844ab5f2a4538348cce401a680dae5c813173c73609eaa11ae3884a5837b03a49ef5025e7dd4987f027dfd8a52c5609824de9032cada500416bb901a18cd0ab46e8c9c08a385b0463ee0d0344c705eac9858d37b1bcaa7de3a341558e13bc2b03ef705283a07a4080d336383f92e07a9988b430c3908493a2162f942869cc9e94405ec27bf45b873be7ef0965d4eb005109b7cfb2786494f8f6808e091368f3623936703a69d76a5e58f7738703bbad98d00f394b8c41b7470c6d4af607348205060f8bb0278bb60b02c7b209c400cf8394de14e0df536dd38fc66dd9342708ada2d93f9b365e0aea0dba7e521c4d226938371d823eabc427456b44892ce61dcdd386ad4f823a6fe035599fe40e4fc457cdfc178a9f96b4326de025cd0cb7148dc01b303191c916b62f09f17cbbdc6a1a48d60d98e8a32c0196ee7221f9ee268e6ed15085dc80ea77a8664e77f840f31e7246fc7c8dff2994011f838df5cba6170e0afa425a10757e21854181836bb8a38df690c7552c223b336c0c15af21ea99b3dafcdad625905fff75aad1c37b810f592060cb2036fbd6ab87c98e174174efd98616871ce86f42b109f693dcaa5f88d8fa8484e14fb1852d2ff1703fa2486abd2ac857a3ac0acbc58a77864bb1757cf1afaa203286c160a037e1a24b6e46898903b13e7ccf8d27febf4f946942a1e178fcf9510be5cc6d543b01af0e39d2bf4230c20c1a11bd780012a7bf18cc55648d6fbfe806b212986d6f3985e7fd15d196b399cb0f8e46a0ff8335486a05517de0b9caee867629a223b48d84c8aa9fd65f9d6983632c833e7cb22b10854d8bd35abbc7a7b4da414a967e166fe63f7475b3a8f57534157ce0fc61de3848ea6e8b92b4884fe8d19359fd13bdecd320604730758c6aeb37ff43484bdd546b251be72bbbb718be2e2233d5026fe5b9945e919aba41befb7970e0846676b851fb5d6d6b280634292aba75fb37aadd135388bef7c8cbf9de6dda606f87355615e450f6285bbedad869b6e6232c2b6ca37f3a3573862fb8cdf5835293f740aac8b2f298e93a43397d4f4fc7b885be572d4d9e0b661d7a041c72943fb3c7872626750833c6611a69fd4e9b9b56b382d49cbe52f52716178efa8a830a8b608ae0a234514fc3990c3a1868963e6f2592df8b85fa869fe7dda257f462b74c7c8dca85721c8ea44559e256bacf0a0c774045aef081348e92938e47c93f8cd5f953f5f51f75eea3f0a71d5c0355e223f9f16856bd1f9bdef42a2956fe8561140022f38b037cadfd5b8c6438c1ef762c507fa2be8f4127a9c343690c32f96fcd68bd15e3a59a7ff4b2c31f3892ac577ef1df015295e12978bbbfcfd59c5dbca6df7666f7df1eee710ee872370933f4052b023f5717c8e256f8b664e3d000e9ba82480b38656eb61114d9058eeba5fa49fb172944767bb13fc5e1b2d4113cb228aba5f618034607246c99924cb6a2a685d91e15be827370e304393017550021f74f1178f12ca8700e8869d9c221090ad9962de214014adb12c6b142fe427b4b32fa1539dae02d042c21b1823601d366c19493afb0b9e69f4be218748c55c723afd131ca604865364f56fdf0cb5f0072ba9ccb47b6730c3075fb6dc8995a14e1324a8330298db8142d391ef07aa4667945d9fba129e9c6a072ccdfb1aca6b87654e67d693b4069ee8997133afc3f5e8c2c05982c86527154a5f557176658421e33deeb3b3d57c2b5809a09a5bdfdefd606c4fe864d08a924c059934c8516b49f7f0c30f62847493be20fe663df7a715d5151d46daf99d8d35855d4b3426ca8adaa99be8e5758ab97961543c3a61e85b55b79062009219ab832b59ae62e0955be92ffa6eacbd4955d52f790b902b672d8c80680ecaa2b1e49f41abce6cfa413b4c773768d62554e14ac89aec88dd32f47af8370c6ab4ad6d5efd50d1c215354c54e74970e5baf2b86f82826d1fbc791e312ef3dea97bbfff23c3805b0e3ddbbfe251fcdc72730a95d08134c55f8cbd7a71ce4672df3b7226966a9aff1d4ed866db95c69b7a2fd3c622014652a3e5c0746dabc40f49cda16876ec818f6e5cc86ea80e9c76b3ab227c0ec7bc58c33a5ebeb9c0ce9efacc8be2baf2383c7e5964fb2b0d09ceaa3d9be606d5c78c45aacda45528825296b8624cbac1e3b239bf058168f077c1ff43a1a3cb4752735f385335f07af97e5b6d266951125b731295111afd5db958dfb01fcd9c1be21985e52e44bb228f355b8b7bcb357852314554222c5d772c74dcc7ae3306288a59dd3b734b54349e0e0521ac52f45e000e5e1ed7869fdfd7ae99ce332e3f0bfdcc311d54ce0e3e3d6da8c430cbc79f315950cb72628a78065545c5cf38014f85ea8f1f865b21d2b63ff91275a83b438a9f6c313591151af1acf93ab8c7800abd8ec438fba6afd933f408d7c4a64f73c58d894c57ad7a8b43ead377207e4352a95b28ecb49926a6cfe33c5f9dd2e5697c67387f6d6fd86a23af18c9bd1b967070d3431cb25e15b92487e8181efa8148d8042785b8265f06fd255b8c7404e0c503b1775922beeedae5f60d488aa32386c399f615478c60370fab04a23967846a6bca782ab3bdfada601ea1d12df146d08806027f4abed78bb1b3f6da90e4fb189c948e2bc83da851e1bb515e4acfda562467b65412d97a844c6523ff961e7101c1e399ee6c440124c52db44c88f5bf00d9ca272dace30ccf50e90bfdcd03049d683f178da7f32c1007b855dfbbf4d0d30bf27d4aee5b1fcba0b07f466e37b2cfb03eed4de721b7945ea1fc377afc84318e8d73b89051ec1f2524cdda78ac06ed71d98adee8e19ddaaed1da87f6afeac135e7c3420210876b8a302776b43aa9b058e8a3ed83d3bfe32eb8f735400df5362e74bcb316a959cff8e7b54a4c1770263e67d0b352044460f509608e2dd2f80a79c209455188efe680c886c23f210590a7b92863fa861915a72044d2e5c19187650a16d5102a128060dd9217706e91795df0082bbb4eae36eb6a053edf0b3f32372bd2a7b0f50fce8300925c3948a97fb39026178fe16c862a415ed43582093693edc579040594a7bccadebe21309bdfa982f4e7f538a9b03ec386030a6070093aa38e93486499889632b2c01a6335de27efd0d31efe5a5a559f0cdcc638c7db720a4c825ae4daf027a896ff886fcb030725f738f89e222f71251a1d34fab62e35faeff7b458a9d6cc49318aca70c53d01b4bac3975ada12aee285cb69730c55eeaad6a3cf9ba01fc7c2d68a25084bc1317c3e68ba4166863fecb7ccd5df918ff6e0d8eba588e92b15a1e368837fc8b78d30d59e3b44f9c1d17e5b29ee5fe2d83c136a91411b4d418f2bb605722ae20a0bf46e686b04fedcd6eaa430d94814af3da0af664c8054fe9008d08954f81aaad82d256715876b4668b62df014c4d6d678f6463bc0bdf323d661e8662b09c38455030435a02831f2933b958fb05035beba2690a2bdcc5d96d717b3c9c4e4b50994b54929adebc5a7663ca601270097f4684445641a954c09f5fd9af50dd946c6d7569ffe2b45fdfb25243846ff5928e21c7ecc64b37ddb2c1f867fd16d680a0209c93257ccb933ba6ce92f241d7f641c8f504f720c1314e569e0d64fc8c9d656863ea56a40458bf94f1a92a3b67bbbfae72a0f902eb767321c88cb61d312ddac508deca28fa14b1afa35778b23e76ec6bcf4ff8da1b9c5ba9b6d9fb3b826bebc08fdb2f2e0845f76e5628fc7f4c98c97ab0bb7e51707605201f4e09afebd9d9c706d4b8f62dd39113aa7d34a9447a20b8955d112cd8fb8d61dadf6092f0f40f3998fd43c3f0fd3839a5f649764f1fcfd3af4199049d3819466dbdb32051b28dc8145f88bffb122e0288fd1439f39d796602fbb52d01554b981d063a092deab13be36d0c44a65ccad4753b49defc173488a5a927432a61a642e7ae1574c09cc4908172cc53c4b34e39df6fd0ba5c5fc580c9583ad3bf7577bc7694fbf2cadd24bb75e39e70d836ecf9bc2ffe931e68d9c29eb5b6bb1a36f890bb65094ead26c0f3b48543e15ac5936093b2627391df96bd6d9aef2648d13924da39e554e8ff0349e2b1371310d4da9cfe10074f13eb1efe34cb5a9b597a41b5f85d874e9020538bd60bd0a9f9f34c9aabb26bfb176cd3e684dc17331acdb84f575ff80238430c6a7372575b696f4921ce81e08396dfd3348ea2e6507061a503cd9a89b55a1c6a902465cfd8d0c9e3f910a75ecb6496f8a53df35ae369104a0b43231b2fbec81cd3f3330bbe18a2cccc5b41804faff682697b12568f3906876041362f3bdf4faa5e7426711cfa144ded309de0eb9f1e020d0cacd8d79dfea44e6567e8ff8dd6a72c38f82e3e5d4661d3bdcb652c440249934da9cf696b6f35e120077df0d847d74af13d46e2d46d43b686e2b24914f89966cfd46f0d9f109e4526d50ef379ecb705fe172df7299352951be5d90b34c2ed7f4ba2bbd5a4e7d71c3166248ae5a2098dc6921d7c132054d38db81b938b8215698a4a8edd3289c334128975b6abfadca027e9c262bbf45c3e42b3dcd336da759808e3c85fae1aa8b8196ae8c44036d33a0fde2ee1542d071c8b1e428e521ca044b118d1d25201555b93faaa90573dffced08c88a65cb83ba5d60432cabb866233ec6ce125580de39d60df1203de4f42e9c8322bbdf7188f787ed7a11d20cd7bc15f7bf335e0d25effa618a17aec0d68dc42691f672bb8b155376bc3496ad1c8229b59ffd17b303682933cdada4a9d77dffa4cbd73705ab9b364275d5bbf31336c7eb720d4a49f9d910f87abe0d305c3fbee66d4bef48c5c1d5da997a359d02cee3bd1c683f20fb671ef1a6605a653850945fcc8daa50fd171741ef157d028342287288d927cb915a29e9b9c3fea7278e33b924c44dbcc56ad63cd38f88e167c89c3cba1ac9f4b6fcbf34a355de6d39f691c585711b24c2f7880bc23395c77e47205fff50e94ea4d137c9afef64eb783cee17b84abd67086db7b9e5c67e8c21e40f68e317dafdc0fe5019ad5427a229b590d9f0fe05d3402a119c98f0daceeb07c1fdfe5ea510905e898aebdf5d50f03e29b43dd949927686a32fda53456e6fd2502955b6220dc995ff3caeb7ea503ca416acf1bbbe87930016d7f1b522646d2202fd8b3604a9dc31e002945b369fcbdb3c9aa8f7fc43158f80229e69e5af90e72ce69b605f41f857c75e51422cd21092c6debdee44419ba0afa29281d9b19c67f848c730bdaeadebac8ecbf16fa162c38fcb4d4cec1f2f9d0fcd9eb91f612c9f4eadfdd562f0e219827aa3edb0791b29165108dd9c04b0f7a936628c84128290468ad66f968e31f896435e2775a0c4c18497853b49c1105405b6e472fe1132759810e96e21b8329e4e9807cee4719f22d4d1ecc51a287bc9de6f576c67a848657dc9f5dfe4914c4c88aed56b83e70c13942c527b90054210cba02b50e356e89618bd295c8782a3aca40689416dfb4ef1d305651ebb7e8f86ebfd4be57d0cce34ac14f95fe7523fddcf50832248d5b9b8cfe876087c88080a54deb</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>动态规划Dp</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]最小路径覆盖问题</title>
    <url>/2020/01/30/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>用几条链覆盖有向图，链之间不能重叠，求最小的个数并输出方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>构造二层的网络跑最大流即可，答案没问题</p>
<p>构造方案的时候根据$2i+1$-&gt;$T$的流量找到链头，再根据中间的流量构造即可</p>
<p>好久之前写了个错的代码，测试过了，数据差评</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>更改构造方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">12005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f);</span><br><span class="line">	addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn], T;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">	q.push(<span class="number">0</span>); <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (!dep[e[i].to] &amp;&amp; e[i].f)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> upper[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (flow &gt;= Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">if</span> (dep[e[i].to] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(e[i].to, min(Max - flow, e[i].f));</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(<span class="number">0</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, res[maxn], last[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		ins(u &lt;&lt; <span class="number">1</span>, v &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	&#125; T = n * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ins(<span class="number">0</span>, i &lt;&lt; <span class="number">1</span>, <span class="number">1</span>), ins(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T, <span class="number">1</span>), last[i] = tot - <span class="number">1</span>;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="keyword">int</span> ans = n - maxflow;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i] || e[last[i]].f == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> cur = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">			vis[cur &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">bool</span> f = <span class="number">0</span>; <span class="built_in">printf</span>(<span class="string">"%d "</span>, cur &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = head[cur]; j; j = e[j].nxt)</span><br><span class="line">				<span class="keyword">if</span> (e[j].f == <span class="number">0</span> &amp;&amp; e[j].to != <span class="number">0</span>) f = <span class="number">1</span>, cur = e[j].to - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]太空飞行计划问题</title>
    <url>/2020/01/29/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一些正权点和负权点，选择一个正权点就必须选择某些负权点，问最大收益</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>说说怎么建图</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/21712.png" alt=""><br>来自 SSL_XXY_BlackCloud </p>
<p>如果求这个网络的最小割，那么要么S-正权点的边被割掉，要么和该正权点相连的负权点-T的边全部被割掉，这恰好符合题意</p>
<p>割掉的部分就是损失的部分，要不实验做不了，要不就是仪器要钱，用$\sum p$减去maxflow即可</p>
<p>输出方案的时候有<strong>trick</strong>，最后那次dfs中dep为0的实验就是被砍掉的，不做的；dep不为0的实验相连的仪器dep显然也不为0，又由T的dep为0可以推得它们连向T的边全部砍掉了</p>
<p>不能用e[i].f的理由就是e[i].f不能判断这个点是否被割掉，反例如下：</p>
<p><img src="https://i.loli.net/2020/01/30/3kOW9P6zSsemvpV.jpg" alt=""></p>
<p>虽然1-&gt;3流完了，可是1-&gt;3并没有被割掉</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>bfs没有重置dep</p>
<p>输出方案没想到用dep，在用e[i].f</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;addedge(u, v, f); addedge(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, c[maxn], p[maxn], tp;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], last[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">				dep[v] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			flow += tmp;</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(S, INF);</span><br><span class="line">&#125; <span class="keyword">bool</span> f;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch &amp; <span class="number">15</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span>) f = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("1.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i); tp += p[i]; f = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (v = read())&#123;</span><br><span class="line">			ins(i, v + n, INF);</span><br><span class="line">			<span class="keyword">if</span> (f == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, c + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ins(S, i, p[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ins(i + n, T, c[i]);</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (dep[i] &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (dep[i + n] &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tp - maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]飞行员配对方案问题</title>
    <url>/2020/01/29/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求二分图最大匹配</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>复习一下模板</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>bfs中vis的位置：要记录的是右边的有没有在这次匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m, n, u, v, ans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="keyword">int</span> mat[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[v] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (dfs(mat[v]) || !mat[v])&#123;</span><br><span class="line">			mat[v] = cur;</span><br><span class="line">			mat[cur] = v;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">	<span class="keyword">while</span> (u != <span class="number">-1</span>)&#123;</span><br><span class="line">		addedge(u, v);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">		ans += dfs(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ans) <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (mat[i] &gt; i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, mat[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>[网络流24题]餐巾计划问题</title>
    <url>/2020/01/27/%5B%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%5D%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>每天需要$x_i$块餐巾，购买餐巾一块$p$元，快洗$f$元$tf$天，慢洗$s$元$ts$天</p>
<p>要满足每天的餐巾需求，问最少花费</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>拆点，$i$是脏餐巾，$i+n$是干净餐巾</p>
<p>购买餐巾从S连到i+n；快洗i连到i+tf+n；慢洗i连到i+ts+n；不洗i连到i+1</p>
<p>每天消耗$x_i$条，源点连i；i+n连汇点</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>当天用完的餐巾当天可以洗</p>
<p>long long</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">4001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f, c;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">4</span>]; <span class="keyword">int</span> head[maxn &lt;&lt; <span class="number">1</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f, e[tot].c = c;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f, c);</span><br><span class="line">	addedge(v, u, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> inq[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> pre[maxn &lt;&lt; <span class="number">1</span>], dis[maxn &lt;&lt; <span class="number">1</span>], flow[maxn &lt;&lt; <span class="number">1</span>], last[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis); <span class="built_in">memset</span>(flow, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> flow); <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop(); q.push(S);</span><br><span class="line">	inq[S] = <span class="number">1</span>, dis[S] = <span class="number">0</span>; pre[T] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop(); inq[cur] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[cur] + e[i].c)&#123;</span><br><span class="line">				dis[v] = dis[cur] + e[i].c;</span><br><span class="line">				flow[v] = min(flow[cur], e[i].f);</span><br><span class="line">				pre[v] = cur;</span><br><span class="line">				last[v] = i;</span><br><span class="line">				<span class="keyword">if</span> (!inq[v])&#123;</span><br><span class="line">					inq[v] = <span class="number">1</span>; q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (SPFA())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = T;</span><br><span class="line">		maxflow += flow[T];</span><br><span class="line">		mincost += flow[T] * dis[T];</span><br><span class="line">		<span class="keyword">while</span> (cur != S)&#123;</span><br><span class="line">			e[last[cur]].f -= flow[T];</span><br><span class="line">			e[last[cur] ^ <span class="number">1</span>].f += flow[T];</span><br><span class="line">			cur = pre[cur];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, tf, f, ts, s, p, x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, x + i);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>, &amp;p, &amp;tf, &amp;f, &amp;ts, &amp;s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ins(S, i + n, INF, p), ins(i + n, T, x[i], <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i != n) ins(i, i + <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">		ins(S, i, x[i], <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (i + tf &lt;= n) ins(i, i + tf + n, INF, f);</span><br><span class="line">		<span class="keyword">if</span> (i + ts &lt;= n) ins(i, i + ts + n, INF, s);</span><br><span class="line">	&#125;</span><br><span class="line">	work();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mincost);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最小费用最大流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>[PKUSC2018]真实排名</title>
    <url>/2020/01/25/%5BPKUSC2018%5D%E7%9C%9F%E5%AE%9E%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出序列$\{a_i\}$ ，将其中$k$个数翻倍，求对于每个数而言大于等于它的个数不变的方案数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>分类讨论即可，还是比较简单的题</p>
<p>当$a_i$不翻倍，则$[(a_i +1)/2),a_i)$中的数不得翻倍，其他随便$C_{n-x-1}^{k}$</p>
<p>当$a_i$翻倍，则$[a_i,2a_i)$中的数必须翻倍，其他随便$C_{n-x}^{k-x}$</p>
<p>边界讨论比较烦：0的时候要特判，不满足上述计算；相同的数要小心</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>排序没有排回来，导致答案乱序</p>
<p>0没有特判（真想不到！）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, a[maxn], tmp[maxn], fac[maxn], inv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>; x %= mo;</span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % mo;</span><br><span class="line">		x = <span class="number">1l</span>l * x * x % mo;</span><br><span class="line">		t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (m &gt; n || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1l</span>l * fac[n] * inv[n - m] % mo * inv[m] % mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> x = lower_bound(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>, l) - tmp;</span><br><span class="line">	<span class="keyword">int</span> y = upper_bound(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>, r) - tmp;</span><br><span class="line">	<span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), tmp[i] = a[i];</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mo;</span><br><span class="line">	inv[n] = <span class="built_in">pow</span>(fac[n], mo - <span class="number">2</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = <span class="number">1l</span>l * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mo;</span><br><span class="line">	sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, C(n, k));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> ans = (C(n - <span class="number">1</span> - f((a[i] + <span class="number">1</span>) / <span class="number">2</span>, a[i] - <span class="number">1</span>), k) + C(n - f(a[i], a[i] * <span class="number">2</span> - <span class="number">1</span>), k - f(a[i], a[i] * <span class="number">2</span> - <span class="number">1</span>))) % mo;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PKUSC</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>[APIO2016]划艇</title>
    <url>/2020/01/22/%5BAPIO2016%5D%E5%88%92%E8%89%87/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有n个数，每个数可以在$[a_i,b_i]$之间取值，也可以取0</p>
<p>要求数列中所有非零数构成严格递增序列</p>
<p>求方案数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>容易想到用$f_{i,max}$表示dp完前i个之后最大值为max的方案数</p>
<p>由于a、b太大，而我们关心的只是大小关系，因此想到离散化，令$f_{i,j}​$表示dp完前i个之后最大值在离散后的第j个区间中</p>
<p>$f_{i,j}$由两部分得到：当p&lt;j，$\sum_{p=0}^{j-1} f_{i-1,p} \cdot (t_{j+1}-t_j)$</p>
<p>当p=j，我们发现还须知道前面的数中有几个在该区间内，那么再加入一维状态k，</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{lim_j} \frac{C_{t_{j+1}-t_j}^{k+1}}{C_{t_{j+1}-t_{j}}^{k}}=\sum_{k=1}^{lim_j-1} \frac{t_{j+1}-t_j-(k+1)}{k+1}</script><p>一个trick：离散化的时候把$a_i$和$b_i+1$丢进去，这样区间就是左闭右开的了</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>一开始没有考虑p=j的情况</p>
<p>线性逆元打错了</p>
<p>f开小了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], f[maxn &lt;&lt; <span class="number">1</span>][maxn], sum[maxn &lt;&lt; <span class="number">1</span>], lim[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>, tmp[maxn &lt;&lt; <span class="number">1</span>], inv[maxn &lt;&lt; <span class="number">1</span>]; <span class="comment">// f [)</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("1.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, a + i, b + i);</span><br><span class="line">		tmp[i * <span class="number">2</span> - <span class="number">1</span>] = a[i]; tmp[i * <span class="number">2</span>] = b[i] + <span class="number">1</span>;</span><br><span class="line">	&#125; sort(tmp + <span class="number">1</span>, tmp + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> cnt = unique(tmp + <span class="number">1</span>, tmp + <span class="number">2</span> * n + <span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		a[i] = lower_bound(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, a[i]) - tmp;</span><br><span class="line">		b[i] = lower_bound(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, b[i] + <span class="number">1</span>) - tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n * <span class="number">2</span>; i++) inv[i] = <span class="number">1l</span>l * inv[mo % i] * (mo - mo / i) % mo;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) sum[j] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt; b[i]; j++)&#123;</span><br><span class="line">			++lim[j];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = lim[j] - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">				f[j][k + <span class="number">1</span>] = (f[j][k + <span class="number">1</span>] + <span class="number">1l</span>l * f[j][k] * (tmp[j + <span class="number">1</span>] - tmp[j] - k) % mo * inv[k + <span class="number">1</span>] % mo) % mo;</span><br><span class="line">			f[j][<span class="number">1</span>] = (f[j][<span class="number">1</span>] + <span class="number">1l</span>l * sum[j - <span class="number">1</span>] * (tmp[j + <span class="number">1</span>] - tmp[j]) % mo) % mo;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">			sum[j] = sum[j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = lim[j]; k &gt;= <span class="number">0</span>; k--) sum[j] = (sum[j] + f[j][k]) % mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (sum[cnt - <span class="number">1</span>] - <span class="number">1</span> + mo) % mo);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APIO</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>动态规划Dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2004]郁闷的出纳员</title>
    <url>/2020/01/21/%5BNOI2004%5D%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>维护数据结构，支持以下操作：</p>
<p>1.插入 2.把所有数的权值改变一个数 3.删除所有小于Min的数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>平衡树维护，2操作视为Min的上下浮动，插入时-delta即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>rotate没有pushup</p>
<p>删除的时候ans可能不止+1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> Q, Min, delta = <span class="number">0</span>, cnt = <span class="number">0</span>, ans = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> son[<span class="number">2</span>], v, sz, lnk, rd;</span><br><span class="line">	&#125;a[maxn * <span class="number">40</span>]; <span class="keyword">int</span> tot;</span><br><span class="line">	T()&#123;tot = <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> S(d) a[a[cur].son[d]]</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		a[cur].sz = S(<span class="number">0</span>).sz + S(<span class="number">1</span>).sz + a[cur].v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = a[cur].son[d ^ <span class="number">1</span>];</span><br><span class="line">		a[cur].son[d ^ <span class="number">1</span>] = a[k].son[d];</span><br><span class="line">		a[k].son[d] = cur;</span><br><span class="line">		pushup(cur); pushup(k);</span><br><span class="line">		cur = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">			cur = ++tot;</span><br><span class="line">			a[cur].lnk = x;</span><br><span class="line">			a[cur].rd = rand();</span><br><span class="line">			a[cur].v = a[cur].sz = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk == x)&#123;</span><br><span class="line">			a[cur].v++;</span><br><span class="line">			a[cur].sz++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> d = a[cur].lnk &lt; x;</span><br><span class="line">		ins(a[cur].son[d], x);</span><br><span class="line">		<span class="keyword">if</span> (S(d).rd &gt; a[cur].rd) rotate(cur, d ^ <span class="number">1</span>);</span><br><span class="line">		a[cur].sz = S(<span class="number">0</span>).sz + S(<span class="number">1</span>).sz + a[cur].v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &gt; x) del(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[cur].lnk &lt; x) del(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!a[cur].son[<span class="number">0</span>] &amp;&amp; !a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				ans += a[cur].v;</span><br><span class="line">				a[cur].sz = <span class="number">0</span>; a[cur].v = <span class="number">0</span>; cur = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!a[cur].son[<span class="number">0</span>] &amp;&amp; a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				rotate(cur, <span class="number">0</span>);</span><br><span class="line">				del(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (a[cur].son[<span class="number">0</span>] &amp;&amp; !a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				rotate(cur, <span class="number">1</span>);</span><br><span class="line">				del(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> d = S(<span class="number">0</span>).rd &gt; S(<span class="number">1</span>).rd;</span><br><span class="line">				rotate(cur, d);</span><br><span class="line">				del(a[cur].son[d], x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a[cur].sz = S(<span class="number">0</span>).sz + S(<span class="number">1</span>).sz + a[cur].v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (S(<span class="number">0</span>).sz &gt;= x) <span class="keyword">return</span> find(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (S(<span class="number">0</span>).sz + a[cur].v &gt;= x) <span class="keyword">return</span> a[cur].lnk;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> find(a[cur].son[<span class="number">1</span>], x - S(<span class="number">0</span>).sz - a[cur].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> -INF;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &gt;= x) <span class="keyword">return</span> pre(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">return</span> max(a[cur].lnk, pre(a[cur].son[<span class="number">1</span>], x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	srand(<span class="keyword">unsigned</span>(time(<span class="number">0</span>)));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Q, &amp;Min);</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">char</span> opt[<span class="number">5</span>]; <span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, opt, &amp;k);</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'I'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (k &gt;= Min) t.ins(rt, k - delta), ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'A'</span>) delta += k;</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'S'</span>) delta -= k;</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'F'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (k &gt; cnt - ans) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.find(rt, cnt - ans - k + <span class="number">1</span>) + delta);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (t.pre(rt, Min - delta) != -INF)&#123;</span><br><span class="line">			t.del(rt, t.pre(rt, Min - delta));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>[CQOI2017]老C的方块</title>
    <url>/2020/01/20/%5BCQOI2017%5D%E8%80%81C%E7%9A%84%E6%96%B9%E5%9D%97/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在下图所示的方阵中，蓝边是挡板，按照一定的规律出现</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/5092.png" alt=""></p>
<p>有一些方格中放了方块，清除方块要一定代价，求最小的代价，使得以下的形状不出现</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/5093.png" alt=""></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先棋盘黑白染色，然后再按照是否与挡板相邻染成四色</p>
<p>重要发现：所有不喜欢的图形一定由四色各一种组成</p>
<p>建四层的图，跑网络最大流即可，因为最大流一定是所需的最小代价</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>dfs的时候min(Max-flow,e[i].f)，把已有的flow减掉！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn * <span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S, T, dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">	q.push(S); <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].f == <span class="number">0</span> || dep[v] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dep[v] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (dep[T] &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (flow &gt;= Max) <span class="keyword">return</span> Max;</span><br><span class="line">		<span class="keyword">if</span> (e[i].f &gt; <span class="number">0</span> &amp;&amp; dep[v] == dep[cur] + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(v, min(Max - flow, e[i].f));</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs()) maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; lnk;</span><br><span class="line"><span class="keyword">int</span> L, C, n; <span class="keyword">int</span> x[maxn], y[maxn], w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;C, &amp;L, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, x + i, y + i, w + i);</span><br><span class="line">		lnk[MP(x[i], y[i])] = i;</span><br><span class="line">	&#125; S = n + <span class="number">1</span>, T = n + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i] % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y[i] % <span class="number">2</span> == <span class="number">1</span>) ins(S, i, w[i]);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] + <span class="number">1</span>, y[i])]) ins(lnk[MP(x[i] + <span class="number">1</span>, y[i])], i, INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] + <span class="number">1</span>)]) ins(lnk[MP(x[i], y[i] + <span class="number">1</span>)], i, INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] - <span class="number">1</span>)]) ins(lnk[MP(x[i], y[i] - <span class="number">1</span>)], i, INF);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x[i] % <span class="number">4</span> == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y[i] % <span class="number">2</span> == <span class="number">0</span>) ins(S, i, w[i]);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] - <span class="number">1</span>)]) ins(lnk[MP(x[i], y[i] - <span class="number">1</span>)], i, INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] + <span class="number">1</span>)]) ins(lnk[MP(x[i], y[i] + <span class="number">1</span>)], i, INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] - <span class="number">1</span>, y[i])]) ins(lnk[MP(x[i] - <span class="number">1</span>, y[i])], i, INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] + <span class="number">1</span>, y[i])]) ins(i, lnk[MP(x[i] + <span class="number">1</span>, y[i])], min(w[i], w[lnk[MP(x[i] + <span class="number">1</span>, y[i])]]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x[i] % <span class="number">4</span> == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] - <span class="number">1</span>)]) ins(i, lnk[MP(x[i], y[i] - <span class="number">1</span>)], INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] + <span class="number">1</span>)]) ins(i, lnk[MP(x[i], y[i] + <span class="number">1</span>)], INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] + <span class="number">1</span>, y[i])]) ins(i, lnk[MP(x[i] + <span class="number">1</span>, y[i])], INF);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> ins(i, T, w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x[i] % <span class="number">4</span> == <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] - <span class="number">1</span>)]) ins(i, lnk[MP(x[i], y[i] - <span class="number">1</span>)], INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i], y[i] + <span class="number">1</span>)]) ins(i, lnk[MP(x[i], y[i] + <span class="number">1</span>)], INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] - <span class="number">1</span>, y[i])]) ins(i, lnk[MP(x[i] - <span class="number">1</span>, y[i])], INF);</span><br><span class="line">				<span class="keyword">if</span> (lnk[MP(x[i] + <span class="number">1</span>, y[i])]) ins(lnk[MP(x[i] + <span class="number">1</span>, y[i])], i, min(w[i], w[lnk[MP(x[i] + <span class="number">1</span>, y[i])]]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> ins(i, T, w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CQOI</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>染色</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]Treap</title>
    <url>/2020/01/19/%5B%E6%A8%A1%E6%9D%BF%5DTreap/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>维护一个数据结构，支持插入；删除；查询某个数的排名；查询排名为x的数；查询前驱；查询后继</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>Treap，结合二叉搜索树和堆</p>
<p>按照随机权值以堆的形式排列，保证复杂度</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>暂无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> S(d) a[a[cur].son[d]]</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> son[<span class="number">2</span>], v, sz, lnk, rd;</span><br><span class="line">	&#125;a[maxn &lt;&lt; <span class="number">1</span>]; <span class="keyword">int</span> tot;</span><br><span class="line">	T()&#123;tot = <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		a[cur].sz = S(<span class="number">0</span>).sz + S(<span class="number">1</span>).sz + a[cur].v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = a[cur].son[d ^ <span class="number">1</span>];</span><br><span class="line">		a[cur].son[d ^ <span class="number">1</span>] = a[k].son[d];</span><br><span class="line">		a[k].son[d] = cur;</span><br><span class="line">		pushup(cur); pushup(k);</span><br><span class="line">		cur = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">			cur = ++tot;</span><br><span class="line">			a[cur].sz = a[cur].v = <span class="number">1</span>;</span><br><span class="line">			a[cur].lnk = x;</span><br><span class="line">			a[cur].rd = rand();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk == x)&#123;</span><br><span class="line">			a[cur].v++; a[cur].sz++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> d = (x &gt; a[cur].lnk);</span><br><span class="line">		ins(a[cur].son[d], x);</span><br><span class="line">		<span class="keyword">if</span> (a[cur].rd &lt; S(d).rd) rotate(cur, d ^ <span class="number">1</span>);</span><br><span class="line">		pushup(cur); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; a[cur].lnk) del(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; a[cur].lnk) del(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[cur].v &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                a[cur].v--;</span><br><span class="line">                a[cur].sz--;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!a[cur].son[<span class="number">0</span>] &amp;&amp; !a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				a[cur].sz--;</span><br><span class="line">				<span class="keyword">if</span> (--a[cur].v == <span class="number">0</span>) cur = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (a[cur].son[<span class="number">0</span>] &amp;&amp; !a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				rotate(cur, <span class="number">1</span>);</span><br><span class="line">				del(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!a[cur].son[<span class="number">0</span>] &amp;&amp; a[cur].son[<span class="number">1</span>])&#123;</span><br><span class="line">				rotate(cur, <span class="number">0</span>);</span><br><span class="line">				del(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> d = (S(<span class="number">0</span>).rd &gt; S(<span class="number">1</span>).rd);</span><br><span class="line">				rotate(cur, d);</span><br><span class="line">				del(a[cur].son[d], x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pushup(cur);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk == x) <span class="keyword">return</span> S(<span class="number">0</span>).sz + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &lt; x) <span class="keyword">return</span> S(<span class="number">0</span>).sz + a[cur].v + rank(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &gt; x) <span class="keyword">return</span> rank(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (S(<span class="number">0</span>).sz &gt;= x) <span class="keyword">return</span> find(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (S(<span class="number">0</span>).sz + a[cur].v &gt;= x) <span class="keyword">return</span> a[cur].lnk;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> find(a[cur].son[<span class="number">1</span>], x - S(<span class="number">0</span>).sz - a[cur].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> -INF;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &gt;= x) <span class="keyword">return</span> pre(a[cur].son[<span class="number">0</span>], x);</span><br><span class="line">		<span class="keyword">return</span> max(a[cur].lnk, pre(a[cur].son[<span class="number">1</span>], x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">suf</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].lnk &lt;= x) <span class="keyword">return</span> suf(a[cur].son[<span class="number">1</span>], x);</span><br><span class="line">		<span class="keyword">return</span> min(a[cur].lnk, suf(a[cur].son[<span class="number">0</span>], x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t; <span class="keyword">int</span> Q, rt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> opt, x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) t.ins(rt, x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">2</span>) t.del(rt, x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.rank(rt, x));</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.find(rt, x));</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.pre(rt, x));</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.suf(rt, x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>模板</tag>
        <tag>Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2015]亚瑟王</title>
    <url>/2020/01/19/%5BHNOI2015%5D%E4%BA%9A%E7%91%9F%E7%8E%8B/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$n$张牌，每张牌有$p_i$的概率被打出，造成$d_i$的伤害</p>
<p>每回合按顺序考虑每一张牌，若该牌打出就结束该回合</p>
<p>共有$r$轮，求造成的期望伤害</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>要解决的就是第i张牌前打出牌数量不同，设前i张牌中出了j张的概率为$f_{i,j}$，容易得出f的递推式</p>
<p>分别解决每张牌被打出的概率</p>
<script type="math/tex; mode=display">
P_i = \sum_{j=0}^{r} f_{i-1,j} \cdot (1 - (1 - p_i)^{r-j})</script><p>统计答案即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>循环的范围太小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> p[maxn], d[maxn], <span class="built_in">pow</span>[maxn][maxn], f[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(<span class="built_in">pow</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> <span class="built_in">pow</span>); <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;r);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, p + i, d + i);</span><br><span class="line">			<span class="built_in">pow</span>[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r; j++) <span class="built_in">pow</span>[i][j] = <span class="built_in">pow</span>[i][j - <span class="number">1</span>] * (<span class="number">1</span> - p[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(i, r); j++)&#123;</span><br><span class="line">				f[i][j] = f[i - <span class="number">1</span>][j] * <span class="built_in">pow</span>[i][r - j];</span><br><span class="line">				<span class="keyword">if</span> (j != <span class="number">0</span>) f[i][j] += f[i - <span class="number">1</span>][j - <span class="number">1</span>] * (<span class="number">1</span> - <span class="built_in">pow</span>[i][r - j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">double</span> P = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(i, r); j++)</span><br><span class="line">				P += f[i - <span class="number">1</span>][j] * (<span class="number">1</span> - <span class="built_in">pow</span>[i][r - j]);</span><br><span class="line">			ans += P * d[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HNOI</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>[PKUWC2018]Minimax</title>
    <url>/2020/01/15/%5BPKUWC2018%5DMinimax/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵二叉树，即每个节点最多两个子节点</p>
<p>对于非叶子节点$i$，有$p_i$的概率选择子节点中权值较小的，有$1-p_i$的概率选择较大的</p>
<p>对于叶子节点，权值给出，且保证所有叶子节点的权值不相同</p>
<p>问最后根节点的权值情况</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先把权值离散化，对于节点cur，权值为i的概率为</p>
<script type="math/tex; mode=display">
p_{cur}\cdot (\sum_{j=1}^{i}f_j)+(1-p_{cur})\cdot (\sum_{j=i}^{m}f_j)</script><p>考虑优化向上合并的过程，刚好可以用线段树合并，合并时顺便维护前缀和、后缀和即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>线段树合并的时候先合并了左儿子，权值改变了，更新右儿子的时候出问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS a[a[cur].ls]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS a[a[cur].rs]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>; x %= mo;</span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % mo;</span><br><span class="line">		x = <span class="number">1l</span>l * x * x % mo;</span><br><span class="line">		t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv = <span class="built_in">pow</span>(<span class="number">10000</span>, mo - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> link[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> ls, rs, v, tg;</span><br><span class="line">		A()&#123;tg = <span class="number">1</span>;&#125;</span><br><span class="line">	&#125;a[maxn * <span class="number">40</span>];</span><br><span class="line">	<span class="keyword">int</span> rt[maxn], tot = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].tg == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		LS.v = <span class="number">1l</span>l * LS.v * a[cur].tg % mo;</span><br><span class="line">		RS.v = <span class="number">1l</span>l * RS.v * a[cur].tg % mo;</span><br><span class="line">		LS.tg = <span class="number">1l</span>l * LS.tg * a[cur].tg % mo;</span><br><span class="line">		RS.tg = <span class="number">1l</span>l * RS.tg * a[cur].tg % mo;</span><br><span class="line">		a[cur].tg = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur) cur = ++tot;</span><br><span class="line">		<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">			a[cur].v = k;</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; pushdown(cur);</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) a[cur].ls = upd(a[cur].ls, l, mid, p, k);</span><br><span class="line">		<span class="keyword">else</span> a[cur].rs = upd(a[cur].rs, mid + <span class="number">1</span>, r, p, k);</span><br><span class="line">		a[cur].v = (LS.v + RS.v) % mo;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pfu, <span class="keyword">int</span> sfu, <span class="keyword">int</span> pfv, <span class="keyword">int</span> sfv, <span class="keyword">int</span> P)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur &amp;&amp; !v) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pushdown(cur); pushdown(v);</span><br><span class="line">		<span class="keyword">if</span> (!cur)&#123;</span><br><span class="line">			a[v].v = <span class="number">1l</span>l * a[v].v * (<span class="number">1l</span>l * P * pfu % mo + <span class="number">1l</span>l * (<span class="number">1</span> + mo - P) * sfu % mo) % mo;</span><br><span class="line">			a[v].tg = <span class="number">1l</span>l * a[v].tg * (<span class="number">1l</span>l * P * pfu % mo + <span class="number">1l</span>l * (<span class="number">1</span> + mo - P) * sfu % mo) % mo;</span><br><span class="line">			<span class="keyword">return</span> v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!v)&#123;</span><br><span class="line">			a[cur].v = <span class="number">1l</span>l * a[cur].v * (<span class="number">1l</span>l * P * pfv % mo + <span class="number">1l</span>l * (<span class="number">1</span> + mo - P) * sfv % mo) % mo;</span><br><span class="line">			a[cur].tg = <span class="number">1l</span>l * a[cur].tg * (<span class="number">1l</span>l * P * pfv % mo + <span class="number">1l</span>l * (<span class="number">1</span> + mo - P) * sfv % mo) % mo;</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, t1 = LS.v, t2 = RS.v, t3 = a[a[v].ls].v, t4 = a[a[v].rs].v;</span><br><span class="line">		a[cur].ls = Merge(a[cur].ls, a[v].ls, l, mid, pfu, (sfu + t2) % mo, pfv, (sfv + t4) % mo, P);</span><br><span class="line">		a[cur].rs = Merge(a[cur].rs, a[v].rs, mid + <span class="number">1</span>, r, (pfu + t1) % mo, sfu, (pfv + t3) % mo, sfv, P);</span><br><span class="line">		a[cur].v = (LS.v + RS.v) % mo;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">			ans = (ans + <span class="number">1l</span>l * l * link[l] % mo * a[cur].v % mo * a[cur].v % mo) % mo;</span><br><span class="line"><span class="comment">//			printf("%d %d %d\n", l, link[l], a[cur].v);</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		calc(a[cur].ls, l, mid);</span><br><span class="line">		calc(a[cur].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> v[maxn], tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head[cur] == <span class="number">0</span>) t.rt[cur] = t.upd(t.rt[cur], <span class="number">1</span>, cnt, v[cur], <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		dfs(e[i].to);</span><br><span class="line">		<span class="keyword">if</span> (t.rt[cur] != <span class="number">0</span>) t.rt[cur] = t.Merge(t.rt[cur], t.rt[e[i].to], <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1l</span>l * p[cur] * inv % mo);</span><br><span class="line">		<span class="keyword">else</span> t.rt[cur] = t.rt[e[i].to];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("1.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> fa, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa); addedge(fa, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (head[i] == <span class="number">0</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, v + i), tmp[++cnt] = v[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">	&#125; sort(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (head[i] == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = lower_bound(tmp + <span class="number">1</span>, tmp + cnt + <span class="number">1</span>, v[i]) - tmp;</span><br><span class="line">			link[p] = v[i];</span><br><span class="line">			v[i] = p;</span><br><span class="line">		&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	t.calc(t.rt[<span class="number">1</span>], <span class="number">1</span>, cnt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PKUWC</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF555E]Case Of Computer Network</title>
    <url>/2020/01/01/%5BCF555E%5DCase%20Of%20Computer%20Network/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给无向图定向，使得满足q组u能到v</p>
<p>只需告知可能或不可能</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然边双里的点可以不用管，因此想到缩点</p>
<p>缩点之后要判断是否有一条边被两种不同的需要覆盖，链上打标记差分即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>本地调的时候有两个dfs没调用，缩点的时候注意不要一条边走两次</p>
<p>CF上一遍过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, u[maxn], v[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], tdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> col[maxn], Ctot = <span class="number">0</span>, Ttot = <span class="number">0</span>; <span class="keyword">bool</span> ins[maxn];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s; <span class="keyword">int</span> rt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">	rt[cur] = Ttot;</span><br><span class="line">	dfn[cur] = low[cur] = ++tdx;</span><br><span class="line">	s.push(cur); ins[cur] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">if</span> ((i ^ <span class="number">1</span>) == pre) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dfn[v] == <span class="number">0</span>) Tarjan(v, i), low[cur] = min(low[cur], low[v]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) low[cur] = min(low[cur], low[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (low[cur] == dfn[cur])&#123;</span><br><span class="line">		++Ctot;</span><br><span class="line">		<span class="keyword">while</span> (s.top() != cur)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = s.top(); s.pop();</span><br><span class="line">			col[tmp] = Ctot;</span><br><span class="line">			ins[tmp] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		col[cur] = Ctot; ins[cur] = <span class="number">0</span>; s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], f[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	f[cur][<span class="number">0</span>] = fa; dep[cur] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[cur]; i++)</span><br><span class="line">		f[cur][i] = f[f[cur][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">		<span class="keyword">if</span> (e[i].to != fa) dfs1(e[i].to, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="keyword">if</span> (dep[v] - (<span class="number">1</span> &lt;&lt; i) &gt;= dep[u]) v = f[v][i];</span><br><span class="line">	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="keyword">if</span> (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">	<span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tg[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(v, cur);</span><br><span class="line">		tg[<span class="number">0</span>][cur] += tg[<span class="number">0</span>][v];</span><br><span class="line">		tg[<span class="number">1</span>][cur] += tg[<span class="number">1</span>][v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tg[<span class="number">0</span>][cur] &gt; <span class="number">0</span> &amp;&amp; tg[<span class="number">1</span>][cur] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, u + i, v + i);</span><br><span class="line">		addedge(u[i], v[i]);</span><br><span class="line">		addedge(v[i], u[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i]) ++Ttot, Tarjan(i, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span> e); <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head); tot = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">if</span> (col[u[i]] != col[v[i]]) addedge(col[u[i]], col[v[i]]), addedge(col[v[i]], col[u[i]]);</span><br><span class="line">	dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> qu, qv, i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qu, &amp;qv);</span><br><span class="line">		<span class="keyword">if</span> (rt[qu] != rt[qv])&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"No"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		qu = col[qu], qv = col[qv];</span><br><span class="line">		<span class="keyword">int</span> lca = LCA(qu, qv);</span><br><span class="line">		tg[<span class="number">0</span>][qu]++, tg[<span class="number">0</span>][lca]--;</span><br><span class="line">		tg[<span class="number">1</span>][qv]++, tg[<span class="number">1</span>][lca]--;</span><br><span class="line">	&#125; dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>差分</tag>
        <tag>边双</tag>
        <tag>Tarjan</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF813D]Two Melodies</title>
    <url>/2019/12/24/%5BCF813D%5DTwo%20Melodies/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$\{a_i\}$中找出两个子序列（可以不连续），使得每个序列中相邻两数查为1或为7的倍数</p>
<p>求两个子序列长度和的最大值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令 $f_{i,j}$表示前面两个断点分别在i和j的最大值</p>
<p>暴力$\theta(n^3)$转移，枚举断点，枚举原序列的数字均可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	f[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">			<span class="keyword">if</span> (_abs(a[i] - a[k]) == <span class="number">1</span> || a[i] % <span class="number">7</span> == a[k] % <span class="number">7</span>) f[j][i] = max(f[j][i], f[j][k] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (_abs(a[i] - a[j]) == <span class="number">1</span> || a[i] % <span class="number">7</span> == a[j] % <span class="number">7</span> || j == <span class="number">0</span>) f[k][i] = max(f[k][i], f[j][k] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (_abs(a[j] - a[k]) == <span class="number">1</span> || a[j] % <span class="number">7</span> == a[k] % <span class="number">7</span> || k == <span class="number">0</span>) f[i][j] = max(f[i][j], f[i][k] + <span class="number">1</span>);</span><br><span class="line">			f[j][i] = f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对枚举断点的进行优化，记录所有$k\in [0,j-1]$的满足条件的Max即可</p>
<p><del>前一种比较难优化</del></p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>一开始写的没法优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn], n, a[maxn], Max1[maxn * <span class="number">100</span>], Max2[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> _abs(<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(Max1, <span class="number">0</span>, <span class="keyword">sizeof</span> Max1); <span class="built_in">memset</span>(Max2, <span class="number">0</span>, <span class="keyword">sizeof</span> Max2);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">			Max1[a[j]] = max(Max1[a[j]], f[i][j]),</span><br><span class="line">			Max2[a[j] % <span class="number">7</span>] = max(Max2[a[j] % <span class="number">7</span>], f[i][j]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			f[i][j] = max(f[i][j], max(Max1[a[j] - <span class="number">1</span>], Max1[a[j] + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">			f[i][j] = max(f[i][j], f[i][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">			f[i][j] = max(f[i][j], Max2[a[j] % <span class="number">7</span>] + <span class="number">1</span>);</span><br><span class="line">			Max1[a[j]] = max(Max1[a[j]], f[i][j]);</span><br><span class="line">			Max2[a[j] % <span class="number">7</span>] = max(Max2[a[j] % <span class="number">7</span>], f[i][j]);</span><br><span class="line">			f[j][i] = f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) ans = max(ans, f[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF796E]Exam Cheating</title>
    <url>/2019/12/21/%5BCF796E%5DExam%20Cheating/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>考试中学渣旁边坐着两个学霸，学渣一题都不会，学霸各有一些题会做且保证正确</p>
<p>学渣一共可以偷看P次，每次最多看一个学霸的连续的K题，问他最多看对几题</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令$f_{i,p,l,r}$表示考虑到第i道题目，用了p次偷看机会，左边学霸上一次偷看还有l道题可以看，右边学霸上一次偷看还有r道题可以看的最优解</p>
<p>分情况讨论（看哪边，是否重新开始）即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>一个地方dr打成r</p>
<p>\(a[2][maxn]\)定义成\(a[maxn][2]\)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pre f[(i + 1) % 2]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> now f[i % 2]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dl max(l - 1, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dr max(r - 1, 0)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, P, K, l[<span class="number">2</span>], a[<span class="number">2</span>][maxn], f[<span class="number">2</span>][maxn][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;P, &amp;K);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t, i = <span class="number">1</span>; i &lt;= l[<span class="number">0</span>]; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); a[<span class="number">0</span>][t] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t, i = <span class="number">1</span>; i &lt;= l[<span class="number">1</span>]; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); a[<span class="number">1</span>][t] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (P * K &gt;= <span class="number">2</span> * n)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tmp += (a[<span class="number">0</span>][i] | a[<span class="number">1</span>][i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f[<span class="number">0</span>]); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(now, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> now);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= P; p++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; K; l++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; K; r++)&#123;</span><br><span class="line">					now[p][dl][dr] = max(now[p][dl][dr], pre[p][l][r]);</span><br><span class="line">					<span class="keyword">if</span> (l &gt; <span class="number">0</span>) now[p][l - <span class="number">1</span>][dr] = max(now[p][l - <span class="number">1</span>][dr], pre[p][l][r] + a[<span class="number">0</span>][i]);</span><br><span class="line">					now[p + <span class="number">1</span>][K - <span class="number">1</span>][dr] = max(now[p + <span class="number">1</span>][K - <span class="number">1</span>][dr], pre[p][l][r] + a[<span class="number">0</span>][i]);</span><br><span class="line">					<span class="keyword">if</span> (r &gt; <span class="number">0</span>) now[p][dl][r - <span class="number">1</span>] = max(now[p][dl][r - <span class="number">1</span>], pre[p][l][r] + a[<span class="number">1</span>][i]);</span><br><span class="line">					now[p + <span class="number">1</span>][dl][K - <span class="number">1</span>] = max(now[p + <span class="number">1</span>][dl][K - <span class="number">1</span>], pre[p][l][r] + a[<span class="number">1</span>][i]);</span><br><span class="line">					<span class="keyword">if</span> (l &gt; <span class="number">0</span> &amp;&amp; r &gt; <span class="number">0</span>) now[p][l - <span class="number">1</span>][r - <span class="number">1</span>] = max(now[p][l - <span class="number">1</span>][r - <span class="number">1</span>], pre[p][l][r] + (a[<span class="number">0</span>][i] | a[<span class="number">1</span>][i]));</span><br><span class="line">					<span class="keyword">if</span> (r &gt; <span class="number">0</span>) now[p + <span class="number">1</span>][K - <span class="number">1</span>][r - <span class="number">1</span>] = max(now[p + <span class="number">1</span>][K - <span class="number">1</span>][r - <span class="number">1</span>], pre[p][l][r] + (a[<span class="number">0</span>][i] | a[<span class="number">1</span>][i]));</span><br><span class="line">					<span class="keyword">if</span> (l &gt; <span class="number">0</span>) now[p + <span class="number">1</span>][l - <span class="number">1</span>][K - <span class="number">1</span>] = max(now[p + <span class="number">1</span>][l - <span class="number">1</span>][K - <span class="number">1</span>], pre[p][l][r] + (a[<span class="number">0</span>][i] | a[<span class="number">1</span>][i])); </span><br><span class="line">					now[p + <span class="number">2</span>][K - <span class="number">1</span>][K - <span class="number">1</span>] = max(now[p + <span class="number">2</span>][K - <span class="number">1</span>][K - <span class="number">1</span>], pre[p][l][r] + (a[<span class="number">0</span>][i] | a[<span class="number">1</span>][i]));</span><br><span class="line">				&#125;</span><br><span class="line">	&#125; <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= P; p++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= K; l++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= K; r++)</span><br><span class="line">				ans = max(ans, f[n % <span class="number">2</span>][p][l][r]);</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1234F]Yet Another Substring Reverse</title>
    <url>/2019/12/19/%5BCF1234F%5DYet%20Another%20Substring%20Reverse/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>你可以将字符串的一个子串进行翻转，使得字符串中连续的不出现相同字符的长度最大</p>
<p>$字符集\leq 20$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>翻转相当于把两个不相交的子串合并，因为顺序没有影响（如ABC-&gt;ACB）</p>
<p>状态压缩，令$f_S$表示答案子串为S的最优解</p>
<p>令T为S的补集，可以发现</p>
<script type="math/tex; mode=display">
ans = max\{f_{A\in S} + f_{B\in T}\}</script><p>预处理Max即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], n, ans;</span><br><span class="line"><span class="keyword">char</span> str[maxn]; <span class="keyword">bool</span> vis[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, S = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) vis[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (vis[str[j] - <span class="string">'a'</span>]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				vis[str[j] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">				++cnt;</span><br><span class="line">				S |= (<span class="number">1</span> &lt;&lt; (str[j] - <span class="string">'a'</span>));</span><br><span class="line">				f[S] = max(f[S], cnt);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">			<span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) f[i] = max(f[i], f[i ^ (<span class="number">1</span> &lt;&lt; j)]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">20</span>); i++)</span><br><span class="line">		ans = max(ans, f[i] + f[((<span class="number">1</span> &lt;&lt; <span class="number">20</span>) - <span class="number">1</span>) ^ i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1238E]Keyboard Purchase</title>
    <url>/2019/12/19/%5BCF1238E%5DKeyboard%20Purchase/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定包含m种字符的字符串，找到一种键盘，使它是m个字符的一种排列</p>
<p>打完这段字符串，会在键盘上移动一些距离，求距离最小值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题不能用传统方式去看，因为前面字符的排列方式会影响后面的Dp，不得不退化到n!</p>
<p>最好的情况是令这m个字符在键盘上距离皆为1，令$f_S$为当前已经确定S中的字符</p>
<p>显然若一个字符已经确定，而另一个没有确认且没有在这次被确认，它们之间的距离会+1</p>
<p>得到转移</p>
<script type="math/tex; mode=display">
f_S=min\{f_{S-\{i\}}+c\}</script><h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], n, m, c[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> str[(<span class="keyword">int</span>)<span class="number">1e5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) c[str[i] - <span class="string">'a'</span>][str[i + <span class="number">1</span>] - <span class="string">'a'</span>]++, c[str[i + <span class="number">1</span>] - <span class="string">'a'</span>][str[i] - <span class="string">'a'</span>]++;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f); f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; m; k++)</span><br><span class="line">				<span class="keyword">if</span> ((i &gt;&gt; j &amp; <span class="number">1</span>) ^ (i &gt;&gt; k &amp; <span class="number">1</span>)) t += c[j][k];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) f[i] = min(f[i], f[i ^ (<span class="number">1</span> &lt;&lt; j)] + t);</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>idea</tag>
        <tag>动态规划Dp</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>[ARC073F]Many Moves</title>
    <url>/2019/12/19/%5BARC073F%5DMany%20Moves/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在编号为1~n的n个格子上有2个棋子，初始时在A和B</p>
<p>现给出$\{x_i\}$，需要一次将某个棋子移到x处，允许有棋子在同一个格子，求最小的移动距离和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令$f_j$表示前一步完成时除了在x处的棋子，另一个棋子在j的最小值</p>
<p>容易得到转移：</p>
<script type="math/tex; mode=display">
\begin{cases}
f_{i,j}=f_{i-1,j}+|x_i-x_{i-1}|\\
f_{i,x_{i-1}}=min\{min\{f_{i-1,j}+|j-x_i|\},f_{i-1,x_{i-1}}+|x_i-x_{i-1}|\}\\
\end{cases}</script><p>绝对值拆开，线段树维护区间$v-p,v+p$最小值即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>开始赋值的时候应该是$v_A=|x_1-B|$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		LL Minl, Minr, tg;</span><br><span class="line">	&#125;a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		a[cur].l = l, a[cur].r = r;</span><br><span class="line">		<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">			a[cur].Minl = INF;</span><br><span class="line">			a[cur].Minr = INF;</span><br><span class="line">			a[cur].tg = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		build(cur &lt;&lt; <span class="number">1</span>, l, mid); build(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">		a[cur].Minl = min(a[cur &lt;&lt; <span class="number">1</span>].Minl, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minl);</span><br><span class="line">		a[cur].Minr = min(a[cur &lt;&lt; <span class="number">1</span>].Minr, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].tg == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span>].tg += a[cur].tg;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span>].Minl += a[cur].tg;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span>].Minr += a[cur].tg; </span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tg += a[cur].tg;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minl += a[cur].tg;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minr += a[cur].tg;</span><br><span class="line">		a[cur].tg = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">Query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l == a[cur].r) <span class="keyword">return</span> a[cur].Minl + a[cur].l;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		<span class="keyword">int</span> mid = a[cur].l + a[cur].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> Query(cur &lt;&lt; <span class="number">1</span>, p);</span><br><span class="line">		<span class="keyword">return</span> Query(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">QMinl</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt; r || a[cur].r &lt; l) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt;= l &amp;&amp; a[cur].r &lt;= r) <span class="keyword">return</span> a[cur].Minl;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		<span class="keyword">return</span> min(QMinl(cur &lt;&lt; <span class="number">1</span>, l, r), QMinl(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">QMinr</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt; r || a[cur].r &lt; l) <span class="keyword">return</span> INF;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt;= l &amp;&amp; a[cur].r &lt;= r) <span class="keyword">return</span> a[cur].Minr;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		<span class="keyword">return</span> min(QMinr(cur &lt;&lt; <span class="number">1</span>, l, r), QMinr(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p, LL k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l == a[cur].r)&#123;</span><br><span class="line">			a[cur].Minl = min(a[cur].Minl, k - p);</span><br><span class="line">			a[cur].Minr = min(a[cur].Minr, k + p);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		<span class="keyword">int</span> mid = a[cur].l + a[cur].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) upd(cur &lt;&lt; <span class="number">1</span>, p, k);</span><br><span class="line">		<span class="keyword">else</span> upd(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, p, k);</span><br><span class="line">		a[cur].Minl = min(a[cur &lt;&lt; <span class="number">1</span>].Minl, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minl);</span><br><span class="line">		a[cur].Minr = min(a[cur &lt;&lt; <span class="number">1</span>].Minr, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Minr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">int</span> n, A, B, Q;</span><br><span class="line">LL x[maxn];</span><br><span class="line">LL _abs(LL x)&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;Q, &amp;A, &amp;B);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, x + i);</span><br><span class="line">	t.build(<span class="number">1</span>, <span class="number">1</span>, n); t.upd(<span class="number">1</span>, A, _abs(<span class="number">1l</span>l * B - x[<span class="number">1</span>])); t.upd(<span class="number">1</span>, B, _abs(<span class="number">1l</span>l * A - x[<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">		LL d = _abs(x[i] - x[i - <span class="number">1</span>]), tmp = t.Query(<span class="number">1</span>, x[i - <span class="number">1</span>]);</span><br><span class="line">		LL Minl = t.QMinl(<span class="number">1</span>, <span class="number">1</span>, x[i]);</span><br><span class="line">		LL Minr = t.QMinr(<span class="number">1</span>, x[i], n);</span><br><span class="line">		t.a[<span class="number">1</span>].Minl += d;</span><br><span class="line">		t.a[<span class="number">1</span>].Minr += d;</span><br><span class="line">		t.a[<span class="number">1</span>].tg += d;</span><br><span class="line">		t.upd(<span class="number">1</span>, x[i - <span class="number">1</span>], min(tmp + d, min(Minl + x[i], Minr - x[i])));</span><br><span class="line">	&#125; LL ans = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, t.Query(<span class="number">1</span>, i));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[AHOI2009]中国象棋</title>
    <url>/2019/12/15/%5BAHOI2009%5D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求在$n\cdot m​$的棋盘上摆放一些炮，使得任意两个炮不能互相攻击的方案数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于每一列，显然只能有0或1或2个炮，这是列中不能攻击的充要条件</p>
<p>令$f_{i,j,k}$为考虑前i行，其中有j列有1个炮，k列有两个炮的方案数，这也意味着有$m-i-j$列没有放棋子</p>
<p>分当前行放0或1或2个棋子讨论即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>不必维护行的信息，在转移的时候行就是满足条件的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">9999973</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn], n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1l</span>l * x * (x - <span class="number">1</span>) / <span class="number">2</span> % mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= m; k++)&#123;</span><br><span class="line">				f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">				<span class="keyword">if</span> (k &gt; <span class="number">0</span>) f[i][j][k] = (f[i][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * (j + <span class="number">1</span>) % mo) % mo;</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">0</span>) f[i][j][k] = (f[i][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * (m - j - k + <span class="number">1</span>) % mo) % mo;</span><br><span class="line">				<span class="keyword">if</span> (k &gt; <span class="number">1</span>) f[i][j][k] = (f[i][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j + <span class="number">2</span>][k - <span class="number">2</span>] * X(j + <span class="number">2</span>) % mo) % mo;</span><br><span class="line">				<span class="keyword">if</span> (k &gt; <span class="number">0</span>) f[i][j][k] = (f[i][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * j % mo * (m - j - k + <span class="number">1</span>) % mo) % mo;</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">1</span>) f[i][j][k] = (f[i][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j - <span class="number">2</span>][k] * X(m - j - k + <span class="number">2</span>) % mo) % mo;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= m; k++)</span><br><span class="line">			ans = (ans + f[n][j][k]) % mo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AHOI</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP2019]划分</title>
    <url>/2019/12/12/%5BNOIP2019%5D%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出$\{a_i\}$，求$\{p_k\}$，使得</p>
<script type="math/tex; mode=display">
\sum_{i=p_{k-2}+1}^{p_{k-1}} a_i \leq \sum_{i=p_{k-1}+1}^{p_k} a_i</script><p>求</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{K}(\sum_{i=p_{k-1}+1}^{p_k}a_i)^2</script><p>的最小值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先给出$\theta(n^3)​$Dp，令$f_{i,j}​$表示只考虑前i个数，前一个p=j的最小值</p>
<script type="math/tex; mode=display">
f_{i,j}=min_{s_i-s_j\geq s_j-s_k}\{f_{i,k}+(s_i-s_j)^2\}=min_{s_i-s_j\geq s_j-s_k}\{f_{i,k}\}+(s_i-s_j)^2</script><p>固定j，单调地取k，可以优化到$\theta(n^2)​$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL f[maxn][maxn], s[maxn], a[maxn];</span><br><span class="line"><span class="keyword">int</span> n, type;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;type);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = s[i] * s[i]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k = j; LL Min = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = j + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">while</span> (s[i] - s[j] &gt;= s[j] - s[k - <span class="number">1</span>] &amp;&amp; k &gt; <span class="number">0</span>) Min = min(Min, f[j][--k]);</span><br><span class="line">			f[i][j] = min(f[i][j], Min + (s[i] - s[j]) * (s[i] - s[j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = min(ans, f[n][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易证明，最后一部分越小越优，令$d_i$为以i结尾的最优方案时最后一段的大小</p>
<p>每次$f_i$自然是由满足$d_j\leq s_i-s_j$，即$d_j+s_j\leq s_i​$中最大的j转移而来（这个结论不大会证，但是举不出反例呵呵呵）</p>
<p>若$j&gt;k$，且$d_k+s_k&gt;d_j+s_j$，那么k就是无效的，维护关于$d_j+s_j$的单调队列即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL f[maxn], s[maxn], a[maxn], d[maxn];</span><br><span class="line"><span class="keyword">int</span> n, type, l, r, q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;type);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">	q[l = r = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; d[q[l + <span class="number">1</span>]] + s[q[l + <span class="number">1</span>]] &lt;= s[i]) ++l;</span><br><span class="line">		d[i] = s[i] - s[q[l]]; f[i] = f[q[l]] + d[i] * d[i];</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; d[q[r]] + s[q[r]] &gt;= d[i] + s[i]) --r;</span><br><span class="line">		q[++r] = i;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC022E]Median Replace</title>
    <url>/2019/12/11/%5BAGC022E%5DMedian%20Replace/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于长度为奇数的01?字符串，可以将连续3个字符用中位数代替，问使得最后可以变为1的方案数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>手动建自动机，表示字符串的替代转移</p>
<p>可以发现替换掉的0越多越好，所以可以贪心地转移，自动机节点数有限</p>
<p><strong>注意，在建立自动机的时候，有些节点（如2，5）要用后两个字符再去匹配，有可能它们和后面的字符消去，形成更优的解</strong></p>
<p>自动机的样子盗张图</p>
<p><img src="https://i.loli.net/2018/07/11/5b4603963b498.png" alt=""></p>
<p>倒序Dp即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> to[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">8</span>], n; <span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">	f[n + <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>, f[n + <span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] != <span class="string">'0'</span>) f[i][j] += f[i + <span class="number">1</span>][to[j][<span class="number">1</span>]];</span><br><span class="line">			<span class="keyword">if</span> (str[i] != <span class="string">'1'</span>) f[i][j] += f[i + <span class="number">1</span>][to[j][<span class="number">0</span>]];</span><br><span class="line">			f[i][j] %= mo;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：<a href="https://blog.csdn.net/ShadyPi/article/details/81007277" target="_blank" rel="noopener">link</a></p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]可持久化线段树（主席树）</title>
    <url>/2019/12/11/%5B%E6%A8%A1%E6%9D%BF%5D%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求静态区间第k小</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>离散化一下，然后先建原树，依次插入$a_i$形成n个版本</p>
<p>每次询问时在r和l-1两个版本里同时查询即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS(cur) a[a[cur].ls]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS(cur) a[a[cur].rs]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> l, r, ls, rs, v;</span><br><span class="line">	&#125;a[maxn * <span class="number">40</span>]; <span class="keyword">int</span> tot;</span><br><span class="line">	T()&#123;tot = <span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		a[cur].l = l, a[cur].r = r;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		build(a[cur].ls = ++tot, l, mid);</span><br><span class="line">		build(a[cur].rs = ++tot, mid + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = a[t].l + a[t].r &gt;&gt; <span class="number">1</span>, cur;</span><br><span class="line">		a[cur = ++tot] = a[t];</span><br><span class="line">		a[cur].v++;</span><br><span class="line">		<span class="keyword">if</span> (a[t].l == a[t].r) <span class="keyword">return</span> cur;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) a[cur].ls = upd(a[t].ls, p);</span><br><span class="line">		<span class="keyword">else</span> a[cur].rs = upd(a[t].rs, p);</span><br><span class="line">		a[cur].v = LS(cur).v + RS(cur).v;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[u].l == a[u].r) <span class="keyword">return</span> a[u].l;</span><br><span class="line">		<span class="keyword">if</span> (LS(v).v - LS(u).v &gt;= k) <span class="keyword">return</span> Query(a[u].ls, a[v].ls, k);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> Query(a[u].rs, a[v].rs, k - (LS(v).v - LS(u).v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t; <span class="keyword">int</span> n, Q, a[maxn], tt[maxn], link[maxn], rt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i), tt[i] = a[i];</span><br><span class="line">	sort(tt + <span class="number">1</span>, tt + n + <span class="number">1</span>); t.build(<span class="number">1</span>, <span class="number">1</span>, n); rt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = lower_bound(tt + <span class="number">1</span>, tt + n + <span class="number">1</span>, a[i]) - tt;</span><br><span class="line">		link[tmp] = a[i];</span><br><span class="line">		a[i] = tmp;</span><br><span class="line">		rt[i] = t.upd(rt[i - <span class="number">1</span>], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, link[t.Query(rt[l - <span class="number">1</span>], rt[r], k)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>可持久化</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF708E]Student's Camp</title>
    <url>/2019/12/09/%5BCF708E%5DStudent&#39;s%20Camp/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$(n+2)\cdot m$的矩阵，第2~n+1行最左的砖块和最右的砖块分别在白天和晚上有$P=\frac{A}{B}$的概率被毁</p>
<p>暴风雨持续了k天k夜，问k天之后整个矩阵仍然联通（共边）的概率，对1e9+7取模</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>令$f_{T,l,r}$为第T行剩下l~r的砖块且上方全部联通的概率，$p_i$为第i块砖恰好留下的概率</p>
<p>得到一个naive的递推式</p>
<script type="math/tex; mode=display">
f_{T,l,r}=p_l\cdot p_{m-r}\cdot \sum_{[x,y]与[l,r]有交}f_{T-1,x,y}</script><p>用前缀和优化， 令$sf_{T,j}=\sum_{1\leq i\leq j}f_{T,i,j}$，$ssf_{T,j}=\sum_{1\leq i\leq j}sf_{T,i}$</p>
<p>则</p>
<script type="math/tex; mode=display">
f_{T,l,r}=p_l\cdot p_{m-r}\cdot(\sum_{1\leq i\leq j\leq m}f_{T-1,i,j}-\sum_{1\leq i\leq j\leq l-1}f_{T-1,i,j}-\sum_{r+1\leq i\leq j\leq m})</script><p>利用对称性翻转区间，$f_{T,x,y}=f_{T,m-y+1,m-x+1}$</p>
<script type="math/tex; mode=display">
f_{T,l,r}=p_l\cdot p_{m-r}\cdot(\sum_{1\leq i\leq j\leq m}f_{T-1,i,j}-\sum_{1\leq i\leq j\leq l-1}f_{T-1,i,j}-\sum_{1\leq i\leq j\leq m-r})</script><script type="math/tex; mode=display">
=p_l\cdot p_{m-r}\cdot (ssf_{T-1,m} - ssf_{T-1,l-1} - ssf_{T-1,m-r})</script><p>又可以发现</p>
<script type="math/tex; mode=display">
sf_{T,j}=\sum_{1\leq i\leq j}f_{T,i,j}=(\sum_{1\leq i\leq j}p_l)\cdot p_{m-j}(ssf_{T-1,m}-ssf_{T-1,m-j})-p_{m-j}\cdot \sum_{1\leq i\leq j}p_i\cdot ssf_{T-1,i-1}</script><p>直接维护sf和ssf就做完了 $\theta(n\cdot m)$</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>初始化的时候fac和inv求得不够，应该求到k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1505</span>;</span><br><span class="line"><span class="keyword">const</span> LL mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x, LL t)</span></span>&#123;</span><br><span class="line">    x %= mo; LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % mo;</span><br><span class="line">        x = <span class="number">1l</span>l * x * x % mo;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, A, B;</span><br><span class="line">LL P, p[maxn], sp[maxn], fac[maxn * <span class="number">100</span>], inv[maxn * <span class="number">100</span>];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mo * inv[n - m] % mo;</span><br><span class="line">&#125;</span><br><span class="line">LL sf[maxn][maxn], ssf[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;n, &amp;m, &amp;A, &amp;B, &amp;k);</span><br><span class="line">    P = <span class="number">1l</span>l * A * <span class="built_in">pow</span>(B, mo - <span class="number">2</span>) % mo; fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mo;</span><br><span class="line">    inv[k] = <span class="built_in">pow</span>(fac[k], mo - <span class="number">2</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = <span class="number">1l</span>l * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mo;</span><br><span class="line"><span class="comment">//    printf("::%lld\n", C(5, 2));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) p[j] = <span class="number">1l</span>l * <span class="built_in">pow</span>(P, j) * <span class="built_in">pow</span>(<span class="number">1</span> + mo - P, k - j) % mo * C(k, j) % mo;</span><br><span class="line">    sp[<span class="number">0</span>] = p[<span class="number">0</span>]; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) sp[j] = (sp[j - <span class="number">1</span>] + p[j]) % mo;</span><br><span class="line">    sf[<span class="number">0</span>][m] = ssf[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T &lt;= n; T++)&#123;</span><br><span class="line">        <span class="keyword">int</span> S = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            S = (S + <span class="number">1l</span>l * ssf[T - <span class="number">1</span>][j - <span class="number">1</span>] * p[j - <span class="number">1</span>] % mo) % mo;</span><br><span class="line">            sf[T][j] = (sf[T][j] + mo + <span class="number">1l</span>l * sp[j - <span class="number">1</span>] * p[m - j] % mo * (ssf[T - <span class="number">1</span>][m] - ssf[T - <span class="number">1</span>][m - j]) % mo) % mo;</span><br><span class="line">            sf[T][j] = (sf[T][j] + mo - <span class="number">1l</span>l * S * p[m - j] % mo) % mo;</span><br><span class="line">            ssf[T][j] = (ssf[T][j - <span class="number">1</span>] + sf[T][j]) % mo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ssf[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2012]永无乡</title>
    <url>/2019/12/08/%5BHNOI2012%5D%E6%B0%B8%E6%97%A0%E4%B9%A1/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于一些点，支持连边和求联通块中第k重要的点</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>动态开点权值线段树，线段树上合并</p>
<p>询问的时候二分即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS a[a[cur].ls]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS a[a[cur].rs]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> ls, rs, v, l, r;</span><br><span class="line">	&#125;a[maxn * <span class="number">40</span>];</span><br><span class="line">	<span class="keyword">int</span> rt[maxn], tot;</span><br><span class="line">	T()&#123;tot = <span class="number">0</span>;&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">		a[cur].l = l, a[cur].r = r;</span><br><span class="line">		<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">			a[cur].v = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!a[cur].ls) a[cur].ls = ++tot;</span><br><span class="line">			upd(a[cur].ls, l, mid, p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!a[cur].rs) a[cur].rs = ++tot;</span><br><span class="line">			upd(a[cur].rs, mid + <span class="number">1</span>, r, p);</span><br><span class="line">		&#125;</span><br><span class="line">		a[cur].v = LS.v + RS.v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cur || !v) <span class="keyword">return</span> cur | v;</span><br><span class="line">		a[cur].ls = Merge(a[cur].ls, a[v].ls);</span><br><span class="line">		a[cur].rs = Merge(a[cur].rs, a[v].rs);</span><br><span class="line">		a[cur].v += a[v].v;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l == a[cur].r) <span class="keyword">return</span> a[cur].l;</span><br><span class="line">		<span class="keyword">if</span> (k &lt;= LS.v) <span class="keyword">return</span> Query(a[cur].ls, k);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> Query(a[cur].rs, k - LS.v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == f[x] ? x : f[x] = getf(f[x]);&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, p[maxn], link[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">		t.rt[i] = ++t.tot; f[i] = i;</span><br><span class="line">		t.upd(t.rt[i], <span class="number">1</span>, n, p[i]);</span><br><span class="line">		link[p[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="keyword">int</span> fu = getf(u), fv = getf(v);</span><br><span class="line">		t.Merge(t.rt[fu], t.rt[fv]);</span><br><span class="line">		f[fv] = fu;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">char</span> opt[<span class="number">2</span>]; <span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">			<span class="keyword">int</span> fu = getf(u), fv = getf(v);</span><br><span class="line">			t.Merge(t.rt[fu], t.rt[fv]); f[fv] = fu;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'Q'</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">			<span class="keyword">if</span> (v &gt; t.a[t.rt[getf(u)]].v) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, link[t.Query(t.rt[getf(u)], v)]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HNOI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>动态开点</tag>
        <tag>线段树合并</tag>
        <tag>线段树二分</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC023D]go home</title>
    <url>/2019/12/06/%5BAGC023D%5Dgo%20home/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>数轴的整点上有一些人，一辆公交车从S开始载上并送这些人回家，方向取决于车上人的投票</p>
<p>所有的人都会让自己回家的时间最小，求公交车送完所有人的时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>不一定所有人都往自己的方向投票</strong></p>
<p>如果最左边的人小于最右边的人，那么不管怎样公交车都先到最右边，再到最左边（即左边的人一开始投右边）</p>
<p>直接合并，统计答案</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>p爆long long</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, x[maxn], dire;</span><br><span class="line">LL ans = <span class="number">0</span>, p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, x + i, p + i);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x[l] &gt;= s)&#123;</span><br><span class="line">            ans += <span class="number">1l</span>l * (x[r] - s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x[r] &lt;= s)&#123;</span><br><span class="line">            ans += <span class="number">1l</span>l * (s - x[l]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[l] &lt; p[r])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dire != <span class="number">1</span>) dire = <span class="number">1</span>, ans += <span class="number">1l</span>l * (x[r] - x[l]);</span><br><span class="line">            p[r] += p[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[l] &gt;= p[r])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dire != <span class="number">-1</span>) dire = <span class="number">-1</span>, ans += <span class="number">1l</span>l * (x[r] - x[l]);</span><br><span class="line">            p[l] += p[r--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC023F]01 on tree</title>
    <url>/2019/12/06/%5BAGC023F%5D01%20on%20tree/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵权值为01的树，找到一个拓扑序列，使得权值序列中逆序对对数最少</p>
<p>求最小值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑两个拓扑序的合并，令$a_1,b_1,a_2,b_2$分别为序列1,2中01的个数</p>
<p>当$b_1\cdot a_2\leq a_1\cdot b_2$即$\frac{b_1}{a_1}\leq\frac{b_2}{a_2}$时，序列1在前面更优</p>
<p>满足排序性质，用堆维护</p>
<p>每次找最小的序列和父亲的序列合并一定最优，局部最优必定导致全局最优</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>1不能再合并，不要加进去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == f[x] ? x : f[x] = getf(f[x]);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b, id;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(A x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1l</span>l * b * x.a &gt; <span class="number">1l</span>l * a * x.b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(A x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a != x.a || b != x.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn]; LL ans = <span class="number">0</span>;</span><br><span class="line">priority_queue &lt;A&gt; q;</span><br><span class="line"><span class="keyword">int</span> n, anc[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, anc + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> val, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">		f[i] = i;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="number">0</span>) a[i] = (A)&#123;<span class="number">1</span>, <span class="number">0</span>, i&#125;;</span><br><span class="line">		<span class="keyword">else</span> a[i] = (A)&#123;<span class="number">0</span>, <span class="number">1</span>, i&#125;;</span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">1</span>) q.push(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		A t = q.top(); q.pop();</span><br><span class="line">		<span class="keyword">int</span> cur = getf(t.id);</span><br><span class="line">		<span class="keyword">if</span> (a[cur] != t) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> fa = getf(anc[cur]);</span><br><span class="line">		ans += <span class="number">1l</span>l * a[fa].b * a[cur].a;</span><br><span class="line">		a[fa].a += a[cur].a;</span><br><span class="line">		a[fa].b += a[cur].b;</span><br><span class="line">		f[getf(cur)] = f[getf(fa)];</span><br><span class="line">		<span class="keyword">if</span> (fa != <span class="number">1</span>) q.push(a[fa]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>[ZJOI2019]语言</title>
    <url>/2019/12/05/%5BZJOI2019%5D%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵无根树和树上的若干条链</p>
<p>求无序点对数，使得这两个点不重合且它们之间的路径至少被一条链包含</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>特别暴力的做法，对于每个节点开一棵权值线段树，统计权值不为0的个数</p>
<p>对于一条链，分别在$u$，$v$，$f_{lca(u,v)}$打1,1,-2标记，自底向上线段树合并即可</p>
<p>线段树动态开点+标记永久化，因为每个区间如果被加上一定会被减去</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>线段树中当前节点的区间若被操作区间覆盖，修改Min时也要修改tg</p>
<p>-2要打在lca的父亲上<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS a[a[cur].ls]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS a[a[cur].rs]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, Min, tg, ls, rs;</span><br><span class="line">    &#125;a[maxn * <span class="number">400</span>];</span><br><span class="line">    <span class="keyword">int</span> rt[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[cur].l &gt; r || a[cur].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[cur].l &gt;= l &amp;&amp; a[cur].r &lt;= r)&#123;</span><br><span class="line">            a[cur].Min += k;</span><br><span class="line">            a[cur].tg = (a[cur].Min &gt; <span class="number">0</span>) ? a[cur].r - a[cur].l + <span class="number">1</span> : LS.tg + RS.tg;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">int</span> M = a[cur].l + a[cur].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!a[cur].ls &amp;&amp; M &gt;= l)&#123;</span><br><span class="line">            a[++tot].l = a[cur].l; a[tot].r = M;</span><br><span class="line">            a[cur].ls = tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[cur].rs &amp;&amp; M &lt; r)&#123;</span><br><span class="line">            a[++tot].l = M + <span class="number">1</span>; a[tot].r = a[cur].r;</span><br><span class="line">            a[cur].rs = tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[cur].ls) upd(a[cur].ls, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (a[cur].rs) upd(a[cur].rs, l, r, k);</span><br><span class="line">        a[cur].tg = (a[cur].Min &gt; <span class="number">0</span>) ? a[cur].r - a[cur].l + <span class="number">1</span> : LS.tg + RS.tg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> cur;</span><br><span class="line">        a[cur].Min += a[v].Min;</span><br><span class="line">        <span class="keyword">if</span> (a[cur].l != a[cur].r)</span><br><span class="line">        a[cur].ls = Merge(a[cur].ls, a[v].ls),</span><br><span class="line">        a[cur].rs = Merge(a[cur].rs, a[v].rs);</span><br><span class="line">        a[cur].tg = (a[cur].Min &gt; <span class="number">0</span>) ? a[cur].r - a[cur].l + <span class="number">1</span> : LS.tg + RS.tg;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t; </span><br><span class="line"><span class="keyword">int</span> dep[maxn], f[maxn], sz[maxn], son[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[cur] = dep[fa] + <span class="number">1</span>; f[cur] = fa; sz[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != fa)&#123;</span><br><span class="line">            dfs1(v, cur);</span><br><span class="line">            <span class="keyword">if</span> (sz[v] &gt; sz[son[cur]]) son[cur] = v;</span><br><span class="line">            sz[cur] += sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[maxn], tdx = <span class="number">0</span>, top[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> topf)</span></span>&#123;</span><br><span class="line">    top[cur] = topf; id[cur] = ++tdx;</span><br><span class="line">    <span class="keyword">if</span> (!son[cur]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[cur], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f[cur] &amp;&amp; e[i].to != son[cur]) dfs2(e[i].to, e[i].to);</span><br><span class="line">&#125; LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">U</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">    U(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>)&#123;</span><br><span class="line">        l = a; r = b; k = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="built_in">vector</span> &lt;U&gt; vec[maxn];</span><br><span class="line"><span class="keyword">int</span> n, Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, cur); t.rt[cur] = t.Merge(t.rt[cur], t.rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[cur].size(); j++)&#123;</span><br><span class="line">        t.upd(t.rt[cur], vec[cur][j].l, vec[cur][j].r, vec[cur][j].k);</span><br><span class="line"><span class="comment">//        printf("::%d %d %d\n", vec[cur][j].l, vec[cur][j].r, vec[cur][j].k);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (cur == 5) printf("%d\n", t.a[t.rt[cur]].tg);</span></span><br><span class="line">    ans += t.a[t.rt[cur]].tg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;U&gt; tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    tmp.clear();</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) swap(u, v);</span><br><span class="line">        tmp.push_back((U)&#123;id[top[v]], id[v], <span class="number">0</span>&#125;);</span><br><span class="line">        v = f[top[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    tmp.push_back((U)&#123;id[u], id[v], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addedge(u, v); addedge(v, u);</span><br><span class="line">    &#125; dfs1(<span class="number">1</span>, <span class="number">0</span>); dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t.rt[i] = i, t.a[i].l = <span class="number">1</span>, t.a[i].r = n;</span><br><span class="line">        vec[i].push_back((U)&#123;id[i], id[i], <span class="number">1</span>&#125;);</span><br><span class="line">        vec[f[i]].push_back((U)&#123;id[i], id[i], <span class="number">-1</span>&#125;);</span><br><span class="line">    &#125; tot = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">int</span> t = split(u, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp.size(); j++)&#123;</span><br><span class="line">            vec[u].push_back((U)&#123;tmp[j].l, tmp[j].r, <span class="number">1</span>&#125;);</span><br><span class="line">            vec[v].push_back((U)&#123;tmp[j].l, tmp[j].r, <span class="number">1</span>&#125;);</span><br><span class="line">            vec[f[t]].push_back((U)&#123;tmp[j].l, tmp[j].r, <span class="number">-2</span>&#125;);</span><br><span class="line"><span class="comment">//            printf("::%d %d\n", tmp[j].l, tmp[j].r);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans - n) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ZJOI</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP2019]Emiya家今天的饭</title>
    <url>/2019/11/22/%5BNOIP2019%5DEmiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出$n\cdot m$的矩阵，从中选出任意个数$(\geq 0)$的元素，使得每行最多只有1个，且每列的个数不超过总数的一半</p>
<p>求所有方案中元素的乘积的和，对$998244353$取模</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，合法的方案数等于所有方案减去不满足的方案数</p>
<p>对于不满足的情况，一定<strong>有且仅有</strong>一列的选择个数超过一半</p>
<p>若选了$x$道菜，其中某种食材用了$y$，条件变形一下得到：$2y+n-x\geq n$</p>
<p>枚举超过一半的那一列，令$f[j][k]$表示有j行取了数，目前$2y+n-x$为k的方案数</p>
<p>分为当前行不选；当前行选，不选选定的列；选当前行，选选定的列 进行Dp即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">105</span>][maxn], s[<span class="number">105</span>];</span><br><span class="line">LL ans = <span class="number">1</span>, f[<span class="number">105</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, a[i] + j); s[i] = (s[i] + a[i][j]) % mo;</span><br><span class="line">			<span class="keyword">if</span> (j == m) ans = <span class="number">1l</span>l * ans * (s[i] + <span class="number">1</span>) % mo;</span><br><span class="line">		&#125; ans--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f); f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= (n &lt;&lt; <span class="number">1</span>); k++)&#123;</span><br><span class="line">				f[j][k] = (f[j][k] + <span class="number">1l</span>l * f[j - <span class="number">1</span>][k] * (s[j] + mo - a[j][i]) % mo) % mo;</span><br><span class="line">				f[j][k + <span class="number">1</span>] = (f[j][k + <span class="number">1</span>] + f[j - <span class="number">1</span>][k]) % mo;</span><br><span class="line">				f[j][k + <span class="number">2</span>] = (f[j][k + <span class="number">2</span>] + <span class="number">1l</span>l * f[j - <span class="number">1</span>][k] * a[j][i] % mo) % mo;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n + <span class="number">1</span>; j &lt;= (n &lt;&lt; <span class="number">1</span>); j++) ans = (ans + mo - f[n][j]) % mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[Artical]NOIP2019考后总结</title>
    <url>/2019/11/21/%5BArtical%5DNoip2019%E8%80%83%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="98ffbf1662ba672fedde8ed2018e5c2fbb8bd3b3f3235a5829edfb0471ffc64f">aba5c7bcecb0e845494faab52ce2974a258b00f2a0905022f77e97008d2305c814e07851c06596df751d30371e46a840571759a48fc2cf1530f10f6554e3f8caa5b2c1095e89af71b2f188a6424ba1a2c82dcc6f4dfc2f30d94c343012e236b14ad12cc9fb0ea026283490c3422a8ecdfea93241d6a16b0bd8f0c126665d52743152bd621d8c1825e03c9281214bab0df7a11716accbc7d34388046e8494922a43b5516a482df51062eda763ea787171051be70951251c90e54dabe2aba81db4eefaa3068ebec7ef71cff7ff3cc23c3e3086b63536d39b813b448a0ba74f43aca4db537fe89ef9400bb6b01cbc15a042aec01a8f88a2f89476afc2e2012248cab9f1c3f7f8918bf2e500ef868078e03c30a6ccafa56c5f8a6f797e347940f06eba18ac9cebbb111763606ee2df6e3a60eb0581d15376f91136cb2ef3e659b9b99f5a83cf9aa4435fc8ee01cc4c341062caa64e4c8c41d16ea6ce562b681db84b779cc413c1166e5cb58a781273a5ea46a9dc50636f88e16b44ed839dce335a575b56d0353b65bc14f8ca45a77a2bb6e4a3bfe1375b06c6d2a966530efcd5ccd838fbc945e6bc63ba74197461fb205e516fea96df33ecfdd0a61b09dd565cfd1b55b46abee78d9c7c6f4ceb03733863a28694453caf3d81f2994f2642310aa615d7e3725fa463e3af4e44fd086c7da7107fb4ab934a3a0fdb232226f52843d11e5f750b8da97398d8691afc98b58362ba8bf536333b4887d31a8f0e83cf204485b714eb40abda61b79f1a71bcecf5ea2cee2f8eca8080a07e0099daa7792ba11b1d2d1e1c6a97c0a229444dc208d42559d11ebde97ae186fcc5279cb27abb39176912c6b83beff365d6432abe4986a76a282b0ef4c865632123bc4de143914c7d8ec7ed43fd8eecfb0f3ea15d544dccab5715f25a0ff65b5a2c3dc995b0aa5fa89a8cc7f34ef1409655e4f0781b78c842777eb43e7862b122ac646f6c6d399ccac5bb9fe9840479c54ea38809704abbfd9ca372816bc56d5d1b15ffec538a452ed0309dd93016ae98890fb005b67bd1f1b5f344ff7e740c7c53454989358eecf3ae237002452fc7dffdd8dde392f1c1858d82a1380d12b4dde7a8a0fa769b3549f93faa8e3759b229b553f328c4ac38f9b7de5482a6faf4502260d39a478afc2b5377f276c7a0a55d65238059ea84867ce015e456363120b1b0ad0fc6453ca5225852d67d3009b0e8c0ca8677f94cbf3f2304ad3f9a08115c562055a47d2fa9b904b20c6961f4798eec96aa0c5a6bbedb7a9c341a96d7fb82fb6073a19a9d95d85da97ceecb9381c14c1fc9537d70ed007a838345a5782020090747061609cc2c7d82cb10e70e0903bd9b3328a728ea037aa3a90a7b105efbc44173dadf7ed259a0cdfde09a8cbd8a610506aece9da5c390104cb1be1a5adf628aa16d940498287fcf7dc74e08db57dfb78b71c9980c501c48e2f4caec25b8ae1aebca3dd8de14d62642e91a0f4c4c8469ad8b5bee3a44bc27a78214cdfc239bb05ded8db6d962b6156fa45912e8794b9e9c34e6969a2283c067c78cf0fe53a7c6651316c930ab7a8da1097e9353eb9a7bef41c0b2b0d245afd8a3f2f3fd862175da7409b6793b84a7c12e2adbb8684af5bb6c627af090cad77e3d3b531bce21a4501b424026a3e0a594b7bcfc00c6e523f9c958d602e9903b0603f0db2f5d22d61645a494f6017b95733c6eca110019ef049daf7ce6e33aa2f3132591b7931db51b168da5486d6ad80e4277a3f739835ebe4ef73a42198db0050df58cee889e282419baf975c16efd99fbf0fe3194fd92ca493048477dad5dbfd1dfebe11362d7fda0634637598ad6caa35d22b76ead698c35b34a9017d68e7d4d899b42e09d7327eaeec975c5f7bc33f4351e38c42a796eae4008834c870eedba64302ada21dab58e1af748bb266ebc8ec31ab1ddd85b33a91436d77190f71493fb63d647b1ae543bd3660ca6c798759cd87b0d3b4acd834fbb348afada31e575fc250a5c9cbbd7c7963279f7b26d60b8469d419d0733303a353067162ef683ed1f5fbaba4f3fba73cb204a6b9a113524056f17e86ca6473d540f632d1d51cba4f7f64e8dda40bf9cf556850a345316461e10fa21640a2858e98fe022fbbefdbec7017a226752617f976b95b9d5b1a97a11fc0de17957c7e76b9ba36b113cf02af3b1619e8f8005428da5f14ad9a64b81f10e924855b5eeaadd1eb907cf3a8a00c5719103683f4ee697d32228f3654fb450cbb0e368b8b8af6b23acdf6ed2e6abecb3369abc4d75d2555e0b1b89d805d394607db4a627aaaf49a3b7ec70fcfb5d7bbbdc286bd3865e8f65faf659cc5d6a0f6b9998cd59f71f6017ec0700055320edb52011d7d707c11c8ca1fb8bea1fb0f122b746812f12f3347eff6eee97f185d1682acaa8a44bdb100080eb3b70e78f3d44903d98f2e87b674ef7938f7740c9b260114a39fdc712b17ad523ca767d7a7ce0439c21d4efd7908f20cb1a24fae9d8b1272c2bbbbd93747ee3ad914307e388fc5e47a6301f098be9da6ac098e8618d4b514ccf943045b70ceb9668ab3eab9905930fe6a677b194f50a88ee9b64174c23ea213d5ae05ee94d86c2a4850197518734723ab24d825d638abb849ddccc90e9e8ef5b38f9eca5897e7f1bfcd0c44e9ee53ed4ff5902570604b8b7a59920ff490ae3cdf0d93bf12c7493055219f2d70e4c9517b92958f1fbb154de1ca22dd4178c5bd3b11e28c2fd6abf93dbbfb64807273b78a1959b646b778f9e847fd7cb7c18d731074a36d1ff888a6f00d075283076a68b97200c94f243640b8ba1d77687a81312c2c189163519fb0a72dcc896bea747a2e0b3db9d345795414a32e1c4a0e89a39a3881f6bcbc6a94a4d52c6581e21fd992e190c69cf67bb8feaa9e6c5d5de066e93570a5b1c01192eb0ec99f471a093a4891808243cac86acc96740d5805bae9920a0e91dcb4c41fcbca03316e4d77598e58c923b2e7a00ae41a53898c9399a5bd75596fa84a94ebfa8a1a9381e28c330dc958f889f5802426a50a0a10f604faea5ebd04d567ee2d2cae78af46bd0ece802458c50aff2ee1c5f15f227567626f371216c3f8967a4a546337f64ff2c7f7b836bee9eb095b244a3981c102209fd491c782e776de0b617513ce95e1c5f3d88ab7c076e39e6d2fec6ae94f14aec26da674713cbd996d00121ae587151e9e36aa4267b57a97ee610a29b9ee01ef45d41675f72bf73587c090a75057d3116b3d7e58cab32a1a8ce3c49f987276bd7b363d2a5b24180990ae1aa096339329d9ddb87a275dd9c12be64d9a07389fd6b9769a969be41292c9efb33bbc4bda6a93a3b708107f3bd5896011b5c4a1ce1b49657d2285e312980677d7d4ed11aacfdb3dad4816fba8a36d3c5439417734620d40e080abe205daa2fc3b6ea7b0ea1878d71a012f89e9d9828164b3c7dfccc9001050f37af31e556e66b1f01aa03069569fd6d9dcc0104e265f9099b30240ddbdec8190b84dad28bfd27d9ee6a41362476bf6c6c311812eed1a0d8e6dfb670365a0107223b7b8c4a495f3aa074dc6de177ff27f22d2fd579a8eca395a3323eac03d8a3f68f6776c2a6d99f089fc9305875cb017e8bb12b73a9beba367e25d5692febee9d662fa17dfa4e63263416119b6e2672da96d5fd9a531e96ecb34cc355522f9053b31402d4fb457a32a59f2211b5712b9c11ec70cb02393dc55cd92b6ed8bfaa439fa17d27799fbbe6c3d3094aa4b1ff82fea2fe7304ef0ece1d1a694c59912a55730f5a902a6ee2729b142ee109dc0291db20e8ff2e1af3bae9c4619e23bd078405245339c3a27a0123899fb45fa0167d4512634314a98bbeaed5d5475fe15eb0be5f6619f2f4405c0f210d45a1d01ccabced6e623a81e6fad5a1ab1c5bdc17139c7d432a483149bcbb8a47c11c5f6acfd9032df548655343031b1e770bb45dfa003b7002351ede29d7b19b7f0b243da9178ad42d610fbd8ad1570ea78af74d7657fe0b8f9092d8adb7266669f085de8000f1c76dd53e0895eca6bc1bc8c8aa864fd075609459722273b516aa06b015a89a37cf0b913e3a5fa8823e3e7fde6187f0ecf901ecbad27d05df62012d6f45692feb23f02d7af9ac446f848affa5849cafef53d740e7872a3d9fafeb2d5c7e2561367d9b832e8b8f7391690f33913a81cd1c49b58016e4220c0ffd2ed73e9dff1cac2f359d6c5287e64c534384ef25738d9cf6931012b35b944b5662616ac335540c2a581f22f2d617a415096529564238e7dd8fae4b015bcfc6ab1e1c21860f74b27b27e2b00103a735819f4f379b5cf5d5bd124b2e3d9cf1fb8459e80ed6feeaee2e010dd45f8c9a0cc4b21d62fe8a3d8b13dd4fe79eef42caf951b449b15e0eee01822794a2ad5c7da170dd88ea4cc52c0a53744223b82a806e4cf170598c94b17ab54ce14d1ef30e70d4689896e8e4184aba0f5d16e772f5c931554b27fdde618ddf4acbe0bc570ab820fdc4d049b106fb78b24fc80e846d5245bb51752d2ac735f88b3ccdd1dd3dd0e1a27d834237abd983af13252aa13e773cb089a3470320250147a649acf970618bd29a64e0eb50bf449d98afcd845904e6c4c9bea9d4ad9fa6d61208c00d85a2721b6fa76cc619b06274ced2f8c7fac4fb18430ac244f993d4591aa20894b850d50a67e3c52a70869788dda171e7358f8956e94f2a9573166fcdb9a4b9d92d97db6fbde905fbc02ccb1d5f78de8f93b685d093c710f1d594e8ca1a93f6dfae47dc6d6faf017d393129ac2e1f9521cac57e3d56f9c1cd194ac6af38d8878bf32782871ba16428c350eb17294503107eed5bda4656573e8626ae43cff0be32bd246c423fe4838c1081dae9ab7bb8fe27778b7bd0ff06c2301c81a4fe36df79ba5175eeeb8f08a225b2c8995765c2e7679d4a65e71a4457d0e3cc2e718c6e7b19e71f1d5fa6546d49123ddbb4dd48be434c834910fec6c5646066e55d85d4555a395b43b1628982e907aa3d09ce9c293cfe0ed10191bb87a2feccf3ea5c23aa52994f36602cc5997fb3d5587b8048bdcaa6f1109d23587cf80c9fc229845a36a644d42cc92195846e985f71fbe676d30883a1b2fb853f896b6d11e4eefa4493f2eea7ce48ca4c9a34715f5cf27229ca7ba60f73c6b9a89526c309d42eff00bbe81b03f09c055cf797b1cada29662f0d41112e2e159b96d245675e1700f6f11ef2d3ef2c37950a91be398c046c87aa1e782b35c7a2f464ae6488d8fc340d47e3027204ca65617bcf0d716758c0cac36c8ac8ee3a9c147b0625c7c500</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Artical</category>
      </categories>
      <tags>
        <tag>Artical</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP2019]括号树</title>
    <url>/2019/11/21/%5BNOIP2019%5D%E6%8B%AC%E5%8F%B7%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一棵以$1$为根的树中，每个节点都有一个左括号或者右括号</p>
<p>令$F(x)$为从$1$到$x$的路径上组成的括号串中合法的连续子串的数量</p>
<p>求$ans=\oplus_{x=1}^n x\cdot F(x)$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先考虑对于一个字符串如何计算，令f为以当前位为结尾的合法串个数，整个串的总数即为f的求和</p>
<p>dfs顺便用栈维护即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>前缀和要在进入下一层前处理好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn], f[maxn], sum[maxn];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s; LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str[cur] == <span class="string">'('</span>) s.push(cur);</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (str[cur] == <span class="string">')'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!s.empty())&#123;</span><br><span class="line">			f[cur] = f[fa[s.top()]] + <span class="number">1</span>;</span><br><span class="line">			tmp = s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; 	sum[cur] = f[cur] + sum[fa[cur]];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (str[cur] == <span class="string">'('</span> &amp;&amp; !s.empty()) s.pop(); </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tmp != <span class="number">-1</span>) s.push(tmp);</span><br><span class="line">	ans ^= (<span class="number">1l</span>l * cur * sum[cur]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, str + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, fa + i);</span><br><span class="line">		addedge(fa[i], i);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF852E]Casinos and travel</title>
    <url>/2019/11/15/%5BCF852E%5DCasinos%20and%20travel/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵树，定义$f(t)$为以t为根，从根到叶子节点的所有链上白格子数为偶数，的黑白染色方案数</p>
<p>求$\sum_{i=1}^n f(i)$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先写个Dp，发现每一棵有根树的答案为：</p>
<p>令$x$为n-叶子节点的个数，则$f(t)=2^x$</p>
<p>$O(n)$求和即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>想到结论就好了<del>不会证也没事</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ind[maxn], n, c, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>; x %= mo;</span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % mo;</span><br><span class="line">		x = <span class="number">1l</span>l * x * x % mo;</span><br><span class="line">		t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		ind[u]++, ind[v]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (ind[i] &gt; <span class="number">1</span>) ++c;</span><br><span class="line">	<span class="keyword">int</span> P = <span class="built_in">pow</span>(<span class="number">2</span>, c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (ind[i] == <span class="number">1</span>) ans = (ans + <span class="number">2l</span>l * P % mo) % mo;</span><br><span class="line">		<span class="keyword">else</span> ans = (ans + P) % mo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF254C]Anagram</title>
    <url>/2019/11/15/%5BCF254C%5DAnagram/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>替换最少数量的字符，使得A中的每个大写字符个数都与B中相同</p>
<p>输出最少替换次数以及字典序最小的方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>完完全全<del>一道傻逼题</del>，考场脑子坏掉了</p>
<p>最少次数显然，输出方案就从后往前，替换字符更小或者不能再协调就替换，不然先不替换</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>犯了一堆神奇的错误，还是思路实现不清晰啊</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn]; <span class="keyword">int</span> n, cnt[<span class="number">26</span>], c[<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[a[i] - <span class="string">'A'</span>]++, cnt[b[i] - <span class="string">'A'</span>]--, c[<span class="number">0</span>][a[i] - <span class="string">'A'</span>]++;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, x = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">		res += max(cnt[j], <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (cnt[j] &lt; <span class="number">0</span> &amp;&amp; x == <span class="number">-1</span>) x = j;</span><br><span class="line">		<span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>) c[<span class="number">1</span>][j] = cnt[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt[a[i] - <span class="string">'A'</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (cnt[a[i] - <span class="string">'A'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] - <span class="string">'A'</span> &gt; x || c[<span class="number">0</span>][a[i] - <span class="string">'A'</span>] == c[<span class="number">1</span>][a[i] - <span class="string">'A'</span>])&#123;</span><br><span class="line">				--cnt[a[i] - <span class="string">'A'</span>]; --c[<span class="number">0</span>][a[i] - <span class="string">'A'</span>]; --c[<span class="number">1</span>][a[i] - <span class="string">'A'</span>];</span><br><span class="line">				a[i] = x + <span class="string">'A'</span>;</span><br><span class="line">				++cnt[x];</span><br><span class="line">				<span class="keyword">while</span> (cnt[x] &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">25</span>) ++x;</span><br><span class="line">			&#125; <span class="keyword">else</span> c[<span class="number">0</span>][a[i] - <span class="string">'A'</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title>[JOI2019]三级跳</title>
    <url>/2019/11/15/%5BJOI2019%5D%E4%B8%89%E7%BA%A7%E8%B7%B3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出${w_i}$，多次询问给出l，r，求满足$l\leq a&lt;b&lt;c\leq r$，$b-a\leq c-b$的$w_a+w_b+w_c$的最大值</p>
<p>$n，q\leq 5\cdot 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果一组ab可能合法，当且仅当ab中间不存在权值比$w_a$或者$w_b​$大的</p>
<p>可以用单调栈求出这些数对，对数是$O(n)$的</p>
<p>然后扫描线+线段树维护区间w+Max的最大值即可</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>注意扫描线要从后往前扫，因为从前往后的话最大值可能是从l前面跳过来的</p>
<p>从后往前扫容易控制边界</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> w[maxn], n, Q;</span><br><span class="line"><span class="keyword">int</span> s[maxn], top = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; p[maxn];</span><br><span class="line"><span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> l, r, Max, v, lazy;</span><br><span class="line">	&#125;a[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		a[cur].l = l, a[cur].r = r;</span><br><span class="line">		<span class="keyword">if</span> (l == r)&#123;a[cur].v = w[l]; <span class="keyword">return</span>;&#125; </span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		build(cur &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">		build(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">		a[cur].v = max(a[cur &lt;&lt; <span class="number">1</span>].v, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!a[cur].lazy) <span class="keyword">return</span>;</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span>].lazy = max(a[cur &lt;&lt; <span class="number">1</span>].lazy, a[cur].lazy);</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span>].Max = max(a[cur &lt;&lt; <span class="number">1</span>].Max, a[cur].lazy + a[cur &lt;&lt; <span class="number">1</span>].v);</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = max(a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy, a[cur].lazy);</span><br><span class="line">		a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Max = max(a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Max, a[cur].lazy + a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">		a[cur].lazy = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt; r || a[cur].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt;= l &amp;&amp; a[cur].r &lt;= r)&#123;</span><br><span class="line">			a[cur].Max = max(a[cur].Max, a[cur].v + k);</span><br><span class="line">			a[cur].lazy = max(a[cur].lazy, k);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pushdown(cur);</span><br><span class="line">		upd(cur &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">		upd(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">		a[cur].Max = max(a[cur &lt;&lt; <span class="number">1</span>].Max, a[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].Max);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt; r || a[cur].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[cur].l &gt;= l &amp;&amp; a[cur].r &lt;= r) <span class="keyword">return</span> a[cur].Max;</span><br><span class="line">		pushdown(cur); <span class="keyword">return</span> max(Query(cur &lt;&lt; <span class="number">1</span>, l, r), Query(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;t; <span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">while</span> (top &amp;&amp; w[s[top]] &lt; w[i]) p[s[top--]].push_back(i);</span><br><span class="line">		p[s[top]].push_back(i); s[++top] = i;</span><br><span class="line"> 	&#125; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> l, r, i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line"> 		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r); q[l].push_back(make_pair(r, i));</span><br><span class="line">	&#125; t.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i].size(); j++)&#123;</span><br><span class="line"><span class="comment">//			printf("%d: %d\n", i, p[i][j]);</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="number">2</span> * p[i][j] - i &lt;= n) t.upd(<span class="number">1</span>, <span class="number">2</span> * p[i][j] - i, n, w[i] + w[p[i][j]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q[i].size(); j++)</span><br><span class="line">			ans[q[i][j].second] = t.Query(<span class="number">1</span>, i, q[i][j].first);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JOI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>状态缩减</tag>
        <tag>扫描线</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]LCA（ST表）</title>
    <url>/2019/11/14/%5B%E6%A8%A1%E6%9D%BF%5DLCA%EF%BC%88ST%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>求静态区间最小值即可</p>
<p>常数有点大，不吸氧可能会T，不过是真好写</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>更新Min的时候还有一个区间是Min[i+(1&lt;&lt;j)][j-1]，不用+1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Min[maxn &lt;&lt; <span class="number">1</span>][<span class="number">25</span>], tdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> link[maxn], dep[maxn], x[maxn &lt;&lt; <span class="number">1</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dep[cur] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	Min[++tdx][<span class="number">0</span>] = dep[cur];</span><br><span class="line">	x[tdx][<span class="number">0</span>] = cur;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v != fa)&#123;</span><br><span class="line">			dfs(v, cur);</span><br><span class="line">			Min[++tdx][<span class="number">0</span>] = dep[cur];</span><br><span class="line">			x[tdx][<span class="number">0</span>] = cur;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	link[cur] = tdx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">24</span>; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= tdx; i++)</span><br><span class="line">			<span class="keyword">if</span> (Min[i][j - <span class="number">1</span>] &lt; Min[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]) x[i][j] = x[i][j - <span class="number">1</span>], Min[i][j] = Min[i][j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> x[i][j] = x[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>], Min[i][j] = Min[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = (<span class="keyword">int</span>)log2(r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Min[l][k] &lt; Min[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) <span class="keyword">return</span> x[l][k];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, Q, rt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;Q, &amp;rt);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		addedge(u, v); addedge(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(rt, <span class="number">0</span>);</span><br><span class="line">	ins();</span><br><span class="line"><span class="comment">//	for (int i = 1; i &lt;= tdx; i++) printf("%d ", Min[i][0]); puts("");</span></span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="keyword">if</span> (link[u] &gt; link[v]) swap(u, v);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(link[u], link[v]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]ST表</title>
    <url>/2019/11/14/%5B%E6%A8%A1%E6%9D%BF%5DST%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如题</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>倍增求区间Max，查询的时候分为两段，保证覆盖即可，重叠无妨</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>无</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Max[maxn][<span class="number">21</span>], n, Q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, Max[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) + i - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">			Max[i][j] = max(Max[i][j - <span class="number">1</span>], Max[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span> (Q--)&#123; <span class="keyword">int</span> l, r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="keyword">int</span> k = (<span class="keyword">int</span>)log2(r - l + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(Max[l][k], Max[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>[Artical]NOIP2019考前总结</title>
    <url>/2019/11/14/%5BArtical%5DNoip2019%E8%80%83%E5%89%8D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5c741beed7608de469a28f7c8ba0a47f120cfa9a9959f08679bb063d853a6ab3">9725dde8c19092706f71a98435e1b7c4654869f8863670b20e6bbfde187b8fecd476be222f749f90e6d1271b2a38376901d36b8f325ba4d64fc9004e43afb66799d1e461223f281fcd94b011d6cbc12391293fb634f6b5aa289bc40917d2ce4c2ac849d4cf8ee2ca0c6af5a27979c22fc226f737f3f892089df2ea02b40e24b66353e7862fc194b86dda498aacbfa68fb0641cb192846f784378d74981a8edcfdc45bc2401c69b6648c7c6e46e948afc8c2300df464d8642a8ccfdf3c0caadd36e85cbf93c694c40d369e46ea4d45a72aad010b56a9ace8e2c2d67dca81a363b6620e6e2990f3faa15cbcb22bd30768e7e5695b92c17dc89a7cf9d00efb97b460809dedb2ab850bd9634efc8c8dd92f7031f66eca8b32880393f28241b518cf4c7d532372ebe893ef2e579fa78bd0a9c65137c837c4860c6c32db41a65732f12bedfeedebacbd4331285ba550280d66d4f5bbaa38ebeb04ad64bc6d3c94af8f6cc6d3cb0c184ab7f287926154b0d4dabed93658049b4541d3781098933d4925969ed1c84146584360035e81542997ca58f8e64e83a2f7f1676d630394cc3fb202eeecf1282c71b78805cbd148c5e7c9681b4c3f2ba6ea1feba112777bdf018cf94a44c468da83e84d7400b2e53445d90db9846d4fc79da22b752aae6e3a46e1a5a4fbb79764fbc107db9468e4ff9ab2ec44c360d77a1af19f7d4fb77ec71ab2f760ef5a23368c43cb477aaf4e0dccad9c1b81fc335ae2b27f828c89efa42089f3f856d4fad9f7dde5a1dc7ee425f246f342bc9167fe02dea252622da3e94a867bc86a5aec3e2420751f48f65623017394648fb1eed3a2bcc4b26e71b546ed686718756dc680a193481f0642096ba16013fd41bd3b5da785bee1c3f57c38bdd9d432ae84ac0774b0ca9cc36016bb88182cb721e16d369580798f6710a3c675c0639c9bac64e07ef6f95f30e7ae90f6e40959eb3954be3e584abfe9ebe1c8091f33ddf20f6b09bf2c076e1f768ec0f74849f16f9ae31f0c658cd055f8075d51cf302db7375072c05cfdc986995329f88ec7ac716a33d4b7ad869bfced5aef7a43cdd3ada5345ff112b4e4b658f0303f621be1117c5f24b321cc8309062437c08242ffe545ac263360e5b54790f5fc396eb4e06fc27cb006fa5c0df9411941d46a41a1629f1febea96b877d828b86ecab5e13b43fb7ebe66df7f1b8332c5902ef3889d4c240cc18ca33785365b6112b179ee7388bf13c9773cc6898d48fcd9cf98c894ba4c27baa952129e5a1d11c2d5c69122333daefc17231225223e0bcc886bb26a6aa2c34b297363cd033dbb3663fcdefb4538842dc16e563d4749913ad785ffa8f111a89a459ba71948f8681e5be3f3bad707fd776d84adaef37af13318f254303ca46c69952330642b898051b65c9b7d819652bcce5af423f0ad98872df874996b81272831f0e3c81f6b7012678c9c4a55dfac33d66a5d5995ea0517af03bd36125c64f4ff0d61c9322e6bb6167b0d3835032b3163dc04e720dabb3fb7041bb1030eb751dca1f7882f1262af77da27c0cd3091b543e26e33876d4318ae9d3775ab3e8a7e7ef9cbd97e70c8c395f28f159a1489adf178d60531d901ff39e9fa1dcb054da2dedd2ea49d4c1597d8196da24d093ed1a371c5d8e33a911aa61c2090d6c337ac08782d400d810286db387664e709903d6da610f5ac1949f0c4b2af254590fcbc0af017c46ad09e659008bf882acf0210fea7d09d7a6b4404bbf190b28176a11bae23d13cc5c7f9285a82834a1e137c8c4813c9e9456605626d787db1f5ddb7294521b01b8b30fde9e0020c23b6198091ba3ea409b1298f1652e2f815a9b401fead4eddd6dace7ec6c9e66f2eb5dce81dfc95bb06faa62f16b22d91736e224fd5fe671cd0fd9ea049c0dc0e04680d7400c7da68d29050984b8e3615819f8362022d106a468dfdfcada26a0228e79fbf288f9f71ce138b43dcf46be2ca95a483b488284e1a1966595454e249b7005cd65b1664e2e3d7595f59b27a8205cd965950fc28252c79c85e29cfaf3583c81d635c3e8130738475c25f1de787b8edced793cf6ff3923ce073aeeb6a7f87bcf201e2f7e5eee81ee04e1070311609f76945030eb26c456a59b56ce93ac028adb7f17bdc3963be0fe45763ae836cea6f9eacf2e98e2bfba515aa05613efa1ec7f1537206ab86eea1d5d102e0a4ce1137b7d2c0d9e6a0ff465f4fb0af138f096adc4500ae1961bf7cdfb49c9db7665c35f152d308a66f704de3dd4911885552716fe81183293c9a971b99570b7b43c4e2660052c44f3c7c1bbab752c2fb3e042e47cc0533dc8b8d772879626e41051f262be10ef3f67c919d18d9c245334938978e90bd699e2049a29afad708c1d998f46f6a0fe7aff6dc0bb39014136b6e04d2ed64fbee570611cd3c38a673b72b629e645c92fb9381dacca1afb135b6810f8edf6daae1f2aa8ab875605d42873bb96b22048761b50975f5feb6f8cc9b5351ab1c4f6d50512475403bbb1da429c9ea70d0ee8f169c909b8c8a39943b52159aabd63fcf9e4951010017ce2c6a04486b6c60b43c4227085bcbbbc61c8bf6047ec35a225c61bb32366131ffeb784def8464cc5f9de8158787fef702273b33fd0512c38101b4b7dfff3c0076b89d706136d1e246750f4fd309b262473ed5437a09489422d06ee16308f22834aba1b78d3fd8defaf69fb0a79b8c28a9b3627182e01faf3c1f17359ad3860a48906b1a87c1931f292ca23956af96445b32eae5b9afec499f931841c655f0e9834eea6f036b0494bbd9dd79ed7506480d0d239fd90b80f93df12aee5c751079f68fe0ada894f146afa1eb503e0d5814477919ecebbfa186e269b83fdd1f68f2d7ec68ecf0db49bc5868d6f9ef6b3b06644fed54407ec612559d846d1baf65c8f080f4ea47d181ac18aca88260c5ba7d4ab356d906b8dff1c4330b5a503d854de50914762afa3ca1ab4e291fd271aea73bf74e93ba7f68883be932a591366cbcb328bcea7313c344936a077c4252c99aa2c348da8503766a0deb4532afd22da8c282af03a4b5bb8d188607a7c1f0e6c32946dffb0c1779ba4905eb5c9a23f712da8d2609303a7e69e6ace0d28f9174de774c22cac8a4de6356582095433c58c8c1d2641e3ab332f39934d66c716eba8723a18cbcb9a9e69d26255308a27adfd15eccacceeb2f7be803cb235c742ef3e33c21d2100ceac88f23e3759202d21dc1fa13f0ac553631dfe7b80854be5af5aacf1a324fc4d9ede488da136b918644e47a7dcbdbbde1e67cc74efd34c7f604b4799f942524312525e79bf631313e025b0aa4d31623b764fa1c8f881b0d6e5897c369df482aad92a0d0f844bf82554a22c77957b17f12f50af82801aadd996b7a7c8fd88d15c6c4caf6dd0ec4b140a97cb58a8b06348f4dbda7050c44230eb2c4bf49a794a4f68e581575b050e7641b3c13e58898c6580096eb53fa0cb4c4e13917579d0284ef89dad487483f06a89026fb68d2c97e6af2f67a331b8f75ec1b4b18fdc669b03b230b9caa2237e916e4e0dbccc66103a32a623235eb2178902bbb51607a18d202e7a9d9cb5159bfe8f41198272452d63cf0e7bcd98238f9935de404aafdd695a13700bc0a39b3fdc4b7e823bd922c3fd78867dd7e38f57027667ecdd2a52557f19f880648ce7d5a2f4826a822fe7d739ffe7dc9728506c9060b2e6e01c1d3640fc11a7745d9294e2f09a30240b5ac8d593558d565d7820c1534e30fee4a490d9f3b0ed8e33da6827cbe71986f7279b99e155e88d1f246891b2ff8990c6297a6f12a04ad630f09ceb5287b5d0eb451120dc180ceec3cc9ca74de452138c72ecaadce786f656fea4b0595b8d7c292791a19dc0830f7718fb7e3c97da56419910f1fbe5a6804e63514647bcd3cf69fb4c413686162ecc803e4c7871eea5faa165c80f09278c0808527bfbe2a9924f5949ee8a45fa7fce2251d28af7b4f512ab6ab5e673c95bfa3f1f6709643b25aa732a6cf16267d5aea8179410fd47b311262eceb99f2dc3286e825ca5ab04b6efed5571e238955ee10c29054929999f4023b479f37a599ee530e8055267e294268eca1625ad5a766a8405d02b8180a1209e3e0b2ff370cd96a0ac814db98087fac9503014d730b7b78a15054cf19ff9c58ddd0ac3522d5b5fe9a1c9fc0ea05438c458efe01496b99851a1ef20502f47f8e4ca6854c104b2e6c6591056d44cda1d9a944fd5bb532c163dcb4327246a973fec096ac9d7e03647603be78178b0943fa96dbc0ac433e871d804a438f3e28cbf8395f43e3222b37b1f6a5efcbfe7be919965e9d64533e91597e84136c0d3c8656df5fe5d24fb966fc5239da61779538a1571f27e59c80a4b20d87a7e738ff0881e088a19876859b4a083e138accb6afa99128776fe7d5d84dd6fd8d34f67066a9f15113c3fd4350bf885b2c6c7bd302fc531a5405099a41061907769d1719fbbf54acec9af68136ffad4ceaa0d4dfdc0be46257d70d2b395f2f69190d720547ff25686c903f6da7c22c16c38d1fe5e0dac3e2b382d359688b339dac381e1142eb71d930c32b42b01ec1033aa572f132332ddc68d4a1fd870b9611d6845e38b7ea7a67f16ab7636069c5b4a2a795932344a29c9479dabf7fd69a9c4a1dc3e439cf82f524e4633eb27d09500b8f6599383b5ea31fb4d6285567d87cf0597040ad5915a3b251f268990886d62cc1ee432d1d713de9ebb89d81127568446febfa8229871dab7eb88d34da88b84110bcba56e4744fc6582174ddf2006d779b00ef06b88c31a2fb2412908c99e943450785ee3d3e0d8dfb66b8935aaea2e8365ad6293fdbdadaeb49503a2bb01e18f8069c82d5ece2532c1c4f71f7fe275df6be7c5ef758836254cdcfc112a1357ae53011412d0225f1168edee499eb0f622976696bc12ba2738e818b527c08278c42acb4f7e494864f03d7581787c039d5e2b05a54148b264bd8b3c412f0811cf730747e1d0b6502daae3975382aeb4e80859d5aff1fb0098bd9d80ea7023f63323a1ea0991d1b8772a8f56af084d6e201e20e0fc7053173b0e1190177bd751d53f1afc6a67e030d8b48beb7a17ef6b89b803185fcdb4ffd7868950bc1689f6796311bdd4dc9a19cdb3e61180d3e30a906681478194d1dd5069cfbfb2cbd56914bf6e8b48533e0eb4695cad31ab8c75d01d07171579c368b29ca047acdb45b97b83dabd5297eaf6c4ce2d38c3b35a82cd1213b0e934a66e84c7f85b8f3959f054b3c287a680ef14584a5829b16d409ad74fb08123258f196d95bf13022027496f61519e9a7823c9b5318ac018b186f7c4765211e0f0778a51fd59aaec410392bda2d729a1548685d625a1ee2ad36c49502b612a34fa4ee1c939665f8695fb508be21d222baec5b245a340de1e44d13897091109bf9e145fc9822413f40edeff58d7e6c9351c4781be1ed959209d019a3f4258d5dbf21bc0c00400428ef3886285ab70ac5df98dee1c86cc0a369c0659810e69c59326f630068788299099f5ce4a57d1eec5df23af113478acc4fb00f47abf65ca1ad74bbe0f62e8c1f2a399943cbbc1962f9b630afa92c87c031459a885ca8c01478323180e9607ff3f0689211921e2b5b12ea903238a7aa191d7340b8d1bf056d00dcf6acb90691d0f1561b30150ac227b3f5934a01beeedd15c7a958b8e122e411e2284d17159b33654d6de637570256ca359c9083985397c57c3247fe1e8b6579c6c599fac4c9b588fbded9110feca6010a083c3113c871c24d82b78701d69acbfbae8f4027c7af2320a34cfaf8c9e54801a32dbe855b024988299be4366464aa078e6b34ae6e2271604f19ce3b554260fe90b7a947493c9de2326397e5e6cd392d0b43029989bf619ea1b38428d47e7a136b6bd2d8be6d49353e869efea8f149044b9721761fbc68b4be380e1ce30e0375d648190beca094698bd035dbb2244cc5650a66834bf906223be917389dd79962c8ea6ed422057010d2bec5acb5f1e8cbf56983f5708feff7c9b88ace64abd2b855bd910d7a4442f3cd0a63d12afd56bc103092ef38b27d9cf955318a35a0f18f783d453b78f6a46d423c6eca91595dfe54adc07f4d0efcf31e270003a5e7d16c37e10d33e9f926b212232e4968a4c8156bf1c3fc74d0b64e122e3578a448ac6c212b92cfb08b83aa1687135a8441bd530d34bb95ace48376c780a5911e2185bee4c9881871af6b46d32ed8fadde98d1c34e768d27056051da98fcd0eff88d37bd1e54ff5a4faa176ae4e3e14aee8a22b3444657dc10696e56a38b815d5843caebbc5dc7e713e59616507f92214e2cc3df59bc8a8f4f21beca18f8b0a41dadb106c52331e5d1a28aa2bc24b53168b539ce018e60a6226db8705600ac0db0afbdec2fad2bbe136aa7214f019f4169750c1c8731e90bdef9e18dcd89c43296c932d97b524af64071e0562a1d39c1fe6e26ad745cb1bf99fa22e29d009ee9c254f317af10f0e679047f0ccdd47b1b243d57595295ced22cc150d4aa323d2efedc64359a214937e76a2f6d8860dafde98bfd95e06c6b4c35a7e7d8685372ce566304f71cddf880eb407356a1c0b72dcf9bbbd8cff86391b5fcd2ebfe520aca0104ca6dcb278e46c106b9492c3b221960cfa4cec46d10b55bf0eb9dc0c8f24efed543154e94bd8b41235c42ec8c75a3b8918c918f481779b34d92a5e2eb61269c58c7dc5df2273d6e61efc7071b2f078efa67e4020ab2712ec5c995d2987458925da35e21aba7d4618e31752b403a1b2c36bf48d8ba84231b8130127e12a816c56b63fb47986736ca2b5020d27c035241032370ffb3b4d1fd754cb4ff6ae9fca4678791f491dd326a5a53fb35db83bcbecdb148975837ac3158e2d4935bf06e5a5fd79e2efc53ee89172eb7ed88dc3de41706dd462aeaa716bde06553cef326b01fdbb52c1bf6cb1849eb88d26ce398389ce152ca2c9d03bf58887486515980d4239a387e9263cd9570c695b85f8538679e6255b3a3c82d14d6901d41fc31d8352b08979977cf599590fd3efdb1e9497ddca85e7333836ba66d7bb7b651fec2c0b2a6e4503b962dfc9a768013767bea984497acafc493e7af06ea37abbb1da5e7567dcbe3afd6b6d332336dd8bd4b7d9fdcb29567750e840016ad69de16ffdbbcf6add7db40e5cb87ca34eb2963ca78116a8d2ca9369fa31fad3f85e66e4e9e7e0e75bc7723b1afc23c5bf67b0627bdb350a19376e14bcf7caa9111ce841ba165416a7408273fcb217521deb46507293ebc24b101e71c929668878746531c410321963a4ea2e86940767779110cf67477ea72e057fc383e0433e5c8178e2d5114a60322bd0fb4006f5a841364552f33077ed6e02d7671dedca1a4c8721eb49c6ce53e7ea81094b55613baa59c9de973e5138ff7379935e56dfd2c60fd8aaad133cfe022e6574758da2442b78d956980fa7de5d2c070371ca0cc4388d3285a076dc43c800e57bf7e7ed41058e5d4193b0b71ee8f83505db990838346ce630cb91b0217dfc62015d7a95cb91e8b1d55de7cea0a0ae05631f8c6bb17d335b50930da081faa84778da3cb1bf450be303a4b13bc81a320c9ad7fb309b1f4cd2a8e26daa21638298a9ef8b9a207c5e27596439c6c0dc1cd1fade3fe8bf2c0a4c1b8178fe04bf09b6546917b7738668aaaba5c0db9f2ff5d997441597581eaa0350b8af5ba523fd6f9541e46b617b5d7191d0265fa69d89310c49efb050ad580cb522881e2fc498805f9337fae9ade771a39b0593ffa476bb4d07cd72de92c5fc40204213b9ca54eb5a2565173f29e47a74a51d37e5217b0159e3585f5482578f3ead98f0a3e5725b7f64dc0d8792802fb946aa90ecf5454b265615fa76f890674dfefe8be63e3afec7793c54583b2921678f1fdfbb4d10f99a544c6ca494f44d48e36c2e66ba1839f6adac6044a12215993584988bbca89242fe0e3fc551d80b66a762ae756b0ea12ef01221258e396d087e7730ca897030c28f6d1b5f63cb3a82d58684503b0b3e0b8ae2bda4e243f7cc4c2342fe218d25ed23dfe09c151ba7840afd041ccad0ad85adc40caefa858a2690df6b0f4eb7777edf759b7d88e921f0b600f0bb378e24e3f6d1a793acf164921ce31a9b430bb786d96df7621494abe0ce1d6fdb6c5e0c151baf9995054e74188a2758ed0c619eafeec13a65c099868498fa22a0d6d5d6b9818c08d8c086ffb97e4a6204c65b6a4270314a2b932ca43b0aa639b130bd3f826628159532af6cabee0bc84cfd951ed52a120aed8ff65e1a6eaa4cc29213033cdceff3b2cf6698ade62654fc91682fac9345956fc88acf1a1f803cdd3c901070995ef3bd685d9f9ef1f7dbf7779fba09eaa74aed2194f2746941b7fbfba7066a6b6950e6151e65f74d4719ccbeedcbf852329c1aea688f227ab4c34b345aa3d5fe0ba29951a9be51d35e6bf3ed0bb03450b6801ddb6e080e64aeedf546035bc6da0a854cc6091fb2d8e95c5b34221605390bf47bdda0868cbd4f8f44d2c51d4fed2be5905f80f5c658b883ed6e4fca611f2b116655771c8f490530a15f94ea9478e266fd482c7b22b5d026f403e8270073088382ed21d9cb24bcf6c025edde37587079a77ecf3a3c5bd1d9dca4a3304208f6fb2713c7b9cd4dabb739ef9d4116f042919a96f0beaeea19d6b17a305dce447bbb83cb47b6189a3d39007cc5ceae52823bc1c6c7a472692751bd8fca972cba10c7f7b7820f351100807d07f42f33f5db5421833533120f314fd8a1405fc635e633dfe48540527769a967956368f18001482d00e29f8acf2008e26b01fecc0943f8cf3569c11a4d4d9a2546d32089027f732b2790620361e36ec527561aeabb250aee439be71bc6a5aad018dee52858894e96845e009f6073dd983a71076b9c3aac476920df1bab6cd21aa133b74176e5f5edc958ce7a191d074db7ceb271d0f95c912fedd044fcf755b8c772c5e16c1a32ea41a66cd55907612647320489f9f74118050b561bf63e625bd7c0162f0f42729b74b5c5214b448a07711cc7f85c56e0b95215f4a714e845c6daaacb7408fe4a1ba562f1d9d75637dc3ccc13bfa8e01ca97e9693c9cd026a0b04260ab96dd47dee2085d56812342d9a7829191f930860063db2b8d1dbf1774b0d22d0a5531f202fa5a992eb0751c4b1343d43ceebd7241e51241ec14c56e9bb8b21786fed8ab6008ec01f5749700739f037dbc6711d9058193aae338e1ce1c345e19fc79edd09f67fde8dd3f857625a670e12f3378647aaf02c63688584ae6479c586a94147e525d7f22f1566aab68f0b5547910e4897f9efb7b2e9c6632e7043ab00c475d9fcd1b369acf26e4b0e7da449e67b987c94135a4b07bcfef21526fc513f286bf78012e1d8de49953ab1cb331dae533516640619a4ee7c3c23a7775dcb57c1af2aafad65daaaff8974048f04d271b3b1f4fd2abf14211f78a85c9f3401d24c622f3c0d2c824213650a6161a6ae8c27923e0924db24caf6e5718fb1709b0aa5ccffc6c6e888c7db661ab2ab12beb37bcda0b98cda5a7873e94da16059bf685f1730ec6ebf6c950deb15dca1122a04570ae30d9eacffd817f47b659595a1147fdc7b4381576254baf8ac655d12d53cf523f4fc032c869a151f6f6e24419ca5bc87e5a1ccdb97cdd54d863d130c7d5f734d42d8e6cf4ad67cd3a90b982bf704808deb62325dea1d3b92d6d67df4a5ea95512a8ff4cfeb33b351b070370b84b059ec1b4979367786cd3ea8fcba49b930d7afbc6f36a2d36f79c8c912680a436b2357672ef1b22a14ce674a97deb375b84e130afa322bae4ab61b63ff62f3af767887ba9aab2c7b8834a28771d862073320c7e482bb828b85f7c68bed4830f9ecba1467fad29ac98c8cc5973a23c97c0f3b2ab8128489809230efcab3f4515a5d4257d84c6c00e3dfea5ae2064f2a224546a6e5c661ba823cf03323f5c06a495a354f52b613fb3b3f7f3dbedf637b9a6649d98559e02c2c19613d24751ad42a390361776c9dd4ad0a70ae7487edc9f0fcbf174d121380b527ad412441fd325f966d92aafc03bbf2f797875db474b6df6ac7131e68dc60cc3462194535110982f0e8916c07ea24e686ecbf90e5bc0cc33c551f38ea44a9dc55975f7d490b156d8c9ca7fb09eca0fa644cb24b327838079a3d76c6b73f28687c44bb8d4ed0b3a3b245976ac0fff128a8e44420e71a7eba0b8fcd7c4d00179a4ea9c5bcc2f3fcaef129b73616277c34391dd768bf616257bbd750e20a400d20dbc77952f524077e146b990e4de7a57eb70f6c4908aebb179e3cd8a813df3377938bd8414097a5b21e8fcb0899f6cfabc28fa4a3423898bb83d0f9a4548d1a83b4f8703a0dd06a8cb5702a1c8b179c8bfb3f270d63b31925cf80a09cdeb3aa7efc1fd77ca3ead8eb8e2c6a6ce5f19d4219964a80f92fcbb33d0da80999c4d32d1652a929a5fe5d4811cec7cec0b91754a57aa103341a77db28a987d9595bdaad44dd9c35c559284abc47c534773497b48230a38053e2ff9673954bf30c38a77ba7c698236a8530e7e92bc2a8eaf2407f93eff669dbe7fec5eb331221eb9246336da42362670cb78fc8090d188114d9c4feac9bb8150e02e11b6615cb5810e2651fc5a4b1ef456e429827b84d899e3539a4729d38c1d04f6ec09a1ae106f679567ee4744b8440d46eb8f0f64844228fb63c706e136547eea5b7851eefd4107b30af4f734b13e75ccc493e9d4f95ff3b9002ef9000e613e5ec00253e0bb65c3d91dd58d08a8fff63c9b4caf802153a72db6b99aeb9876bda4b36874c16e50c50801ec04380ba31292784f189ab426710e20bdd70a844b08e63266c4f8ad3675796639f388bbbbbe008a5945fa3d20e10a5956902eada9141862d8b583903202bf4482c57faeb68db1e60c39e336ee5dc42628afc8229279028a41eb7be2a5d094b7d4247370023de7c04f29d82fb02ae0d52fa3257ebcd88feb92c2b975fbd41da117304363aac59938f3c380b8126bac0384c1c08aff4556a2e61be1faabafd829197bda3c32afc3b20ed76e3ef8969f3ed7e8bdcc96d5111a93961baf118b3d3846a8e29f38d432b7f0713c794853c8c355648450d4e9804d66e6c2516bc0835c2004570ac00e8594e095f06b87d78459d6447d64edc50aee8a211f4a8c9592a83e394fbf09daaafac9f09d1ec8d4169d5f656dd5b1b9e65118d38d45eb0316ed575565255c4c8211d0dc0fd5873a9758965a3b4b982feac70da3a0decbc7227a523977b41df7aa4df3cf33a8dd8c6a603782753df8d7f05c222b08364e8f9266e0874babad92fd060217db7044723621138463fff106d3afee80fa244a9de0566bd7371ec391cb7bf84dde6cd726fa5b04569de85314e700413b7fdc99f820287e6b6f56bbb082608a79f2800d4a1d352f50793ad18358054169db8e49145f0d54a0e187b8afb06e157dee15c3295b7eab3f5be5b6b18d641af03b0aafa027f42dd5bd47b254896d41905e6c12812f0eff4c50d34e8bf2ebcc6a1f91e368169ed0875c8259b4534562599cb5c362b85a9bfb1bc26190ef55a7b3573e6a054d5a28756f4873ae50729938f6807d616010a5fb69e7b12ed3f2339110e9b5cb166c09ad39e047aedc1aee7547f8373f155e9e878b9092da2a50e3b9d5d7ee5ae6b6673d2280984668c5f02a4ece4cab8a2c01b2247907952bfb1c18c4579ca3634cb7456bb2af8e6ca6f2a88fc1e22dd722b6b441ebac1fcf9cbc0bb83135df31506076a6ccfa36de9d9b78a5084aff66c68ea1a822ce493f7d8ae28f301ad954aacade62708ba768a18b88dd05d3f61506b9ec2d3e0f7a340822f88293eeb3109e944ee0007a70b81201a73c3f34d68e81997dc2cffc960db20023fcb77a5411a1fdba489f5fa409c8b1d7323bb095bde93fb5850db6d053836f860fb95f24eb46b64a1423d3744512916185689d38ba29c3c1d89c5eab8dd57875c8843338187cf4d9503d27fab62dfe67562ad2f280da0f55beb0483009fefdfbb7ae21beb552eff4f7bfee3fabe63f8478e6b309a6f96e7d5511a5ad7615a27dfce2ae73099e635793f85550f7bc7de8ab7300720ab14af6039153a661ac93f3ec2eaedf4d425aa7d57f44234b2585995bb34031204563790ec4c7e738ac4535e87263e2cb856313cb932d129a07a76528f1f93af54262ddd769a60c038ee484b7b3ba2b34d914d7aed50b617e5df04934db81fd187dd3b5f20ac4d8a0722851141bd21ae1002ab38716abd7bc20caaa5b2c933edb297858b93c4731ea5786ceb4f58f3d6b759dca5d5e9a28c75416041617f2fbb00c296bc42bb138cb38fd4ab6f8edc69be318d83cf21321e258358e9158f93f541791aa9db4c1873c6b360ba3f6547e46cc67fd0e57b4c6ac4d6999fdb646ef33b6379fd0a54f770a716747983232c6fa6d4bbc02676a8bc014e8c9818e4575b63646d3c12e5525b9f7f9a0ad7321b38ef7eeea42ca01b192c22c04a101a071941c2625d94b26f5df7365137d77c6abdea82de9424e56f3547c02f0cc20e42f9cefb847e113bfa835ed1ab253214bdc735a6dc2a21746da70550a440278dd29c6b08054a4d3d3aadf75774c12ff82965512e823b2f100075559f9096c6367a1af41491895980972ca9978be71853362b76a083f5c317e866a07135b1bca1ec525115f33021471916d5e8a55d54e345434fed8d1f2ff72ee63687328b017cb954803afc12dda81cbcbf834b3c283d8290fff8d227bbe64096d4615dae879146a50f1c41f8ab06d5c4d20ea4767031fb556055bef34102acee1acaa22780cc498dcaa379d18ae881255b3b52ba8578b85a595b5ebec15c865e4a019d6a8ff5df721b4246b53fb921de56a8e5741faa3435501a5d19e37d39fe3ebd3a5d3925b52e71f145507f86c32f9050572301f797bc5232a89e9aaab5907050c7e92faec15c2156dd979e03a1dda8eaf09789093abd9fcca903bb5e43c4e4bc4ab3ab78651f4c4c81ce9b0f040e8fb9dc55b2954ea4bde78af57ffcc9b87cce548ca8d3e4d8d021d8814c057d6432b88baa07f8911ec0cf812b3ef50c347d08e82913d44eb36397b66b729570465bc909f3291d218c62e50d1d1c75b9895ecafc246afef768b051350eaa9a67f97ed136a0677ef144e80abbe3730beea33981e9b3aea9196725bb986a2a842169df29b602a7a3d3da7f8447ac12e71bf09f52de1c43b5a67b18318b8c06a51dc1e898aa9109dc145ed7d6f2d6f5f56e8cee5aa6fd8c3700702fc70c7c20360b7d670a9702b4d32efd896b58263ba92b6e80a19e11dec01fc9dc628e34348063917517dffc515f3def58b13fed504c2c207137fbbaa4ff5b72a45b95849efa1792d835366ed04511b3d90bf056e0a3278e2102c19fd010840bc67e1453808e957350f1cfa9e1926465b770859b3e9fed8e48c1ef566ca10ed0acb1ba9b7fc95cab5ed96ae7026e8c391a388453a3b12b21f133b33774d36fb755597799f02a60682a298dc718abf65b71ab3e10af88a7543c5fc730e49b1e324f780d9cda3243d746cd70937d3698659b706af590fa11195e836cf03685ed66e9dfff72bb43e5fea242b27ed496fee670a3497c8be4d7772d7f94ff8194ed981ba0b3baede821c553d87e551bb13c085b961345d1ac2410a030132b279f2a3820b7da2f28964e61e95f39c8416805d787e833f3d64b3a3bd4f61aef79ef5df2ba62513249941ae1ebb91be5bed253a74a0a8738d792347cf0bfa176b7f48dd4b076ac8f347ffb89585ced8dd1afe9c7dcd8f22007ab9c3ffe068f34ef6b4084bef24e71a843f0bc9cb923d57aa1d5f5ec78fc4042e8ff76ceaa44ca46a792d6acee6a772783af1a86f641f529bd288327139b5f323ecd6600af0d2ba71219ffeb2ffab6e03bcb2c591459f4541a36c78906df4a9e0d313d6dd6e0322a4f2e3ba67a46be0f3034ed8c98d40ef9d49837ca946dae603fc5cf85dbfa5c54e81de57aca85989c3e747e28c8cfa76741f5877a111763f116e3bdb2d06970e2f090ae2bad41dbf982f44dec7c390f131e5cf10bd712280330b6a2525fe349e4b8d653f38ef5afbb0cfd077395bed0eb628b879000ab364a1ff43a22c520b026cbc981795f2963b3341157ccdccda5caa06d7c8d23dbb6a296413d839b143ac0285ebd9d5600be27364f7868be4a7b5e9c5d4da6b1efa7a97225637598c7e9d1781353c86be083e8320c3e7a283977a82e0994c553fc8f8327b8ad6a84559eeb6366afb8889e7df5a8caa81d887593b11f3f667378add80249e7a5f7b7edeb6fdcc02a83fcb119e198dc4a52b9a192177c64da40cafb41bace710108a16085f544e061b583c9a897cb86a14d38709796e7e88cb7a16c425cab52691a33790a57d6c91d93dfc8146dfc71eb04b128794b740ff40b3d266c122c489da3bc9af4bc8cb5c465442a1b03598f53c0a9bfe36d76b0cf6b958adfbc61e580b602754b6aca059fcbc298dca62dd61746b48af8d208ff30c30ddb06ac209ce155abcc4e6387c947d3329408c2a254fea8c9c484f063fb426ff883f308a6ebcb7ea6afb628b072f63853e478517de26f17e798ee5c57eb752988f17b07a27f1e2eb1dff5d43d217a24e17d37667ed1c069760bb87011f30d2c13dbea91b29f9e150ee432d8e07366d948160cd0c8b2dbcfc12fe29f1d79c985adc89503d54fdee74cff0d5281e54c6b07bbe88efc236a7c3513ba70e553c02a4e72890fa45d6bef90567db5cb563b3a63614922b346d5f58cbd7b2039565cda24125dc4df6cce55b6a4d14ca92fc72d1789a561153deec405eb6c09cbdd8bb21df7cb823be8151af6d3b54e80af2b962aec0ba4bbfe64516a3d07b8d65d1be3db16df3a9a9346f4be48ee15653deee0a00700de0b606b8ed922126aa5877e0d3dfcc6e592da47402786554ef5900da2737463c81bfc566eeccf4e1efc02a4de943a3ba70846087acca30871b0f53f50cd2c6e1ca31dcf94b0eaf2f576398e754dcc624d44f819d5d11a47f18d84e163e20bef5771657ee074b633e0065304893587409f5804d56dcaaf03b92520d035a93438c7cafdcdb13262b2ae61e72839f4ae4c6ba374af5eb401e162ca95560922a28af000cf0fbafa43e2f881a505c9ebab026211c84668dedb54871dd243948c6dc4ab2beb5cb316d6199d3aaf6ebcf72d634a537125c7b6220ae6420569ef296700612b581640e07da0447f44c390802d8e63f3ce0f4316cd8d09b4b0f156b94731e201d2972447f05888010933be37664fe5cdaf9e5d5c97119fe9ffaadd8dabab9e9c482c381ab3bd383bc0ba97fe605b1119ac16ecd2ea8ddd1239a4e9b4eeca994478cec5c31497656f3e0ca9cb98e8a68e6a6fa94781b6df16df9429bfa9e94924c1b9e1dc89c91c28d78c3476eb926e5ba5c695e855c11f3358c8b9dc1e2cda93925db85706002d354bf431fa18f75fa96b6bb80a829e9b6952dd7f8d6b89c439485b0ea31827663c726d4a8cb9a1d28f03196d3b713113da66a6af4bfb05e10fc57a65eed8024b913873f5949683d6730ad528809b381eff2ea0e6d1b1135a53c75c959c0578440b737156e2df7a47d526d8fd6ba5b99d2eb86b734e4b9f0a537d38d38146e738ce4d9874a9bf9fdce080a72ebff0bd8a47c840bf582de20c22269b40c2145c3d9394cc413a221530a4733e752af529a1e26aca0cd6a4a149e1b4cf777cc877bcbd62e5410f7adf9a49c418fb89231d4051ffd72a515f1962a7530149a082d1bc51ba0d540581b45b4f9eb8ce89d839ba7e94d9cd7b861af224d174c971355b69199707bdbf64b6ead6a96f94c6dc89bf94f2ebf1808583c6fc391b38d7fa13bf64d9d5622d58f70b06d701f42079ed6642eecb2860056b945a55d0a11544a0d63b0f24f0a0391e1bab7820e850ba2af580a798eb354b227b6fc543aade97439369a6830e5fe4568e1015c0619e6a446c41243f9cd8d119adb62a0260d598f3e5d800590d4bc785ee6e347d44196a7cf8ed3b72839fc23f98f8683bcbfd3b58a4ad24b32e2730490dc0d552db6766d3d05358c17338052104aafca6eac6866df7c8df780fc91867d7f01554db55cf3ebc4b8f2470b57fb0d2792282498f8ea2cb4d399fb60bf2b7aada9c17a65bc3b4aace2e23e247c338c738f7ca322bf3459c76e566b61954473bcbd2456c3833eb9ccbfc6cf5ff5444bfaa0e919a9f15c92051ff8efe46f7f554fcb4c23f67360419adeefdfe7517ccc2c0cef54538abf976e5b35b406cd4de020735ae81744fe75131dd0884e4b0e5b8f27c035f3827c607d0e2b02393e04e25fc3cddf4dc9bacc52523042fef9e38432b84f459dcf744a05bb8add4d9f62b304089eaa6cf466fe7cd644daa4ae704fd001e247993d431d3803a95dfca1c83e948b78c3e6555998719fd018571d0a24cb773d7c2b0298cad5ebc1072ea52f34ccadcde6089c75c8f94628d7f412d1e9554d71cc6de6c7af9ff956c3d751c7dbfe47e03729403d9d9ce77a4110a1486fc217b8e6656b62623720ad36f6ddab1b07d143e73459e43c40d68c24cce77555f5845ba99e8eeb4b129bb02d9071a383aa495697fa8cd082e4d8cba5c95f497cf7228d805fe6acbc1cd25705bf2ecbcf1381bd95895a5ec684493d05fc0bb29557de147d71b99d4d22d8704f2be71febe2902ca659e8415ff7bc1fdbaa168a5bd5a8319a5dc9860f3745517856e342c6c5d4f1e8ff2c8fe44053578093a15305a1032e42b328064cf44843260c09e921cb664773fd8c89dee3995ed4dd175c4c20c943766f72ca2ebb18dda531e88d624c258d5677c0c69557249d7c71fbba84a00addab8764fa8ede95d336990f769c1b154d9246c58f5bf313ae372ab0a774f3a3e55a0d69ee2a237cd1932620db51ec624ec5798bd5aa7162ba832c6859c88175ce4d6fe7f60d77c05ae21cc075dfcae923912fd6a7d6802e127e291d3cb9adb51066e9d32a33d7bdae38f3f59f741bd1c159abcd12e19452b994a0e18c092abc348b6b2e80fde0d43139698f46561f517014af8dd6c51b300c19a47e964131b439b6be3e811518c611bde19dde9928854a28b0701c13f08e5f8821b0b12990668d709a46f9fbc9702649b255ff5c780f1a513c272f821a11ca51239ae89fbfa72b474a486fd787b805855fbd44a9eb96e2bf29e4fce1a3afb3c4d53a1daee7583c15c896a6989796f98ced3c8938e933258f490b7ee5916deaa5b97b9ce8c99989b6b83667e9753a1bc0e050e48e07cb49252851006e728382090fff1bf0cf0f4c23330601ea63644314261bceb111b72cd2615dd10a45cf25db37a03515f6051579dd6cbf2f50b69ba305ffa55c630d1e481e1f9d1f5a310340320f5c780e6b80daaf0428374f3f1228d3756a2468d05d0bbd5f6de34e038afb45f53d49e4439f203401030c3bd7f1e02566267aa4a9634d0b9d2d2d37ccd2887ec08583cda550c6ab3efe76c2d05705d8c65042259eda88ee829172687f2bc90d8b6314f182e96e13ca0ef30fad54543c7f1246dab117d701ead6b97d790b5d7061c1fac003be6175079bb1f7abfffcd28172fe77e030d069695e79369312998b34d035a1e0ce10d96bb341a7337ee5214cc5351586e5a89ef8afa0afe86712d2ee717b97b1f53b70b87c4a1babd81090d288a8c623543811d9f6fbaa833eddfb01bb7bdb30038ef23ffb57e35851230dea91d19beb70ed95beedee5c44239dc2740d59e32a3e153e35b11b8cc6e95d1c6636b9ca039626b2c0ed5dc074311c0c4e369299ca503c0b2a5a1c09779e4eb1e9a612f70ebd7e229e291cf53665f8c0f3b336f7a74fc95e1974d8106567b7f05aafdf87d43966d66167a7f8a83daba36a5abd7e75b0152dbe422c84d3bb87ba3eee3fb6814d0422377c3cdaca013d3bda537766808bc1b6614aabb63ab6a7cf28cca9cfc37c87a4f483c38614952d9dfb369fff32743b000e31dc8d0568533088228c5d52db61ece7d8d7af4fc94956cdf8491741e8373e7edc78fe2c631f8eac6d2f3faa4c030eb42cf934f4d4566953268d60da27dca2c51ec68a0d9aece09e963c5730402f04a43bc3f48608fe306728c2365fb7e007afb96173cefe17516a8d62cff714939dacb3e54300d1a80021b513a14bc67d5d129af2f6d32e8dca9d9503aead1f715a0c26e05b636b277c5d99da3693a895c2a9879f10a1edab67596d32bed513b1dcd4b9540c65be605b56893c1ae45bf6a1d65e36031fb2da134387a066b44215d887828350f811864f74d4982c7586bdbf343e68856c2659dc3aa8641c8123454640173aa9c9ad522791076a3e9a66f589c517950bd39928bde867b4377a2344b1abf56a0f3150d34362d8d6f47a20d6181d7737535b11ba63393186a26db2d1a395f83ce78fa6b0fc6ae1a29621ab2acd9ff65c5a93f6182d00753088992fbbb725c1650420ae3e5234a921f7210b08af13743fdd0f25175a728b5d96cd9e253ed0a9a9d69733fa28ce323d0f37ead2f7b9bd42fcaa1baa9d11a442e052184d3d081f605f51495ee10783a6bff255e01d5c21fbad5914c2f5909ca4d6452e43b54e5e553e5f53e98c6c7375c545623bc3ab092724d3ff793907c2f61e77de74ace1fa38b0f0eace2ce3dd7aa5bcf0c1bfa8dc5a79cf7d6a18069e2d324741ce2ffe5f50a7119c05b653b270f31378627beef2afffefdb84210191ffee45c39a7d15df0a8a42e9eeb5a7c674bdb2de3f5b23ab78e4a865400951f66ea870b8c7cc37b747bf337968113752ed3b7cdcf5083b2f67699ced6647c5a39a5bb160defef94d1d63999ecd4e03a9cd636272692dc33e304b4d56f6afd9b9254c8126c6ae8b7b19dc5be6fcbc88ddfea2496944c22efb9899491c7d51a968c259fb9b75ea174bc11fbf8da75c17f1b19cfc01cfe921e76dde4600a75732edc38c09c14a60b5471682f1e2ba84d7645fc4159bbf86180245f06a393701ea3e7aa9a8e6c3fa1eac8969e5697b608f6b87851f4ed5e20cd515cb617419c94d43ae73e9c0b64ca24ba319d063c811f28976bf4d002496dd6bce611f6aa3a21b7df7ee99ac90ea0651024153cba4edb02e1037500bf4cbf7b2ed66a62eacda0d2b352eb9fb0d223523411f0c4fd02e4409f07520fbabf7f9c3f1ccfb5b979de4d1f79da902b2b6cf8cae4d945a7ee5c4ec76121764c3b1fe8d98b0d21cfa332eb8d3031e158094d9ab30675f8e62b84758c5d87afe8bddbd162259a4cd3a40c7dd5f1140db698e0a309eb42f554780d1c10720595d63dd5acb9d6df18bf8a2d0b8bd15ba3f75fd56e0916a1073000b5e2c57c42b49273fbb5f04097d3d727bbec4572c29ff187a7e8046cc0ea74c724812873262013e06ba41c81c227b325aae513b554f63b3e9095065e790584bc7e7f1598e01953c07f2f467cf10eee58638a3a8b5546a43b2fe530af3812957a42c0857f9a44fed98612e075ce9c6b12de496f27da1d910356de8cf4fbb10f8eddb7e54eac0bdd4d4e052dbc19a4af49fe7254baac065824896e60e42dc72390f30e949082b8939029a57f1b79e0a9d4b5b034f850004e0dd50e6bc31c707fbcea4b821a7a3537326414caf8dfa2880ab704dbddc0034c5e2979fb2ac02f57148289c993328abf4c0b75c0529e3458b8d67b52ace27ef53bc9b33f470de94e373504a5dc1f486ac2cfe9e320b25594a7612b4a977773271f3f24909d858c55149432053a9bc8fd37c69750b7c22ad1f26f67dcccc4df10a04421e546e45ee28e1df68fc2b9ef7982bd8980f78fa8ee99bfc1298f4644a2d1fa6253802efb553962357a4acbe65b8d91ddd49044fea8057b14371dd9fb1d9a1ba9d7ebc417ee7cf77b4b29066d7f892158ea9a9e6b584d98237300da95b8b7632627f03b127504b6b347f9de5cfd7057368d9522362a91bb2a0a42741f0ac60a72dffb3ad8bf00cd59586423319d468dd8090fe4e1995d2684eb4a3049060720144f2448b1421f377f788e941ef9f1855d17a9cb7a0c503f11a303508494a9c5af9a0ffa73c3e910db32c3d97bcc35e6572db8b35f5d97ddfe4cfe9884290c89c1b6bd5cfc2ac53867d32248dab401e4eb7e986f4378ec601b359eedf6f819cd688b9c61cf951acf69862b3a272b9c94d2887f3bab10c977b20fb8ebcf562a5ee2d0079e8a2b540d8c58d8ea79464c6d60cd8f4fcda6a175f2cbb1e345a70bc07cfa2a5652d3948551cf8c4776db914b9f2607460b9976bccd2f7167b3e6d2efd45aed2fdb21a5b3a1ce40845620bc6f52582a7c74e53dcf2c7ef35ba0e9ee9876be5b77138f5481dc94993e8d8fd9f6d47b0608a32f45f582e8cbb190d0f1bdccc08fd2f562286b07bf791ce5bc5035f0f3b1989a667397a9ec241551c0bbb8c9949a60e7c3cf3566ac50c9670c101c6ae868e587f05c934e67fea73c5a983ffdbf27ccc206fbf5b1f558429fd0384b95226a3c64ee5963659fa92a4fa6812b052945135efbc7e4faa49751d12b376f8df252ec937ea29506e6e2114b1f571d5fabb5dea1c4dd380fec3bde2bba8ff69f74ce8080be5d26fdb2151d0cc61a276248a414b7ac8e0e08cfdf4cdf6a498eae4c7f80997941508af465882027238b1eebf12d3fb30d9d4a237dca497d5e48f03adcd331a6ccc3145bd902a814041010028f742c60893cf4c6ebeca91756134ee1c07c94299ab5c2805abbd54c84513eea8f37da543ae94c38158d6d26553dbb8b0279c50a9fd26076122ac6f1de7079ec80244ce415066ff72f5e9a1e2beb8242c206a51fed97065495599517397b7ab787960226ce0fab0983431ff3add0005928dd8736bb5d401e5d01d4d6b23d43ca61809f2d30d3707fba4133306f26c7bb86eb54d460a3e400ded468ca6f1a34f08d49f404c0eb17916967adf16eeca4b7cbc2cc4a2531feee8d39dc8e58bd7b9403bbde5935617050fe7e09ec96508c83dba99853f6f544e2b0f2a8da75667bf3c5e9ef2da5ca8d6a657413c9950078c446951f00b930d511cee511d8d19cf6496116e3b4b1bd8e26ec1a1c4d44a2ef9013bb64cca7945fb8a9f1b5e43a11a434247d7a1ce2dcd2f7e1e750eb4582fa8b425451a19b9c710a7733954eec0829e4e6a474fdb42ee124020666f6851ef804d4586536594041880c5c1f33b211e066e189e5b01e745cd92c555f08a72859444b106abcb1b1d1ce5519627629de303d167af246a70b64662c411c363da20f8db1467622a45f2d72b5ee2430bab1366b2a6b01aa38ac1db59a6aef0e32cd6c101017738ad30419ac0d7425ac33e0ac7f1f40d14dcd4214a49d2f5efd4cbca40619a627307a50999630af9f10d937edbc679bde077988c48add4c00966ea181898afae92d7f674befe23a6016d0281c5c8f3ee84d95ff3809b8598fcf903d3108ae211b89eae75c52915e56b16306f149c27d2fd35883c73d1035960d82cf5d7138c64201066f3549ac224cd27c9976e71c2a5da2c352ad9e380b26cce3ff4f5c4243df8ba045e6e1677266af10670a363819bda5744b7bc75ecc8d37ad7a75f54ca38071dc77e4c7bc1d1a7bfee890975bc43f140971b8c51bc9460d85c8a4ea4582747a089116fe9f34e6fb6a59a783827aeef356747f1df42b50e81aa19a30ba6388985e7ffd8eaa0e683e71f408efb56ac7b3598872ca3aba8dad3fcc11079be6b228eff574d21bd162e7e76c955c3a3b02808f2eb2f331bb6fa02e9bb362f3c0dbc49c58d9eda9fb826b106b336f0900861053a42106071f640f94243e15d3e36e6d01a7b909c3a60647d10d4a979d957fa582a5f6726a401d4620bfad6817d9733449e1d7c42723f951192eaed0490b60e7c73e6808430b1019af91f177aebc22d0d76f7468e45261f0fdeef68cabee89c8d6ccfa6795bf8e852fade8a277848a40294fbd430f07d336d53ef569210f8ac1fe17d605184b6e094bdd4658a605e369cb096668c2feb2baa24228cdd46a971027152232e731b7cb54bc0fd1253475394caa98b04ebdc0334cae422899050bb684cf6a81d5edb58704ff49800ad5510fac85f729062a0c81239f0e714c943859d2d714eff4e9484667e640b43bc83c623984cb26794896b431b2011eb89d84425c16205e170fefc0beb69f224847b00c8ab17c4bdd4d9afffcf252867b54e1d83c373d83989d7fa9137bed9918d643013d51f7c35edb86bf2206b24fbbc8382665dfd9b21ba9d6409ccdfa2787d7dc7510701ca2910ddeb7c5277cc3e1c3184ebb657366c4b5e32b0045ed180987a170af99be51c4a82539c27ba8311750f178e38123aa5a9f0d78c0fc0b238b0a1ef6e1d76463c21b9f04a4ae7d34bd5b32c3e03008a9e2c419e1bc1363486608648953e0a361d7594ef7c8cd3931bb74184c7d1e4ef9ea85fc65d995a002ae264602fd70df0f5e59a664dde0b3f805eb420076a41bd8ef00da7951805aca018981dbc694777795e0eb2991c5441ff347dad8b20b2942d03dd1ca80b39234dd4f431c1ca038505b31cb304f5113c42e91ed30d37ade97deec687e80931e21620e67519a846f0e48735e6f996c4c1f75399ee3792c965c59be252a19fa06409c975d061e0501a6ee14edf3c97b43685085096fdfd7e886b0529938008fd93da5fe5cc402abcc5df276ffca209bc8ffa61033945c7327367f49d003ce562610b94999e3a036b71fd50e40d08588d6b7b46d177084b40b0bb2df1b5cd3fade70da7390f527abdb1157a65a3260469f417da26be2a4950404bb9f00df489344b6f026d98cd684d44ba171da11743d0bb229e7761817524bccb572d5617428b8a79d5a0b27331d464b2f2d3552bf1cb7ca25e8d2ec791b0e30b732d8176aaa6a6db3f4b95d1e63f7cbb4ae433867a6b926a7c1687e7939684462d6c40539712a42cb32aaad49f4ecfbad2dd58264565ac24c17e2c4cf67db7441a937a5fd19bbc26769ce5b07c4826400e0ab031be5ba076a962ad9b5659e42fad8bc9f489d278cd536a85f0abcd2e3fd190b94c80784027e1de23057890c3630eab9b80c5f1747aef353bfda466d7e8acc594749dfb1f0730707e72696cbecbe3495e2cb7059b7cccf0a0508170818d462ef9647a71bcb46d3795cbd58db5054cfcdb4979a6d600bbf3b1c0154e89e63f04162151629a2657d83f4bf591dd14e70c47d8a95a0192aea3c87bdb58ffcbbd8f1c9116287ac521f1d47e53b265ff86a817ff2292c41794474202538db196bb89a1ddb9247493e6aeae1653f4e49d61966b0cb86bdbbc7e37d88f27bd57a64771533bed223405506b319653b88c0188074caac566af9e5fe424fa8c290c891011e70b792b8a622ad2d226aee0e0a8ce080c8f7dc29754d44567aeeabe3f628b6b19490e1c0edd969f91d173e94140747b9f3f0e8b0b82c810252815a37709c5e96303f02c73e4c1a4862aa2c16ebcca20e03285646704025ccdbe30e3a5fc13d5c94424944643b0022afa513593d1bc7c8ab36007f018cfb984500584aa0056aa3f3f0f56fec8227cb0b92bc75e582fa4e254b185e237e0ebb94497ab28d0adc86e054a0fb2a5ed681683628435b310618ec906004e382c1512a8ddd41343c76acec1118907caea779b2ed02b3a375bbd43a6ab51ab4e0bf279d07d760e7eefa6ef7da2724221976d66153dd8f94d8f904113b45c3023524a3617f8cf90fbae6542ccaa0e79e26db592b49a60f7c352d61f2a4cdfb57e9ffd5b24e839dea6332e4c729c7e849101aceb9183cd94957043f5fd32770d738f92f3d112eb450a66867446538ba7f830d051beac6c46cc0e4df4eb1b1478ce1bfa356e095a1a16965d743aa419685c13caadbc19defcef398af20c633c2a8d2ee564ee819abe5ba3b1f0a17972e28c7ac9ecf1023a6b790cdc6ed786255fd3f57612618cf69fd5eaee606f488a276ae714f69f6533305bb031e14546426f05189237c2fcaaff0f1ae8335e242dd874250592cdee9a764ac24849f23515454ed3e2077a7d656a535287089ad2b55bdf0656e86b5d2de4841c40476690bebbe7d2da9acfb5f523584cb34897fd874208de51d476d97eae08aeb001ad95a5c17825fa21c6212ef974155cef9e696e79215f66e152706f9bff1485a65a20824372b9baa241cd19e78354f15db43c4b97d2469c8e036d49b03d737c945f5f4f8b72e45be97741ce1215a584e747ad56583b867b1ae01f0159e01c3c47732fcccc254304c22f0dc8296e7dac12864b240eb23ca5def114a10d72ca42608a9f4c5b87cb2826e1dccde502d1c07c36db9955fe066cd07eb0cd93e0a53b041fc563f84471bf2c9d4078af9ab61b312e4afd28e482d79d83d15756d93f571ac1f0b0b251e601d78a58869b0366d613680eb218900918205e4083264d5c3bacac1f2ba63ff54d84420be6d94a7f981b508511b1a35c718f6b569a4fb0c42c0904cc08854ce4351b755b96e606252f4b48177cfac9367d5bcfffe47be8e0858d9e31ece76de99f2266a6863ba3817aa72153d4ce9fd65f02ecfbe71b114fc22b45b586b43f73fdf150e0224709087b895b67e3f9b94683e157bdfa0f6067a0f47d6c435f42ce3416f549e8fa8dbbe6312794c807f3d2f5b4c399e14cf81d91f9c3cb511078ed1e6bfdf14e9b614ca2f8a4aa977e7b1987ef2febaaddabcef38f7e855a74f2d7773ed2ec12a604f2b0fd32832579537d3a76c9d14658e232dd4f1c2e6dab1dbb16b79ead2e12c96f7f8930cc0eff99d33ecad9a9d90542b6d86ca9b6775817025e46b73c6805d02deb3cb920753a9212a4884e3cf55774f65929cc45cedd4d033610ce06d0a96833288de6adbfa7eb0790e0667b4495889b6b432e1ab9fb3431d6e3b8234dbc0f64ea3ed67cdfd36b107e184fda20cb45b24801959caeea37bfaa7d4688873fb1e7893e47bf24ca977ab797ec38d8fde7bcd95170e52833464677a7ad9eaa5d0eec82532174221525529a3ddf75c7fb29f5541e61286987d50142c7fc2283e4d766decb5c603364181e3deb914b1441b4582a58e958d2e71da1a29c3bfe3adce3b63be70987d987bdf1de9c4aabfc6df6523ce1691190176dfeb9982806849ca300c0a9845640a56712da602e7cb1954c81a1fe234c338e869da78bf028bc1f61c8f994404503142fc3ce59343114adfaf7b09a16c8568e3c12d1085decd448b0ec8c2b146d657c5596cf89e39d1fceb5a1c7b12152815a7b4bc0e7a320fbf600ae2ea7fdc073c06dd2b07f3894659a84bf3dcfcffefec8a55e62e50f0f3b0854feaaccdcb43858cb4710780c798fa41170ad1034030185f5133f01fc176f4877e45f0fa97efb5bc02e1e5c4ae15a7b06136f02a354f8ddff21a702e43d8f1e4445b73db8b280c949a76c3655e68cc7603dbfed1514566f6e9101e9351a670f206c489bf54d9a7f8b632a25e68c9545f0356f28e55899798e0ed5bb9f741bea4d39b970cc99abe9abe1564132ee625d6cb32c9e144899b801e1ecf0f9913bea91a15c75231d31a8dad04c0b539efd0917d076074f0d05a621d196c73b7425b2c5eba8e64ef9104d5b89d31458704e61d16d0f648b955f12afe68afc8549bea83599d1f3fcda93830e8253fffd9c57fbaa51f18b54fda5637585aabfcab6ac23b15b42cd3e54bb413a4b3c7642afc3a574081c0be154bca47fc74c40620a59895796d49ae6aac2cb0225ff98f6ee051919ce91222304cdc1c104e0a4af2431c4571e2e4768f9e990d24918be584611549b9b78fad4566d3f8e159c9b64ff0c7c547543c70549c0610a4d82fd48304dbb33ccce72b4a1bc7ec1c06e1b00403c219e0d61f8f4afd3a13ae1e1897164055bbf5d57c00b7561398908e2c9c41940c949b53193a718135f08b3c485b277167701b7e1c7eb394ee2f19d12d942042b734d0f5d6282f45422c09b3a1fe2fc9677d71aac6ea7709b35471a94bf2777815299fe551bd753063d5faf8702340e6ced4ded6ceff8d6d37f570b2810b3c911f2d87340a02472b747adca3186aeec4747e0122ff5a2d14d076841caad590a3c82e8808c9241b698fb2bdcfcb0fe0b45395bcdda9e136da04babf4010323f7b7a182af808309d3c1d6ee541c5d45c12acca8cc77d31b74d9623416b97dd94e523e8907403d46f116feaee02da784b20ab7ec837acd430424baccc98a365c643d546caf1330466e91a9e368d36a22a15b39a1be076af5d5be0cc8c503e7b3606dac90f0fcfbef4f37adbb75d4619be1431dc7e495fb89ffc50c839c3edcd562cbea6977133b0aedc660649b4459aa122410d81bec586d7fd2ab2d5fce28f5cb0ebc7d86fed0a016d1df14ab1aa368209dc69e6bd59179852424b46aa64c759220ab54d1921a4f7f74ce303ab40b4c19b76de20ea368a950091d78060ff1aadf4661a1c40418568986be779f2bcbb6329a619504902319250455611fdd9d9952d7ccf40d48cbc415f09e2a52a756dad8128809259867518a3322b8a27016f6e1446d87121b8781abd46c0a3e7d8bffeed93eb0c089400061e3844087ff8552f5928f87f9a81dd59220db66863be1c62f1c892a95371d23bdfab2df5f8df829691ce60c6eb12d41c98049719830d2e811efca852ebb85a2cf512a57c8e402570783caae5abe92f407d1019f92ea9b5680670d41fa99d92dd081a2f34ef24a9a22da4f9e11d0c47ddd3fd1dd63e478c46a58f30a3c001634483ca8c66c4fa6c572b61fbc632cc3bb89fb96f6df3d84aac2f972f75600c712e0d131d0c2e5b3cc7a6d073dedd3a7cd91c2f31dc8078cedec778090b8faa3bf9d556653074f746e75a400cbfd696f0e9008bd7ece968487cd9ef7d8f387667f3faac51e254eab530b994b85ed60a26253743d921621522638f0e57d84cf6e9a1a9cd5a0f548016c2a7122bdee43503bb08de42e4b6290fffd6ec3329ec81bbaa088f4d1cdf63f4667c023e3eab2e6697467f757ee6f7280d06a9921d918c8c98b08b40540997cdeb89e9117d36c8fb81c4c18d004c72377c0dd240e2ba4fc9b1066514f40eb764a387432351d851cef9d615d531bf5cc5657e01acb485f88a91c95097c9c84bf96153ed96f334b0c6d5273ca5e47c24fd6055266c3981d30d61172109b92f69af395cb88af0cac8d2b878de54193771a5421c8c08bae2e71781297e8cf687d65a05d37d7bff18c9d3bb40d45c617290b09e9187c03499a3fc92d09c7b9f37eb9dbd22243577299639a742d9052062133bf2c84cfdaa47322790720133c5bf9bc62f5ab6a25842b3272a840f601fb2111681aeb1d2d2f66a4e5627a1323e16556a7a29f20d570b5812c202a9785405839c92d46f774b41419bada5c53f8f2d3a10ec19d9fb34d0444e31750f726b9e6a0096277472cfe8603cdb8095b497513e23adb6de714c950d1788988ff65043403bd21a530755ebb5865562cfa80c66de3c5f1a1c568802d0baf42ee8e655d72906c63e6d0372cbcf1215434c3fd0f598a2ba3ed3583b46f3c36e86f8a388598bcfe20e15becb857622957a4e243c5104ccc5435d0baf4dab088a5b6859a85155a52cc28b2dd61aa3a0e3d31b7a3b91bfbbf5d74cdba8244913db7581f8cee0505539040f731b8ff9d9bab5b310a9bb96f4bb9fdb9aa51cb14ece723686f1cedcef4bb6490d92fd33e0d11e9cbdb569fd4719518c82f5e5f0fef9c3a9d44992fe3bb86fffc579c2842de20e5d8fa85e37aee0edcdc523a77c3014913ab1e392619436bc4a196708a0492ec733adbdfecb64eff279e667cae6db919b0039faac1941d66c90ab662b26b3e908f6246e9723ae9a4d55780b86d2333956ad56d49531617e5e7678d40547aba899e246a22e2bce91599ae5e125110bd57d4dc19c71a53cf561bac6fc4a350e74957d2b89b8da13daed6809e3d1f0309f81d70f52374bad4589d70d0f9897e37507835feeb1d89df53858950d998eccfab5eca108c067cdba205a9c4f18ee97c9bdccb64bcc0b7c8fa4428698fcf14ea7dbeca042a12f6c30ce5f6be470bf9d1f56b9eccd76a12f53671e2b3dd6816a8db23e30bda0c7676a4e5c88dadb7db10f8445096def6560e3f7f9bea3d8ea11c3cbc859a104a07f8575e07cecc73ee2eb8284375b487965f3c825105ad982bf43fb8871a5643f74b38e5a662c279fa3266f874fa4dda48539ec3c2085fefc6333f415d5b2a880ec08c69875d3866ac0f7c915393581b881d7d7d7e729ab7eea3905d9509bdacf88a2f3bbe7833f4088145fec5f1eee16b9ca9f4d5ce4ed2f87aab9af556c6c661b17dcfd98f5c1a68f64558bd0544818aefe7a0174c36a67426ac1f0dee24f67d72c9a677b33feafa857a144ba0a211775c6edd1fb7f36e68c90731bac88fbdb7d655c34dd57ecbf3b6201ef758227b0fc57b0271fb0586dcd4439e5a891e190d3de5fb11df7805632c445921f42412426ae7015324f7c2108ca3253863f9f04c7e8b99a766095307ea04bdcded7e66b3f985085de9b04b4a91ff01c0590b8e3ae5b122ab93afad55e5eee6890925de97913506a28ff13cf103b8d798837bbcce5810ea49802ec804a7c5a68011a902a4fe82ba97f44108a466021481e7c3253de40f693ccd3c98138fe635ee969f27bd015c4e225bce274cdb6ca25fe00518884177469d2060f88b1637947951ceee9fd196cffc41bb4bdac28c24107609a93e7f15edb31c701a29da23bababd9a3e05d5b981004c6d1f11196df7d95e09609774ecd95a4513c9f4c78a984d8507b37245b054ac6ddeb984ceb13b1bc41070fee9586dda6ac86cbb764cdbea80377c3c1ae2c07ff18d686a3f73876dc13b772292d10d029f183d6e4df3738ae4a9e600b933dfd714f1f37bfec6d384c06fe167921b1d09c00ca866ac02db22f5ffc1d86643d8191ec5965761ddab0bbdee0dbaabaeb6add8d0214162b18493821acdaf804310cd319a1bfcce6e9abc0ff4332a5034737ee2cb001386a0f0b23aa75ac80f6e79f4d9ec1383ce2d9dbad98e61bf78fe608c4a0811b0668c6e1b934a4fb31f0737f85969bbaaf61cce512f86a44111528968b3e67a0d1f417e13185f6e137a063994b905c7906ba3d96bb1b049ec6c25dc3833f06043e9728f605151e26920c45584ac5c9e3b1b759c2ed5ef9fb3105a7d758bf445cf5a03b2fd5a55dce76f54342f410b23c46ca36997e8fffaf571b837d29fe4a08a96fcf0973d56fd9b7d6937557e5f0c6734d8d5ddedd8a8f7db257b40da6fe499cbe4fd95ec31a168f245377bf36acf5463bfc19b497e1540afa465781772cd7393e8788f7d40fac8426ce34df0700a95d19ded23a7fd68d0d1e2a19a0beb87d7ffb8310c5c3d97219aad3051db9d1bd84041a4c839bcf57896dab90d46b3105d758b8dc9cc9b54d8f9789a20103a0c602233292a72f703ff738de4574e4f2605dbc8711c891a9bb13f2fa7aa1a58de383a024c751548b5b5973427492f5dd64af6c76cb5611dc6beeb211428bd1b99c64aa1faa959c2443d88af242e5ba2ff1e4183b48e7ddc5d4bc0a57f9413468864e2363a9dd9d28cb3f9bda79a29b36e56123ce8bd9d766b5dba57739a11c3dee42577266831c49f5fe968ff558e5e67341e8059526cb571fd6f9804010edf643440431d9448d101769387f2873251d9439807120a37435dad6a33675ee350c95e4beaf17c6313062a2f935f992bc70fad9bf2b91d5befae77d0db0b5380c743e0dd1147cfc1bb766436cd979150f72c29fcaa4962a0b14e16efcb280177906344510301499e00a3aff03db15197aceaca1ec7df3a121c9aef4271b158988afe6ef07c0dcdb3943295374c0ec90007c7de4a34d6318f60d03bccf9a94ea69fc30794beb2cc46e06909d216590528445a75aadaaab9362886baa64255d5deb4a51a0b29643d7cb0b724c868495db5b8944a5e3d7a90032e2e7db1a8cb79288c1dd1c19a86ef2e09f6df4d005533234c122bf3030abb7a29599e40ac06c7ede92ea039ec28428154d1e69a05b3257de3d4e9718037d8e7b9dd70334d1ba765c668e3c0344588f93c84f0080219a3196544920d69bea22da31ef2167eb60cf5e87a2152022f0fe5ac5d66ee74b2a4c5291e21f319fcea6a23ce0db293a034767c1c21fa0edc8995172844428b37e03082c0d8cf58ddbbf5a51315059831beb6880326f4872669a8b745c3bd238c6816dbb15ba2a273ca3565e8f451df9ce02d9ad48295eb623e6e94662f6e2f1a5099850df57ec666f9d44ccbd237ed7ffdb718ec00726f2a8b41c3274a66994d8e76206d44c3896ae868ef89abb3462b421655dbb8ff32cfb85235c760019173c09531fcee380525cfdf647001de0db183a8f264574944c682d264e7b7413ab123ac6e4d711cb6e41de22937283266cd69af0da9b6dd9578eec5e98a330362aead6e9bfae3fc429c6c25609752fd47daa6ad3f74a400158bbc076ad4a18498275cc93a596cc38ef801e0a07e1dfd77fbe893965404b42f7b632259ae0cc433eba387f9df4cccb85c85aeff7f67081633e79cf18bdc6de456bca4a47a2731b6806055df7a4c5c8a59959841c4e8b6ea13a59768146d092dc785f60597cfa4d116e1a2c4fd4aa2946c47a261c2afda1eac06bc16b75d26372bf05d7150d5d83833a113f6966852861630a1eb5a0bf287a3df75d853b2cf7518afae01d3612c4be92ca785d081684ea78bb7abc5e83f3e06257fbf26d727a4f5e6dd2643ff885154b68e9e6a028262ddd89fc2517c1b555792100c86bf8f6cce9158acb5f4166db02f5cdbb7b56eb5c954fdefd7249105bdd719322c34d317485e1ea419b91d72b93426f2935a2ba528a2cec924ee922e8d30486a7a38ddeee93bbe2d7cf5a00ffd9fda9fd5517e982a1471eed03c778607b1a9a528858f5577c77e1955301619f60460dee45e0cc663f183eb4a7f55edd3ca1f4023a75f6e106b1e5918d8ae897dc81a851fa19b7458b8bd25cf147f2b733fb3c7da82b9d4c9dd2e9290baddcdff3ae5b40ab438262ba2cfa045b5f4ba8e3cac86c554e3a24cb819975095ccb4e02226e51fbbc1e6f4844dd312aed75c1652acc2774105351514a8cb40abcda10da4a52fdee4cff6930133bf2ddcba5d82366ee652fc8f7369618fcf1b8739b7a95eb9fe52c637649a2642ed775e8f053a3b7f3480f1aa26b43ca4bcea07dec7396fccde9a2075c6cc189a45a4ae267151e3f8e18434d280e5b9768cc047a5a626bf4c28c8b8ec6581291c253bad166caf3599cb37cc5301db71491eced5c76523e11e28b487a44dc57ea78c634969108b6a358474e30d30455410e91d02b30e444577f9099ff3cf53b12970e8676d7dafc9baf8ac708d07069caded8ff453e9b8fbae11ed01a7b52b5d1b202bdbc7c0eaf677da167ef5fab49b2c429b11ecb9beedaa96843516e3755ccb95b7d67f34c2597d3d995709bd4ee84ee862b246bf90d3394e654bca597680916041ac9494a96506251330399697b361b7529647049639aff78518cef60f02410f29acbf79bb858240b7147d1df390cad39a712fdad9240f254874b593b7be8411ec41737fe14045dfc3d10b5c4505e818f51a944498740785e02eabecae2a93f8c09d231709cd4343a298b3e4fb42c6314de1657aec04673c7e4d5cf316ff76f3d1331e032b00bfba24e9effa823e5409c1485f2718bd35ee4f6fc490bf1c30619d3369a12b99ea7a6269f31b4b361de656a7c5d6f74792d8ae2d13dab42cf7a4a015a8472d3df6265531f772e7a3a02f02c18f545cbd4f9b84b8243f258ce163b12dee806d294ec4d6143d02c7a63adcfb6f789c26ce46093fce3d976b4fc93808af0608e0818e16f12e8965daf0819c6255c197032537a1b070d19be91eda928c77e1fd814495b15219255e85d04ff76a0197f6d8e27ed39371b8afe897bf00a375945071f4f6f47fdb63d3a8f12e0262fa516a5487dd0496f05e05</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Artical</category>
      </categories>
      <tags>
        <tag>Artical</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOIP2016]天天爱跑步</title>
    <url>/2019/11/14/%5BNOIP2016%5D%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在树上有一些简单链，问每个点是多少条链的第\(w_j\)个点</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>把链分为上行的和下行的两条</p>
<p>在上行链上，造成贡献的必要条件是\(w_j+dep_j=dep_u\)，u为j子树中的点</p>
<p>在下行链上，造成贡献的必要条件是\(w_j-dep_j=l-dep_v\)，v为j子树中的点</p>
<p>dfs，顺便关于\(w_j+dep_j\)和\(w_j-dep[j]\)开桶统计即可</p>
<p>注意点1，当一条链两个端点的lca恰好在这条链有贡献，会被算两遍，要先减掉</p>
<p>注意点2，如果链的起点和终点都在子树中，lca以上就不能算贡献</p>
<p>因此，链的起点和终点的贡献要在lca处减掉</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>注意点1,2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">25</span>], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	f[cur][<span class="number">0</span>] = fa; dep[cur] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[cur]; i++)</span><br><span class="line">		f[cur][i] = f[f[cur][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">		<span class="keyword">if</span> (e[i].to != fa) dfs1(e[i].to, cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="keyword">if</span> (dep[v] - (<span class="number">1</span> &lt;&lt; i) &gt;= dep[u]) v = f[v][i];</span><br><span class="line">	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="keyword">if</span> (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];</span><br><span class="line">	<span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s[maxn], ds[maxn &lt;&lt; <span class="number">1</span>], dt[maxn &lt;&lt; <span class="number">2</span>], res[maxn];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; t[maxn], tt[maxn], ss[maxn]; <span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t1 = ds[w[cur] + dep[cur]], t2 = dt[w[cur] - dep[cur] + maxn];</span><br><span class="line">	ds[dep[cur]] += s[cur];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t[cur].size(); j++)</span><br><span class="line">		dt[t[cur][j] + maxn]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(v, cur);</span><br><span class="line">	&#125;</span><br><span class="line">	res[cur] += ds[w[cur] + dep[cur]] - t1 + dt[w[cur] - dep[cur] + maxn] - t2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ss[cur].size(); j++)</span><br><span class="line">		ds[dep[ss[cur][j]]]--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tt[cur].size(); j++)</span><br><span class="line">		dt[tt[cur][j] + maxn]--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		addedge(u, v); addedge(v, u);</span><br><span class="line">	&#125; dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//	printf("%d\n", LCA(2, 5));</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, w + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v); <span class="keyword">int</span> lca = LCA(u, v);</span><br><span class="line">		s[u]++; <span class="keyword">if</span> (dep[lca] + w[lca] == dep[u]) res[lca]--; </span><br><span class="line">		ss[lca].push_back(u);</span><br><span class="line">		t[v].push_back(dep[u] - <span class="number">2</span> * dep[lca]);</span><br><span class="line">		tt[lca].push_back(dep[u] - <span class="number">2</span> * dep[lca]);</span><br><span class="line">	&#125; dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>差分</tag>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title>[SOJ781]天下大雨</title>
    <url>/2019/11/13/%5BSOJ718%5D%E5%A4%A9%E4%B8%8B%E5%A4%A7%E9%9B%A8/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="58d4ec37fa6997648339d7f4de89adcac204922a5ff8d9fd1e1e2a7dace263e5">39b3ab97ad2fe4a6ababc42acd0b026e76dd316f9b0ae48f37a5a806e53974f1d0afda32c22f6aaa1dc8fb583635b686d93c44c4c0d8c790d8bd526bfdc4d9def1cd55af94208c87bffe4dddf6fa8672c12c453599fd7a5d521d685b8eec6a6a63a7e082704d7280bc7fcb11a954d8e549e6bf3a1d032f68a45acd9ca5c35a230e0af47d216bc9338e485867b49d78b8572a9966b1b72a68604b8d7071bd6e3217c9b92831d182972157b9c65a79ca09de12ef440423abef8fb6d55a6a80224762af8c8e2224b6f5a08e7671afda49a5b830cec6b25dd982a4d613d95eccb4ad45bc01786ee937353599b40789e0784854aa4b70f7458c53f05350a4616ef158977492710827001bab6625ca0e2419b98b209ef36bbbcfa1345ed65f7f5ef0ac6c293e3b36e3ae8ef795a41dda3cbbe00bb84abf2287354cd4cb551a46d5d1314a48be8ebd2f03a38bfe52d05c5ef66c863d244d51d93aa938cf62dae2a6fae473171d228e0f588989b08f372792b63bc5f7956e6a065f24e8867e1d3b0bad40ac86a8e02bf06095c8ac85b0e3e0f66011ccbccd1266d83eacc5143b38b728d4a5e1c2e8733c8a381246f88706afc644886b08f9149e756265e77a064807dbadeca3fb552d877ee8e315a4f9d01b6b0c1b856659366f135d6bb2f00314bf8cf102bd232c77f464f33cb71c083f82b4606dc8bb85452d401e42b099fbfa6d50d64d09a119611088ffb2cfb626d80482101b26ef4efbbae3b8a80caf26d4f6be9de710a9a979ad64407da0d2b8a513e4f33631545342ed6270b4f4ef17dc1d301926e0d0eedb2bed91b90b6d2d252ee9c1a68b9a7a164fd8a2f7685077079176b63d8c57efb6c47901d4db918e08774b01e5e4cab8710ccb7c07d89e7240b6918b0043fbd970d321463dc8a71eeb13899ce2cd5ccde18a599421058fb1a2dee15e5b76ff5d87ea93cee3514f39e905f525b0f2a5c38379e994fe38425f75fa3f0cd140326bc247f23d79341850e7db62bc5c0dd18b36381eb0de9f0e07b32abd22e9b6ba6b4e9f53486ebaccf5abc219f483468b24bbb057fb656230a8b9b107ab0adccf3058a0da3c989ccce8f3595e4bc948f019586fe78a5cef0b609bc39ed6eafa787ed20bc1ca64782cf6dd9dff5ac8bf9b867d45a71a09e0bd64ff0de3d837e000dfc3b0763496240909bb5effabc749678457c40bef88d918d7fa778b4ced954f2a727cf8806af2c61a48acd806bfbb76156d9cf74d20ebed3e421c5c36c49ff2d75694ea19e542548bb533c92c63ca224684432177b1bdd57cdd9e09c17f51b8b85f839f6b65d50c491026e7a25c9b3729bfbc35d5b21aa758e1a4a0084bbb1fbc2fd0a4d64cacbcd1358d0a97cc1fd161ad7d62fed343f2fc1c5a014f0b1018003928292dee71213f858169b54d9a42a6c877e218ba01a3c216e9e6c6952c8c1d14fb4a28fc9986490af5ad337068081edcd8ae77ca1651b6e04f2d6790f0e1041db4c93c7e2a58886588ef728b57c6c2bd385dedc6b229f033159479e94594c68c5277a72fb913352a85bacf6f40a5ed7b5c4f8c9a47c8acc51382c5c4418bfe7fd6818235be59f60883f2a0fdfbfcff4d80352e7a64d876e0d98c7e88171e04029289113d3e9273aedce941f38705cfc6fe7049f20dd23d055675eaf344672008214065739064cca13eb2381b3c840e443acabb490697139f6b2c177c925b11dc3197ef882edb90d26f669fcff3fca03fa199032a2f496a651b3e56dbcd616cadaf2850adaf42fe8f9285e8089ec158ea8d8a855a224bff62a86307e4b37d15b1296265f7f8a6b88344322e5d561e43b8ee69eab4949cc45d0a0c5b294a4f6a1ca2d6d2f1a05a811b1a4ad40b923a0e8e0413c23c9a732672437d534be8b06e03922eab542573f166bdf21594c78f87cfb145aee6ecb485c4fcafb4ae4d1e0ccfb72da8b76cb63526d55ee69a4eac2767d356cd0032672669d0c31e8fe59bc885d72c87c911761ea11b8e70a237264900b0d5445556e73e5eedb845725e62a6994b18205cfe31a76eb3a4900976aa8d527d9e88b8fbe982de8754035fd7f7fc708e9c8bd3d6313c795c9e566d1169270613d21163cb7c27f88074fdd5593889fd3f6994e8bf5fd9f2f78c05acaa7b91b69e5224715f8fdf2e84da6f16bf2cb6251b08dcafdf2133643781811953a7c9a870f1c80fe71e0249c71dbf4a91268f8103213e17a24e53b2560a5ba708365bcfb247ba6ef69bbaed34e0bc3ff818b62f694c87b0207ca6517ceb39e4a6a3e6a06d649abdba7659bc2c60f5100219e5c40ceac9ff8653ccdfa04a3d76ed0ecbcb50752f09a5c434bf8e5ffb96eacb678ac5b612244fb8381573d96139487ffaffa411bf5ca4dbbeec681afba604a4a6ee981847e9046f48114f0b2eaac9ccf9d3a5cd179b2ae1f53ac231063fb1f9e174a56a5759a7467266ad3eb1165e630bf03537f779a1656767733ea2419257b8b85bf223b66428496ad30c6d30ee11c7fd511c58ebbd684e4e4d72ec1c50ab480b07ef9ee660f726a09b28e78b934f2277ccefda28be1cf00ac51375be740f212b5df90bd98e6acf1a70d88d3462b966075b20ae278f1e917d82056a7f8a9607081d89af750077f9666f95ec1ce59555ad3f041e294ff1b5fcfdc7b0280400d3ec7d2f3c412b0bfad80a1dcba2101a019f95c06f979a6ac182d6d6643b7add8ccc8716a17f0e9edc44776974acca51511bacb7dba7a5ba0a1bf6092d0e1577f4055b1ffa1def204efefcb36b1e71b7848a9233b43c3a00c6638f2f05e009bf9b62d5df9130ee1af3404b9fc214163ac7ccda5fd8cdd6920eccfb1ff3efbf196e881db57bff5395ed8c3cdfff0d75bbab0b81ace33004c9fb434a61fa3c73b52824b78cd7cd3138588020a2c0bb95bf315a98e3b21795a80c262ea69da144d2f06d05bb89db6e8f1561c92ab7661f37a960abb47b0e94b2202ce6811bc8810565be3e69d9618fbc9b141666ccdadb0ff8427dc1b4dc0f15d79542a7f47b25e744cfa1b0cb78be86997d6a3317cb7458edda77de8dc12d112dee1e09564196bf67f37bc8ad418c5b51df98c53d7a3dfe3d05b581b76647585802158ad0cc6c2b8c2a68488b0bb32609f2939a9fea15b37dbcb7f18078a6af30490002a644d2fc35202b7b8bab69f2867980bd4d483f12cacafe98613b7bc098c8d27e4f3fb5c078625214aad5d2f59d17993823f28d400f1a9ca2c8a4d33df8bfa2fa81e245b4dce1ce8a7d33c588c5eb06fb4a0191794ddb01f8122d9ae5a14f2597cb5c2e5d215a5315d99550dd62570b746d544bd2ad2a15008c107ce4229fdfb633e57ca5f3190e0dc1e8b336386ecb64ce50dd829ff8693a789838ccbc05ff66678774b310aaf72fedf97ae0efb838a70db97c10dbb253a4eee13b70ae376c81551c8287bbd9a4c941e59dae23aa4ea22ea09223f8f7c459edd8b8ec8217cee7bb58fc5c63331adb5323c1b2f5cbf71c6f923f36e7de75ab7b3f78a53a3690592d4f9e5723316f66b3438895c036837262afe1c9049762019561224c250f1d65cca6ac500c003cddce6ce97b3965050351270731ece7b1f0f73f988c717c2558915e5a2ceb6c0ce1eadf53600908315103f16c79f15e6b5674365b59d6e3ae20b029323e162ed63d9b2a84c09ae9ea43244b86dd6e64e892cd464f9305dfeefbe04631c0d4fa9fbe6f378b7b8c05dd8e35a539bbee03c0370ef0752b95a815522599121f0a7de1f32f7ebef7829b66097ba5708f9e607f0db5133da2249d867302de3deb44aa5f7013c911cebd320b960e515f237985b775da7439fd9bd3a76fb4140c6e92f8098d725cc21f72985fa7be2e0615fb6b77851586703fdbd351d802bedc6d2fdd61c0b5c03a8756014ce297a69fe7fbf11e3bc73e4db94861a69f17a268db278f07bb3c4984f6dc222bbde0b03114b199ffb3bfd46776aea93e7db4b4efd54862534f3fddbd751bcb83ff6892ee60c50f9f9a63b1532502e24abfd54f1970a3d1854e8bee0cbdb02a641440d243af518cc6d21d95849dc643a2cd74b34ed2fd1771d9c6e74ae8d8baa173ee75700d89836e62b0966f05230d70eec553089128bdb8c95cac11c2aa8e70911808a96ec1acba26a4658ff4ca53a0b294d2fe6a6d617e5bfd9ef0d347a96f4b8b48e5ae09399164df94a50f2ad554e692b3097251c70f550cfcc0100dcbd01d6b0f0b53ac76e29a15a98c9b270e62414a1099eda4c935d94aeeabc9d770fecd042a41f5f9966bdb98e51e4b99ca41bee0de949d2328534f10d959984023dc3bfc2d79d8d660e1473f30bb9c09b78430793c544b841cb3bdb004e88412a532c6a98351765b831b9eb80f00ea2eb2e90eb4ac4f5c82912bc40ce8db610d32c89701f9ab9279bfe5d21b8466dccba95031f21f1a5ecf7857147d39baddc767bd561bc254317b66e79a1d50ec31f371ff0b47d816d28234cd116a7126e98af96c373c54c337bdb627e5b36516823b319e44f17a34a42390f4b99c2f4cb06eaf7c6bfe0002838bd30ffd02239ef191c3a33d688beebb4a16acd71691ba184441fd04920eda21294866b03754f126f4ecef9030d6a2457a9b06d6e740479ccea86e9c69049a59f712c570efd1c64bf4206d54c90588badec4f2f083f107b4975b2e3752d019c858425892b968ef1364e636f3cdb4ca63d264abb32000e02f490722261d024bf9a4f270f3e560c0d8e23e09a220f120c6031b67ffd00afd4e5e1db7c873ce98aec1f75dad6b47e7749558185c41715cc423879cc9aa3cf01aead451ccb1734557a9e187767b174edb78ff82de3f056266dd468bbf099fd25d385ba1581e0c1dee00232ecb910286fdb0c189f64d58d19640c32d9191a43b11fb82ef956538294ca7ec07985bc741f0b1acd95af7619b44c273a032e96aa8d64e1964a478f304fc2d5782f97c691f06aa89c66335bc62d6921f34ee493d0542529fc778e9d8e7daf111d372ad28b4b9cc448d51aff6e2a34ed4ee1c759733ef3135e59c57f1e8b2d599f0f4817b8b1dc1b8970f7e0b381008f04f0014b4b8f31c084acb8323afa0f23b98cc373ef2b907abbdc2395bc0d75969313a2c0ba97898a877cc5ab4f216ea72fe53dc28066172bfe3f6eb8dc02c5164ffaf5b5ef52430f31f1fdad8e025c5e82bb9a343891c4faee6dae7e598a2971716d50de69c9eacc14c4f7cf4c4c2eed53dcd3bef84a7091c669897e83ceaf7ee2be978ecf07c471eb35292fc519525c89375d3529ef6db480c812e9da36060b72c89e0fafe1256bf79d59a9dda6be037cf0cf357ca989322a0928146d29ded3f4d031f7c680bab70715bf3ccdc8f8a8d35a6b3408a113595a3bd0f2c2fc8e0c67e49c5d7b603247485775ba95ddd794f1956d3911560d15861beb83533333e790d653ec0acf2de23d1cfb2a9365d98ff5a2b9719544235fd41258d1f36ed1b55aa59f7c82a6b39cf60907faefb4099785d1442c2c892944dc3099f1e03bbab4692f988167e5d68c39cb8f8487e967e4f9f0d4a62ef645c791df155794d364669f9e2182013e91666651c02226c7cfd88c5c642ebe84e1fbc7419947e3143fb796fec7852f180362cbe623b7d473b104cdc2b26c1f5d76715381ba3325896a4c8fbdd85f89c63edd3d505813546c412ddb9af51a1b9d54fa30ddd2b2cbbb7bc734176fe82ce6083d262fc33dded12e87d5a396a252cdd4a189d5f37f7cbe65ec799d546723809cc692621b0b58dd0317740080b409d35cf94c3d2d7d5721bee7ac547f173be98f880d889ed23bcdacbffff0432dd6d0600f5379e63f8b75327f9e71d8f296a1bb4e25841a1c76254cc4e5737b85ae353adc6be2dbb4077248f5561e9ab78c151a3fcea1bf97b56d5125cfda141c8e11473849288a167cf68ea21fd13d37099936d3eafa196084cebe2c9be0ce772da22a2822f635a3cd4591eced8e83ff7309a9aa6ccc43adb53321523a613fadc41ea5fc3bb3b18e31103beea7ff454e83461fe91d06d0b8c8a6a96482922e9a03bce41edcea2316beba44f645cc85918ed527f93f534d0514b6d446656e51f94cefde8252b0119992ff6112f504a9471cfc0b262fb9f7f41bcb5cb3e7c4adc4a18ebcb3b43a028003ffb82eb394ccdda6ddc7545172f137faaf23d6448ceed0946c98f86a6ac585a4b3e6a0a1e1fcee172e628bb64da36e4399cd584b5b4f22b30b89528623b3cda6d282657de30bbf432d1761c47b505b1377dbb569d3358a2290e6d669e2e5aafd7a0fc7162f45e44def15f23ecf09c9e042b90571820a351e7e0cd959b78c18639895dd9dab3c4af391bee988bcc84ec598b67609da448eb9e550689cb83ea8b841ece809e85ba6a68a456d62ad06d28763c34894ff3b00e545d2b53bf44493986979af86ed758f17716c15d0d0be7e47623321bebf32614742947f8899437950e3627c63a885865493e411b40359c389dfea85db6e12552f680b601e6009105114b9f37db820e6006bcabcde2b841b8f3d11ff2a13a87a7376d6114e4b71fcf99ddd877334206ae18d2afbaf80e05bd6c4c062a35e5faf1549ad15aae0de5ed8423e6034aaa558df496b58705b3afb4dfb257433c933ae8ee5fb860be204406fbb898e81709f468ae333af23f1703b8dcb10ace868b8170d9d5fcc115cddc3ad43828e775f1e55cd2c4d05ee47c10c57010e1c6c87d43d640cc07b7e5207ed4c2d79b00100dd11b1f00bd876bc65a30ad283f2aa5941d90771644cd95ecfa16b392f9e8b683abd1a4940bb30680b7d1912ec9faeac98d4e7ebc1435a8ec4cd75d5a315f197e086e7ec23d7a72bc86e27fe78244073f234df90b26301ee89d12e0cd9d6522d74a910ad9dae7f123d737bc488a217649fcca022d6bf78e2e0c7c080daed98ef882b83dc088eecef4fa75da0f479a7a355cbf7d602fe6ab83697edda66bbce2186dd904881730cbf6dbfc746bfa950f5db62e0c8192a5ed89cb7259c8f8d3968151ceecfe82b6572b740a5068f714eecbb625884f56ba26a9d5e6e2bb38718f4b9ac2d9688526d009990593f24f26cbf226b42b8a464c40270266ea398ce67241afe280521b1b6558c09865aa4e884a675a273500f8780ec0292b95190b22a0c77c6a6ee3b96234fc97263bbc9b0d8d45087d7e0b5f8cd10660626099b375ee9de61e5d7bdf334a03f1b87decdfc4c8b6bf5455961d4d49c3c7ce90a6dab26270e997693d14082d363b43b47162700bf66861e8105bc9a3a48f83bed23bfbe86b8913e2b33ee3ec445315c947e8a21cfc4be1e653a94a1c53bfb722a6e3752e77c960a392f175ce82dfc128cb19f1c7ac52d51aab0e98c9f7d8927387a44d941398039af7e312dfd03ebb0df3b0e53cd192158ed77e10c8133ca9c232f58a04cd0a967664b05f901123060ec323680dbf1d1035728b2ad13bef7b8b4ef0457f74e7a5aa254943a1b2eb51ee827d7576a9926d1c142996a75a5d303f15e03b017c8815491108636e08ba28e6ff5d4951548247c22183f5660566bc7237c76e52271b3af6df6af59731dcea4c52e413b404204f37b45255fc99d078cbea321d0c2ae63f2d4fcd0b25cbb5605b8761067017bf3c9b765d6e28a388b2f265425d463ca1e74089ba459f0f57eb10161ab5b0531ff7b19b802b801bf459607dbcce5afc9efa54c00d1b32129622784de5d3344f40970335400ef4ad78019112c8cff7d6194286d6fbca5022bd3d0c5ab7767f9c890ee59b4862ae5461f84f51c82fd6990a24b953092c5abb10d3376c25a776513b325acd43c5f3569a5dbad07c5b5fc5b6582ae2d3b3c8ff194816a34e3c18b90948e779a35ddc4fc08850343e0e18ef633cffdd62fed227c5e5e005296879bc7dd9dfafc64069e8130f401eba1133d8608c64607d9c61719835057ee7b67b917fd9abfdaef35565c095828319accea3893cf51262cd81473f0cd4eb44aa1ae12d897f0b7d45582c9e4c35ae0b99afc9e74be8b1f7c795ba7b76eb985bdb7278b75edbfa19490e63396cb5d880c50c74020841b46b144f6a23b7e61666817ea20ae58df262bbd47e26c65072518a40b31b9b7d8c71cc6f0fc24d27f6530330f73fdf4fccf28fa6bc5a758b69bdb12373065f2a8eb9b74ab6bebfa6aed7c6448749d217ebec8c3d3659a4e9068ce7bda061ffbab3411cd34b7d18fb6158e0304e2a5859a31196d0aff56ba829db6c8e92a2a9b2d0ae358199fc7b1af809b0471edabdbe225a28e124f8eb66518f95779c7fb611c5d07589f591365d7853519f33500689a9a0bef66f493ae4044dd684bea639c89596834058708b8d273a29454f9e1c39ff998fbcdc7fbd47185920f6f8a9fb24da11ccec540aa26dc666537bfb588518ad7112f44591313bb37c0cc92829dff3c81f1e8463b5f21c7feebc4b11b2c11de111251a0741f47ebb4a9b43a5cc39b235ac95b9738a27370767d1874be444fc3f1e0cf5fb9c649c79a6769791fa78213d29ce7df82b127d035b3e6836ac64a7df79284daf31551f271be529f6a0d84bfa725e2a453733d92bc6a71b077ef8aada2046b11513430c4b9bb81f177d7ba5aad5ca23cb5882c8beb650d7e61c491e8bb549db29ef362c44a8bb57d6065bf2953bb3849964d8b31ebb8cf886d874c2d695124d672a2676c3a6591677c0efd4244ff12c92e41342428172a8180ba36525caec555cd3c1b1c9debe72b11888b711d23ed8163944c956d0601c8ca02271c366ae29d1cca810d5990672495e8f888c0c85b215b8ba1cdcca9be007852a6542aad873122c8d8eaa7fec3662196d112092ed035aeda29a1fe5623206e2cea3325b9d5e086d03ecf49979fba3f3c85af8568e893c1bd5a3bdf8da16dbdd9af64f4e26d01dbf21828fea00a24897832dab13901ac0ba4c039d877cf8239d639f5104371698a3986556efa33373745a69193efed8316e9cc315dc9bf1ce619c4d1d25bf9efa3d3da87a72cfe1cc75e483e3ed4b589ee5ea0230144b450968159a9709ec4a22c6cbc2083fb0221b3b99b60106aed702ed6ca2a56c8856028621581bb7a5a64264c3aff5dd6d25b8e30d4086aa6212a68c13ad9c6d3cd4c685932ebd7ac386ea87d5e66f503b8b4ce626ccee72448de34a4bf37ec4d3c67e8870ae279fe5917dce60bdb9f2edd6aeb274a388768a411600d451637917149fc59190a61fe84f97308feb595728d26f020ec07f78cf04a1c2e479b88878aa6cd822a511fccb6a98c5d06706a5d9e3b2982da47284e67045b683427e362444a30d8c5fde5d0b62fb90074801096891ddd0f4baff95fbe47e980cd5e849db322bd6d4a0ca0c7a1f14a830dfd13c336727b2716ace52661775f09d67f624067eb76accbd5ade1659ded216a53b2bb5b6c7a8c3285453ea4e9141722dd1bfa9659b963886f621502995859bf2e909cb640f8f5c9c061e0255e090a029f4e5bd0a02090065ba86e645e5d73388611442e7494cfdd116699bace7758881eb616c50359388c2d7554bc5196e6c993a6529fca9b048f667c0b7e7133322f6378092b529ed59af81f75d7c721410aed732598f9beaff514de164145b377b29f356c70d7e32fe8e18352a23643a425a51c9168d7a44d2964a36d03392c7075420af3047e199bb779841ce72f709c1f17c1b6f692d99098bc9ba390eb7fd09521355ee340fd9c881efdd12a9c786625fcfdfe2f578f258d9cd9e9c5b74db740bbcc76b1c49d35648a07c90f9bd68f1dd82c7ed0a6442f756ae19a32fe4c0e7a7ab7c8cd5d0fc220a6974d3d3c532f74a59cec3215559e8a06c6ccb9ae83f6a614f5aa9ec1135defb4974a489485c45e07fa97b7c2bf95bfe1601751b45011cc040ee5a8e8d34b690d8314a38b5874f6bdb01fb0cb9831907e4a69fb07c33b5d708bd1633224a2a8c9869859468751b9e934ea6baa227bedce7d0d63a67c219f132df8f033ca91c134ce9cbed46d208dc79ecb600dd3b23398fd2448eae0698447624447f158a2834682055054f887e2e29a63ddc9ffc75c8748a18d2bdaefc882c1e1717652b9f9a3b3b647778ab946827fd83e8a39a8b669a10242370894ee2ff1e3515783e4ccf99828b0d9aa74a3609764b23143ec0d187900aa371a9682546a7733d50e798b4a22bfec83ee980734ea3e64278f3a1f289692da5dee7314fc47735947ccf2c784f410d4950a0ce90f82365e47680badf5579db57d25c7094e4c2fec01bf7c34ecb2e98026415cf2233447049ecd810daacc4fd020aab65ab164b253795218dc7abdf9b04ece39ce756e80425585a9cbabac20cbd8a21fa2b605461ddbaf292f9768186c439ce6e4e7801e0aa0b42d6d01c19380efcefbe340fa76cbced14b99200f4a19a7983ebb6060ff8e2d198a2a29beab58119df9f5484bd9f96096a54732c28b7399b7ecd3e0d9515416d0a47c6d40e73007391296bedaff05f5d755be40543570e4ed29cf0e1b07c455a04c8ceeae21334ba9513725a427b03fe87efa4d94d3d7914d2f636dc344f05519c69cc39e45357370bffa93d46334d9eb387ae5ea799ef6b3e8b5a456aa577f860f087f21e4117edd1efdc88804725e4969ae8c7a41f6a0c54435fb75d76f864edbd156bf2b6e46834fe7d86799b74f88c6a4b7dcb79a0575ab59a310d411a5943103775353c5f6d23be8d36c712f6359672dacb9aa71c87a41564f7025433238b3702999a441f42ce076844ca466df15733fbf4c1c3fce6789fd4d0af32c209b308d14ca1c872e7eb14d298f30f9f2cbeb1431b9bf4ff4a992e95257c106eece143b25c9db88749aa7e6f969f35bae2586c254522155415c85dcdea72774b2c4ea89d46b78e5d549e5b72f679e8325ead2fe88e50063e398a26c92d3f43dbd0c733024ba184f327b725e85fad6f5af676cbd5a314eaa27ce049f345ea2c240a0110c41303349ee9948b2cbd0f4f6d18d476a003edc50adb03e53fb088bc844d549240cf7f22b0983fca51952c9abe04cba96896137e28c8d162f3929201bf190dff21b0f9a2f60cc818e794b392c7a736476c3d49bd4a40db9018c7fb3528654e1c798c62b1dcf8498dc4b2c18ea5481cf5212b4a3c8e5b5f376980b6102b57ad00ccc9f757ce4df1bde7aaf1b30324e57971dae5585500be687794fa746a915ccbc40ef67cd0ada83e42b9a355f6bd53726611e7c54bfd3e09d228a3749f9f2db9f5cae963ceca982639080dd133b95a6b52a1a62d7f36c512703164e0ab46adca2da2e7498cb3d178198d84003c38bcfddd372dc1242b83a0b32686ec56e2d40829472590c1d03465d9500b69d4e83c17e6b6e2e17ddd1ac7d9442f87a97e015a064e6db1ada23656faa8c262c14a0b49f109055e782ffb511b284ab0747979539d4486c0cc25b4ba5efd713c748929046832ce5425c48b8b84178cc7add060233adcd77432eed3295348aefbded8a8c491999ec3d9cb76182c5f878164ceb42b704e0d77ea053de51957d2cde4604b1fb14da981ae2fed800bf04d68e7e2ab74630bcf40ed234b7f551ce7537a00a4a893ab002336c7f69cc0a61c1e8adf61617a726f57c6521d7d91fc6e3b5efe1856dfdaca0956eb87ea64051872f8465388590f1415b8659b7bf09cf6e67d6468e51b490680d83ee9857d8324134bcdfa895f8ffacb3913d7296f7d8068525b6c72b652e0539a2aeafa63dccfce5d7174e78d66bd696cc2f1527abc91b6e8371730bc2427d92f206acc84a2cbdd77e1f079d7e9631b77028f70365638f39f355a15607fa222947e9f0a5cdb0fc2b59defa868a0a738d1ecd3063959dcbb92551d43898aa46830f27297f63a669d503f6450392c7a76e0a1bce4377a5187ac58734ff9a4a2826a437703bf3a7f31fb489ba5246ffd4240cd0dbedde054d3caed3c44ef21d87c5e44cbf83b5ff5b5b14105759b590d66402238027610ea77495fafb7c7d48f261a1f39b629c712dbc9f4a2f9c44374106d91553fb4d842d54b7f4ae06138cce759a703173203ae23cf2e6c10ac6f867f544261b1a5ab65bdbc0dc1f3e07e3d0bf2c874</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title>[SOJ684]降雨量</title>
    <url>/2019/11/13/%5BSOJ684%5D%E9%99%8D%E9%9B%A8%E9%87%8F/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="dd4545d98fd43c4d9a342a5cd2109bd6d1ec7b2ae6f91ed35e7c2ebf73aa0660">39b3ab97ad2fe4a6ababc42acd0b026e76dd316f9b0ae48f37a5a806e53974f1d0afda32c22f6aaa1dc8fb583635b686d93c44c4c0d8c790d8bd526bfdc4d9def1cd55af94208c87bffe4dddf6fa86725899073c4954c78c73cbe0e758c11b421bf790cd2bb9b8f71a51252c5f3df7fcabd9d27c215c6ab35b8688ff9d1eff72ee9c59f72b9c7e4cbea9397bd55cc8ee388e5e1747150a8d25e6bc06f55836a2749f6075e9184e044657db71a24b2a28f46743780d8162c8381a61fb7c8d455c526631186a6aa32f499048b3ea1ec6ad44c4a78f45ce8c6f5fecc296739fe000dd8fddf4a24c989afa0ab8cc85e3dd3e74628d75dbe5641c2935e779fda6f7c15eb8d3f0ceeb9cec268bf358a443683500f9f8ee92641474d9ea4dcd62ae1513345394e1141c6565a62e7099979558bc1a9fb83fa6cd130406b2cc0c34f69913a16d109d57360f7ea39f0b7cd1f6e5a2f50a7a6bc526bc0f652de060c3f5e0d958698123fd03acc30a6eb2bc1c525dc8959a9046080775ede5172d38aa4e73714243d0671f95602ee6f8874de479ac69efb423ff84a637e1a39c97b9d51a70178e08ed32308d572333976a2c0f40892807186e12e6e333208af412d013cbd32ca2216f042973bc23c479b346263de409f32d86b6d2346e4a5f4daa3e63d0a56604ce6fbf0e941c430785452649783cb234ee1cb97b6a33319c0a49eae40ab1557f679004f0b3cf2b0c4c4802a232d28241df1292c3fe23f6ec61ac59774024cf3fd3cc72a63f2af847f350b47d606bc436ae2192f16181f9c688f21308b52f552c72104f5d7d986d6ccf29ab824e88aa0eb68fbe8df3ed1ad2003a3d28f5e41cc8ae46c528fdee6ece954d565d2fa0c047978b21cdb921a031c11757533b183b53f64bd1b04304a9f2776bd38cd62ceb8e2dff6adff3fe041d8e57f2a469016afeaec9579511123fa497fb8a97ffc829b59dfa4c0198da2a40122cb7ba0811de1318fb5b0286c0d4870694005096681775869bc3e8089372bf80734dfb2ff0f6c43e505d02ef8bf1197611abd1a75b45d9efe2cf7fb2f4a0a555786629ba9ae8b9d0932aca7151a95dd31bf0fd25dfab4ec109ad3ca0f7751a6a606fc1ec4d6f26c7c248722f0adf5d796f23d133484bb951dcc883d3336f7da02e763c7f71107f9e33d96d48fdadc1cfcba1617e25916bfd8701a2e42def3d1b33ae8e5b47c92c294b3d5da0a713f030bf727d4d8279d26346dcc868b8f344fbb4baa91318bf21558fa295b9951d42e4bbb72b66d6429cc7b91ef0326dbb5436af9af521b65aa97b31afcd06bd209886e2f1ec670065f7a1fa98036dddaccdd39160821e01e8549585fd0ba3406b236926a66c0eaf128a428327460845f043424ae5a0acf49fddf10207ab4fa2891a86cac2dc83dabb4922f78084836c61d05d4f3d9db6fedaa827580898ad3b559275d1b3bd0c583e83fe36ee302ff0fd9161cecd08e00c9dbb4751b6fb1bcbb1be2d760d69d5c13a8d15e89ffe14123b63953bcee56b7b3835c346f454003398b24ac9ec3944e101218de04263a4b231731ccd4433cabafea6e1e8f2a722099de43601c310ed8beffbb3b4f9b7601ed81363cce5331fc8d341d5ff08c00f798a99a6de4961e507568ce14a15e9882b428bf4ab0cd9e72026b74c75a2169e3bea812285a501069e2fcfad6d43bfbf16a01923fd1e25f3088450e71c41f971b9997c8f9c905af09e147f67c964f7b4859bb80f270c19043a8c03c5f9ac97cd99baac5ef1785b0723883b88c397493b027c31af4889debfed15cb9e14c4a27aba50610083564ea47ad7a52856e019df9bb7d72185e62d67328165146d18defaa1e8713a9ca7a476ec828f403e48f43359c9b8b956982aa79f2135838e3e3903120816e24d6914e432412870cfe57134076ab63ce6ced0cf81c58f789915a872452b319351d82d1dba03b259f25091b60d757c35f5fc3ef1ee780dc7608ec96f4b3c080f6ed7fd2b8cf9d139584caa7d15ff961ba93e560559529994054522bf0f31c669b0cef35658f23780ac77b35a0f75d0b0da8994530c35a40444149b831ac62323f455bdd32704d918a378d44bab2e1a7ee06b4efd731252ba8fb0857d06fd78ded1d8dee98bbcbcfdbd324268b4e881135e824c986d59085ffe71a794c6a017358a3763bc4436aeaf1f336201a5ec4524873cd062666cc835527867600668584cc697c78f3140a93956ae2b5fa2775c8c78dc246096d94e28e626d27388fe57beeb75fd6c9ea300ef9ce3cc08da6c53671d02c461644afb0af5a0281965ec5c7be6901d9d09e487887fec294ca6156d7e2710eb47e7c0d96d1004df303f3e6084a61a85e734743e9fedd63b31ae680d79836e00799d773c0718ac6e425df8df4880e0a23de7c86eba6d740a106ddba9577245577764eba2188b762fc996c05080d7fe25c45b235e36fd2cb9de3002100ff5b97a57a30454ce737e31c199b9997f0821b941ede605c27a4fa99f3abbfba24833ea8963771c925fc4edbd38d11523eee347bf52bca0319bc1a93b676d0958fdf85b7e778908cf03943fa42695c761bcd04c167ad10f0aff375071008c8f6c38dafaf165cd339d469eb00e9c439cca298c9f1f9f5e88320fc89875ffd644e3b30515295ccfd65be351999a7d76748c7b1e2b6e1dd6fd34ede1f66fad0c8ab3d98b87d27f9190fcc2e17fdea8fad7dc9a7d138a2469b4c2f5af51926121fe065081bee9e669a3935c5d14c91e1f4917f311c2beaa2c6650d7b8a93b1cb9ac6486077f86792c359ec1083fa378c1e27bdc95a0bc5057c27ca58e9cea35fa77619df3177e0e6ebf0f789949a26bab70cdb7b9398a038e36cb66580e884bddbbe84604e9209de927667d0d044785fda72cb0346b59ed6d0820c50e83f963381b56323872ce7ef713bbb47498b5165124e1ee656b9e1411ec5e54b1213100a8984a8c16c315a59daa10a899c3ea024c8bc993240456b61dd80b49f83a0d14f9dd9a3d578d1a63264cec5b815f5d544434e06f2e423aa0130cee2ad8175d3f2ca62b68c659473790b8a79dc7f6a2c0de5e38e666379ab7b5c7731c835e613c3d7e644516b6581b419646c9051ba8b1f93fc62049f2e513dcdf1fd1bec6cb9ca9048988fbd06fce6a53633ce8ab641f3f27dd2d7c7b81b1531d21dd81028f4cdc3c3988fa5d1162db320a45b64ea481ece37031256d8ae5b13430f28caffa613b5ed8027521010bb43eebdc13e57fbabb6a68ade407a43190f73d0cd316d679c13f6ef0ade5da14183f912025277499a563b7d82a7c077f480c8a9f766380595e68c9a069c65001b910ef1020508614a9bbce4118454a0ebb53ae25410810662578934630246e13b5f22de92e0f9142a5913391555da20032bc901ac0aa0724e84b9444c02282e9c81f6a5946d4cea203c0c0d39107916b1c4bf6277ffb7ddf5fe0e79dbdcc841f2ed03117c63418adad0ecce1a9655763b375223df2f81fca9fdd3d1f8f61ae712133bfb6bfc8171cb8a7574ec7004391003f402df601fb0f626d75021ab86092e50c6543cff88b3da0bd14d73d93b0c4df98d9216e2558efa75cd42194e8c2b730c5e6ec7481c8a28b8b1440e478ef35b86e7452e7eebb4fbeb607391746844777e2fa8f06519fc5ee956fb4c6339073eede5ef26fdb260cc9bed83ddd9effe7e26a09479a487a7e70da6dea5fbda4a30f36bce5ee64e9bf94ad296f05ffc37f3533561850422836025865bd0581db94dcaf9b5b502b196ef379c50deb5fa18d5ff562915052809a8597b524ffe73217c770715915284c8591951e5a0f03cc339aa85fb9e5ebc8a23dc0bd37b47a998501182a7dd5ff39c289a3ebd2fae7cb102c62a43e1b22b1b689dc61b8882484bb4472f6eb3bc6820cad2a6e6294db867db14507b7bb87136dd9c748a6e24b17affc8ebb55e1a3d37f1a61f8ada1485127877d74fb8f8cd81bafd08f662fb5f25533417662e4fc08253edccd8b688eca11437ef231571f21d8fce55b60a2f92281b3b31b0983e3c72458eb9ed052a60ee125743769a7885295cabaedbdc706e33727339df591bf1f565511c5c77569c882c7b329efb18215532723498f9b193edc4467ffe9dfa748e3d009e537ec76ca1d26b8fc41e2bec9b3fbdb4c7f3a2f4a612535d17d6e4e76415bd6df58179974107c2a01eaf4a4cf5c949f9e3967384e7acee8d3d9b5e53408e2d27f41fad2e13593649f1b531de6b02288e3eaa16d17270fa2385f78cad3b2fd0102fece68adc780f1cea8264799e951c510f492a02f1174cdbdaaacd5ffd3e8c26bb01462d2737de1b83cfd78859b6954e5daf2dfeffaf31b52f0a298d7de66d1ce55423bb1c1e4bbfb3e4173cb4783f11b828566eda2c204f703dbf6270a99e03f0b3e89b8c90842a887defca65bfaf249445ec86c4b914766595a5fc1d1eb1c80e1dc71ecabbcfd0cdacd155d9e7a7b95aa6bec7656288af9490da0b1c298ed6dd4c8f9726ba594d54db5e00205c5f7e83e3820d675a807d7c83172df94505f3adf1bae240135a49f6f947f194c933d97e96699e95cffc3b9d84986c80b974bb8c9820722bd13f9ef5287cc5d85e2fa9b5f03b5a20559a65f712f6623fbd88ac2b82326d3be14a1d61d32b840dfaf035dd725004deaf778185657df1072f78c03e25f2ac0886e27a28b018d1caaff6c83d80b78524de37899eed08df1a1715eebb466b44267aea16d3f4494af03f07e18c19cecf1f3151f69d0f76794cd61a91d64137fd8d2828c8fbab9aac0491083a6dbc801a4daa73b7dd6fa0a60b29068ec2b2292166b45e289ee718dd15ddc89cbd9aab43bd0458e9acd76172f74908d5a0c0e62128e832ffd547ee40ad3df380d3980dabd047fb316c4cf0e01dd0cd41ad4106eb790b5059e39d45dea2fe84cebe5bc450dd9750121b7a8ba851500f7491dc369711414ced6d7d4e1ddf28031e0a392716d32388ef00e2944183391e1757edc112b620f2650b4744601c6c7d256b66b3077bb307d6ae4cccc54f5340b787634b67e25e43d58fc3a315d7746b9dcf7de762bb2daabbac67449c1b557002160f7c19267c5728389450ac9635e96cd90f5c7a1ab281f6b3479d214dfb0111ad54eb180d3b1a19fbb4dad04e17b811c528c8b1368e60e8f722c3d5bc4c4f0056f4459588c5bebab3742e473cf37053c812f04b37de95aada8b6a593bd10750ad566c7ff52ba8e940cb1c1779d203153590c4298da736879da024ad01625b3c155423a37440b694b8d653d4d4a006fafdd0cf88fa40eb87bdc097d1fce5a3eb47f7865300d7309027fe08f1661e97f7008c76d37bfd2a506e46eaa10b966290587ad1fccbcd21a2b77da9984ab0492eac58c7388e5235ef332ec992ea65a8586e305e2909b6ca4cab68ff4c0f5421bd9fd22e99405798d2a61558c82b2688fde135c7710bc9a7527d590762e20238ef02b26a065fde445893a552a94c1aee69cf46ef2de9cb21a87a82169e58c9b64d0701f18fc9e5cb268a895c1c6f483db3fd9e67a9bbad726c5ef5bc4ea147fd655b1d6f1e08937c79e66282d73652efa6441575345fa9d43da33efbf89c60ef197fdbe73f849f0cec22aa28ef6cfcd64270566b4ea80f42bd5dc9306896ef032ada2a3cf1c27498a5ee1fc3270092e921d15c9852c91ead2a54bc4f6ed385ff1a1e4e49a69d03bfef2aa286537b7412c5f746f9582458c26fd7bfdd8f7112badf38deaea746359c1531ca552f5ff556e5ad10ff61bbed6879908948fc9db047dff105f4b954123af33089d456433832a0d20b8aab3809ae465f1cc4f9b1883383969667a1b3d25adb4087f643aeb2c8cb5a350931a4b3748a7fc1eecbee06f8e831785ec756bd22d97344e85e3f351d461b834b182f3bbe465f21e257d9f58d04ff58a7b62fb3d97f884646cac06b40294ad3e63b54a410540e75a8c38f9999dff01d8d435f2419eabcffb8a7475dc833f5f32a180888c69015ceb7240fe1a2be291f33be7b9af33e471c73611078def8edd3d40916de3a00eeb403a7441133b9f9d04def97c66887f68a37bb6ad2eda6c7e428856ce29b0fde09a1d8bc200eb0ab15177185f4c8fa778abab0d16614967886f9d049c2b02cd02b763ae6bda6bea3c084359cc204580fdba76d7988fdf899cda3b7829bb8f93f056f98da63c718155dc90dc21454b8787e9465c054b606ec7567ac97c847228651cc7de8e1a2ebf51725e5cd5046bfa0e030251df22f801f01282d529ab33febdf39db6ed8972edb42dd5091ea2a9685d2f30c963a252a374f9fc4aabbf729eb4b8af6e78246d91f9ca27d6a3e7dc4c70dcd85b9a8c4ee34664b0d50995252551871ecc97a77234291341d837fec19805d51ffa7df397d58b892b5d9737937173fb16260176ec8800b852a2ea5c10c4ec2b64b077a508783dec7497db7b1fd33456b7bc31533077ffb794708b5dc8f6a0dab352d8ced39305fb18ee227945b15075466548c9fbe2de78fb4afe91be4140d143acebf6f7feb0d3ef8aeb75bbe059a44ada837daf29b9adc51934ef25fc53a626eb06bda568b41532552abcedc46f0b2a6233e5ea3b6eda3f90d638e69d8399db00bc1abf672faf014de5773d3662fb0b7db3f9b0cbf1ac25cc3b90446b6f32bbc31c3fbb6241a98d456f1859ff15b94625bddb810933c69335ef798672619b3886bd2eb4f0075c9b4e079e2d0f9f26b0ac77a63228866bc7a4b4216064470f9aeac80027520287d1ef772e47ddfd83ef25f5f9bcddd72bf85f19ee3a425a6fe9e5d6f8152275677df0e8a3923844216a243a9719a360302280e8e7389e3e84257ab3e27efb97d63bc2c5ecba493c9070f885c8784ba4ab8bd38d763a97381c0e8f4315b717ba1e0041bec90cebbecb2efaec448922ab936aeb13c39bf338db90fd7ae917d17b37fd45cb8e4d2ea958b3ed9a25e63909fd465f78ebcbc6f64eb67de12cd67811dc2062af3bf11ef9bec05e0fc07b565fae5fccdf0786a4a90d3775ffee42d82ffcb44c8165ca8f596ed79090f8cf722c08c0026e095c2651f9ab14065f6e5a72aef7ff393401fea482b0d749e87200e0d93ea144e998d68c1cbd6883dcc37b84fee9c297a6d94546c18ab0200474f32180b308793a69b73b4a617053d6e6f528ff366afc09cd12df0a3384478f076a329c3b9e9f8021b06d5da38593ae719712a8e6ad2d36fdce3be1f651c0c264d25d94e92de66087f288f70653b7d3ece383a32b5d7b5603072adf0fe2b9722f44577a38a5927ccb04769ae1c95e71e26af71008f79442ba305858428ffbd008537e613bfba6347832182346da026b58a96c3b8f648f3d0118cda6d38033c056282da18ad66cac8e6c7ce550fb8c6489417d183d752a3e8a9d6f3d6aeb7b3102f433339a4a5a767c366ed94ce9a500945574307dbab600314265cacab67e06182201f978807e13058eb6139806d43f5b440def4d2d07177d62d4e095f6e495dbe6ff640de568850899fd5e35d4a45d59ceab400b93646ebe80bf072eddcadc625ba15e9060b199a1c9b704931b0f06dd39906ac4a4dbb9644d2c4241d6030f47c0d5786cc8956b10ba01539c46d3872b57422271e7ab19595ee7fc8696d7e17899b7ac476a996bb2f55662ec5e323c95158c5ffdded1180cf1470b1a84aa06bdaa67dac7af0ed5e861ecc9d7691c39dce4a008c7eee4cd28d35ddba372650e497426fd60d9614d003c8f85d43d41805f830422c1812a6225ef4785c3f6ad66a7232cf9e3ae9e8b4f35dab6f62185df0c71181462615ce8c8a78d86beeaaded4d4e2cf30e08b9e49be3ca7b9ac90084b4d90a0471f19bd9fd3cddb6ba20babf1105f490d30a214c6665e2d7bf19895b318f1243e66a218ddfe858e43731716d853c3ef3ef05ce924003065d7dc68c63e12ef0cfc55d1188b800eb34f2fac517577c553d48e716d3228b219410a482035a6268191148110619e0e0bf359f3d22e3df7b8f73ff30b95c4e3bdef6b804c44433d8d8e91eb73c63b27e36d62cf0e46d8e9b83f7bd87985962e7f6e7d5392a5eb02b1b267f7b87e29ac932232ebf6c1ab56f291badf9764d2bb87e9f8a6596c7c24daa53caf3dcd526c29586b36043efadca1c32f6809f12f5cf04f970f95848723b5f006dfc58e62c3c682db786f4d84d23e5d7c53b7238710a78e0957dcb0f3b5c57d2c92f57ff858dafc786a5bc7fbc15321f554d15b927b56114a11865f1b4e1a884863c3fbf88d683c1b255ed2ed181be39284f9687046122ef0cd474444ef945398522014830145e44a92151dbc5284caf29a0a8ecfea066df450d1c07813b5ea923706f7531324418a13f89ed6fddbf8e52bce8f8fb49a6f36dd7b63bbca35c585f188c279cf8cff7f59116ff75595ebfa16d327ad647a26f352d4f2b6c1e3e2e68c08c8b908cd53f65c663e18ab273124076c1f9675da83609562b8c01d62ea6d10ac93d58b4dc40d0b6dd0f847877a46059a25d7b725869020c52c1ecfe380329bcf0e4a7b76b58207e000379a601183a4c7b5501025edeb1b577ee1cabe395e262a19d3a232b0c8e69c85bd42f592c436a2738ae0a6b84d402e01dd2891ee07927ccceafc6a6a05a88a23300c33dd47307f915549cbf57c0e20e2c62da66a8b6108d1b6ed86ea6e31dc0e854eb3c23ba8a54f02f2f4a6b7d6dc9650942437aeebc6f940024b5ea1ac9efac133717ad40feb4e695500c2e7528464a1afafdb2de8d0e6df4af7a3791dba038cbf1f58d2fbe7bda32970d39d6675d49460b567887f6bafc137129d407f87ef4043ae6bc37d2d0bf37f5d2318e2bf14f8b5f59d3971d3783f2522b99fe98587b81a46e74bdd0b5382bcf2d201a8aa206afac579bbb2ee3a3cc89acc40ec2514ea11404725eea606aafd8d05bcc0b1b20a8788d1a6f3f7975c1524298a20923667c76a705cbf9c48b7201d0975ad241c486cc537edc98ed69dea016ad54d615eaf90554dd9f8503309cd43226d06acbab9b982e961d77d972fa860cfa04ed86c4da9eabc34b169e549a04e458b7beecb433864330476a084bf16d79779d95cbc6fd4e193a2fcc4694ebcf30227623ff99cc72547af8402cbbe4203ec3a224ef4b3a5036fc7abd27ae7e8e7ffb90a7e5c72905530d2cfb9ddd06acc39cc7a5050215f6d22b6233d1df76541b124f37abc27309c80b1f11547ab893154a7ab09c7726e957fe90f16567142d624c85013108590ecafcc4c704a2f0aca2eef0fcbf251b8f4831c3b2246db2f7e070372512159a20c71967ba8f8b07f5eb42b42cb2f4ff18d10e45e37b298c0661d332f743c65a562ba80ebf26cd6961b7fa1b85b49cfd4d04ee9f623adeee6e4e8d83a4da23ef41f36c884e1721030e16021ce839e92ca5de758aca1d1ce46810eea3434f85212452020e82610e52dc480f328d33b941bfe1dd8ab045b34c2c97f54315f340a8bbf43e59db4006018c59678ecfb83d87fb16e1d5542b6ad576be0b180a8c50cde2372edf4cb9a6bb0682b5136a4cfac1ccb11faed7d9d194b0e8b2dff365c6deb2631fb4e331a2212c80e0249b8a5fc87d939df50ecd3408ad16a0b0fc7fff86ba4bb8f3800b520404f22a4b674d622575b464a3b80bb61aec6af07e81d52bf2dc89db58325ed45b8192c6d8c371bec539fef444d8a18b32283531893c6d23fbc64bdd8cba36f3f5fd989a37b29c46ee1045c8efe6feabbe7f0e9494bb283c560defc227432ea30232e86706cf725b97282f70f30a0c139fae51f36d73b0fe5b1eb8eff47e13e8345929cf49b0a81c7d1e7f174536ba1275bb3b1a4db8efa53a1a1400e010ebdaf3cdb65d926afed3e91cf6c83b008ff59395f5391e9f0e61e3fa198ce1d54376882600a6a848a9583b9beee6236722a83b42f3de5ef97011349092450b93cac524a90bc0f00a4e5cc1c5a740d38454a3aa8a18f9a4997c47e6834e6878764b7f22d515d0bdd9f57e979bae297c9012ad030616d3b9045624954cf3878cd1aa283a552bfc3bf335cf970b0a19fea6658c94d3211ed998fdefeb1bb0bc3c0866794f7fd5ea960f355059d96acf8ed2d624319d7c0e2d6ae857f59b29062c6497700bb98cf4963d6266275c69f01a97a0f29916667094a86fddbe83782e1b5797217783928f8d0e1fea85423ee50b4d464f03350878ed37595163c87a6baad708d1e7f8676e4ed8619bd9ae24aa9d89798ace052a57a466a240a6ace5951d9a218634d8da976bf339b66a9a1b104324c6174872d628f8a6765854abe149dea32f31205f525e2bc0bf0dd49b15e9bb00d4cf4aac296886d2b279767435e34d3a2982b0d37fae62f586b04a26400a92d980a9451557f24f282c804562e17075a9dd53f7e83e7df4befded7e601917a9d13196da366d131500f50427f7a96fa058c245cb32a1b233eda4e89af7ac19f027c65065957f6066d3c3d9e3e150e266b1b47c84d5459296585fb5569f0145fdf9a08c28fc14feb8ab6658be8e78343fac1cc5fe6521d84ddac9a70dad697e925b24bdb26cb684c5537f82484c778039df36f09512ffc19b0489c8dc792047b6cab6bce3bc3eb7e29ee14a5620f908d8ef25556795c3aa39dba46bf6353b31b89a229621cfbb9bb72ff6bb2f0c461d88e885f5c00f8d72ad56ea346ca68bb97a5a2e9d2f5f67ee6655a0d63eca3fb0b1c8a22346fa1f87e89eb7e416bf0c4f8c265160035056315f96a180eda6f97cd2509258766e0a387fbc71b22043fa6558783eda73fc593ca69ae6e65df3174d3245b2d41880c4a569388b7f909cb6ef002b94d6b24a0d2cec1dcb5e353a81861934dddd8eb3d89326ebe7313a7a21a3d0a7a306a6a3a0b1aff5186f95d6b9daac735b3258b74612a3121b7d87da822c9158398150f875266449ea918ed1a067f3386dabb271f6b53d61360f7e345f67713f44f4e4ce13778190afef48451d4415eb1b189d0d87af4587e21da0ae7f39beec0a1d8de5b7ec5ba2b946ab575d42afdf013abc51c512e2b95fa70c0122fa2f9d437d2c2179c07ef57d6fe0a7f99f6eb8323b1232b708b4e404a60418a64fbefff36c66087157440b3b3b10c3eb0e662ffa1591c2a7f1b4922d8e76823af815cedbd3eb0373aee1514ab83d54036b16c463a16d5df49eba688c634110a8c5bf4279b84fab3252790bcac87739f0d3941744d9ef5a5a6b4f1cc11003a06177ab29b80a38f56a5c89f950d1872174640027c69bcfe0a4eb31ce15fe5bfc41664b1efbfa3e35ee5cd2d3f43e96756e2eb789ee91b11a0a7c98d197029d4c07280f396f905f7a855e3cf7e2bddaa502c5367f8c7053f6c18408ebd2b334209bc2fb384d81f5cadc14bcc97c8128a7aeb6a501aaee6c8a13df02ecfa5877226e2152c86730d0c7276f846b8b26da527e7cc4152821a37462bf9dcb9d05f6a0d8aa69235f4dd249eb8eaca8f019d0bcec8234f699c49b44ccebead471b94a0e15d29ff52ae7bcfa8ca9d1e3d763ffa6850b72136cbeaf1f16045cfdce6aa8fe4fcef5d2fce487dd341c90e9d3b3a898f3d25970172491488bcd4b24c23c8b2279c8314f86dd4b26bc6aa9f5991879a90b98164ae8e6adde11a8f4d009f785410db517d23ba02545c550150548709b0384a4450541877f6ab88160e005f259965f20e2ae29ca99cc258f955aa08712704d03d198133b07ae629552d658fd17247c9ba38519998a7a3f94fc223d2cb4941e3f352b7830a7e6e31f95b9f473637a961a7f697998390f983f5697edb0e42587b617975b32d049f81615826a05d7cbd9b02e6d75ae1e3b74d73d0b0087f30a0b48853b4245ce74643a0e0def56d4b2df8fed23f1d01078f7d55379017f678359b06f539374e086476180760df22cc179e75b0fdbe08adfa941f26ac4ca80f21b627ddc3a36257d9d5f70ee2efa6348fe7572f7bea9abbe4abeaa5b221a9b6b70c56b815c8469c6c4bf92be32ad85b8bff4b6c15920461feef757a64ba222cd9d7d075eda248f713eaa0558e337092043024639ecaf4ff4d14eb0459d6b24ec0ffa6e06712c606f16ec16256dfaec1702508220a8da0b7807cc5bb62803943d1318d804be3f5434ca90fa9ff11ea0274a8aa29870c9b31fa76f8cb6b23e02cb1de9fa4b795cae989bff75086da0baff3d4d913df4fc2e4f1334b4149af4648cc08c1c0aa4f324ca67b5d2385beab9c8aac8401007ce16a0b3e3f45cffd880b14a7c1a7c7dbe2dff0aaef8eb9997628fbaebc2a3e29b57369a1b8100686d93d178f53e1eb79915c462351877c354017d6fb78126b2c88436ed7836a0da93eea654845133dce5bd6a0b99232e549f0675f84e0656496d3b5e68e60421687d008a368d712618247680d8538c9876cbb678a558c1f80b3767edfddde7dc0782c66ee2ddfd67289cc8b8c94849be25483910151464c2ac009a40888f30baa7d26a3264701ec890c98a1d9341c39d646fa6a29942438bc0dd4aa6e3efe7002e94d6faf03a095aafb54eb11a28c13cb78d7b199fe2c91b32bb865d72020154cf2dbd56a320fc6201d3b461c16a588476d7954a259115a6e545225f7964b13530633a7e636243e8f49253fece5e7d76baccb592ffa67ddc16f91670626121fd010cb041f4a7e06a929c63d3162dce62dda609399c3af91baf6587e198cfba4c7efa46031bc012899bfba7dcbb35f05924f141363b02a7880647671f4f27e8e864f976760dd7286e4fd3067bf27c03b546fa85c8b769b4205de0db13ba9f542aa7d73a8f12aae2083ccfabe2601adcb86b7f194e3347606d274691f829f837c304c95e0b51d828b21bc143649d416662f8993457b9e875d0c5eaede96e4d63a39e0d6874aa12ee962af0c641d77303a3fd612734664b5556e20600f6f93b6b99dfe3be135040b8429d86922696ac85b1577c358b8a934f18f87e4a2e29727a2bd84246ae649736d184624d99b139d044e7e973742d30a5c57e2575d71c341f25bbb7238fd046070f61d53a59114d4f4bc41faf8e3d12d0a47c5c4b67bc28d68608868662ccf1649379ef669be8170c7267ab97b49b57e33302204c886bc7394fe46c772c74c61077b6fbab6cd2c420c219b6c826a4049a754afddffff9ccc6272094ffa93b2a246c5eca25f34362f890acf340e2ad710339b24a961ddcac578a64df1f1c60ebd0119a0679e7c0f0d2060f2f3ec4ecb5d41307f117647ecb5a943d1bbd31609448d2433a73e173bb37f51a8cfac2aceae6c714fcf134c4a4feeb8cfbcbc578a667c4c9731050a7385845a78a6b5491bc08ce5edc2f72a3874cf697c3619d54cf3a6f0f0ce79bf464d5c3849f286b07aaa207ef4235f4c2e853494508623d2814df90c3a1699394ec7eef17838484a1ba8560ca6c7b212869e9a927cf6662874c75c5dae39031922b909920941b5f4c3173e1db6884213bb2f9c29a7c5389083f940c03879a1bf78e595febbf30f23c22fe12db3ada64ea07a5349c8e6f0ec383e0e91280c0644783496e229e814997c36333b60a8ec7bbbce593bc5cd3f5f83206c0d1a3a2a83525f8ee6aa1b80003be0cf5ff75ae35e23fc25e93671b46914108b8b78d89a57c791d38e026d3e6ae957980e0e9fe99bfd31ffaf363be951e7b732e53939c5898dbc8d758d77a0b016602ea35499e26ff3b704294fbe04dfc4742a8aad1f8c8af3db115bda23f5a91d5127fcd275e43f825af7289fb6808645f9deaa39a0978818dbaa4bb0b2419d556e6bd582e527c356feab177c7710fec6868f3f186cb427784d2aca713902c3e62218ba3c94a336ab2796b4bece82d74328667c35d56a76b1fb9d6ae86a58b43d2a55e34b5c7ac32f20a1c488fe5c6440b7c19578e2f2fab7b7375cccccd4692c38c6bd52e87cf84ffd977f0460d5f165afb3cfef1d2b0b97582804f12d7848d8f7d9c28eff64f82c1cd384620d9ea2ff532fa4da0e81d4f7ccf796ce465a0efeacc777692585b96f7cfc5a5aac58b24d11170327eacab6f4c3156f5d92bdaf889591f80</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>扫描线</tag>
        <tag>set</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>[SOJ683]蜥蜴</title>
    <url>/2019/11/13/%5BSOJ683%5D%E8%9C%A5%E8%9C%B4/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="9f6a1c6f404603baad97c867c5f394987065db76abfed47aa83e749eaf47382b">39b3ab97ad2fe4a6ababc42acd0b026e76dd316f9b0ae48f37a5a806e53974f1d0afda32c22f6aaa1dc8fb583635b686d93c44c4c0d8c790d8bd526bfdc4d9def1cd55af94208c87bffe4dddf6fa86728f258c2d2d3878c9870b84058377431fe7b1ce5afb46fc11d1ccf177e12530906791b86a87e85f88dc91b8b69aaf0cc21ad1d35212e7d062b932fdc13c3c7bb4a99af4c8e79258021a3453236a7a6625d4e4f1999d427208f46a05959aef16d09b5281eea10a177e37f229770bd4043663afd8ba9a621927417a216a9e81b7bc75d541e919cded94fbf88dbad551f0c2c651e7a4ba4836901788c9a2ebd077bfe582b185971c1e311ec776ed683176f741e25673277dc681ebcd358d46e149b6093c2c15a714e0538ad0d4460f416df52e65cc45ecf00b8bfa7d46d8f647d51acfb6a52ec38dd2f68346c2050e4aab7a7f32b7de374545f0904900aac7167fe53a293d1c9a587a5c5f4ed2ec80a3f914a70ce6355dc5034a4e6df4e042aa54d1e76385aa800e9a4f2ba195d062286e76afd5e9a6dc44b05226318f2e7bde19f032ed268fad9a72f5040a2b7ed9c29eb02521498b3cfab36085fbb32491e63186a0d81953209c1469db8895e638b306bb939c402a47503308cee1e26a945c9154e8638e83dbd7281a8807206534bc2e1ac02e977516ede5624263b328720aade7fa108c769b2ea488d0e5c7502712358016d2226891b965cbd511859ef3b57593ee64939b53e3bc12f3defccaa1b816c7a1db9b5899c3cb2a45911121f489f8ef8ecbee8956cb1551ef485a7e5c2699c8482b0c68eb8c6ee225f31c3766aea1e04acdd1ee0f1c36df804d976d8aee853ae0a567e1d40d2814c8b9dbe5b802def036aaf4e7a75577ae3445d57678b062caa55228f551b5a3dffeab813e561dac2e8b3da973d408a646c7394d8b8e1a21dc0d36ce5221459be489863df4bf1bd24eef5bd859b3b530311a9f6045fefc7b18870679ba95a842b95a2751d900cfb016d5275140e95fac40a71ec76ecf4c5e1979b2f59bd6d836e164db5d9108ed1d065e0119506ab806867f1efdf4f3ea7a169e5227d61b52c54a65698a89064a2632536a40066eb54dfb8d89416d2c5529b987400d0b873e6b924977d4a5afd82cf45f31990e89da34f035cb5346df6cfce98891965fb689d0b2797e31826d1b9024c379b2ecd6aaae1b3d1f082679ffdbc1ec49363cd675a43cdd21a76b70e80a87ef19a198cbdc1e185fb589f262d3d59b33bb5a3369746c22a1a0569a96c2f76d8f3622b9938f9f0c8c820155125db1bc44cb6969be617abeffcfb22f85828179c92943e76b9665002dc899650018d6b4ad7830dd5c8d9eb7a9ffbb6812ad2e2cba9ff1f25228c92bfc40610a2c7856ef7c551b764772dccb709c05b0741b47fd21e5c67de4b0ffe501259659fc040c59db86944ccc082b23d441602a8b0aae2255630e49cdd3c3c7adf063f551ef1191086b9885e8843a1566d7684c0df09f77f6f2e195336787f2e177abf7dbe0ede1560ec0aeb8d1fd380b5ee00f7bbd868a92b00d3d6a9b7ac47376064aeca6ce6b3c79b838590ffa129ca96e4f68c46c4fc7a90c4e9ee76590f65f82abedfa88002c6ad97258c1881e06ab4b1e64dc50fa0a1e1fc1193b18417178aef9ed6002209e5d60c15b3ac63c4d39b5d231329f0112200d365d933e27d60b82d633342be6c5b698cb16300ce3fb219940fb3c926076e7705ecb9536af43d9bd385584ee4d100a0f1751464d96fe704a2d2de11f762fbd1b02b5bb8fb85bbc7c070a817d80d9404c33a54c2de290978456559a796adec4649ee339accf8ea7f9b01bb357ca59c968b047815501eb91ddb653442d3abbafdca8e4e4daaa45e0245491f59e4b04378fef597d72f8e881ff563d49a636d2253c6537c5f4446ca00ceb523665bc4c191f24d129a3e7ffec57db6eaa5d086d060d9e618b88e60cf4b03a998ad8b356d8c723a638df64b7be1665ac2e209a90e9474e561f8eab69bbd75e8e68853b479bc0630f6666e90200b8108b8a52861c5e8dec19da217cd675dae1f1a734ad2bfb2c41b0e8650feca6be9b7c2b18ff8f811815f37f71f07d4f7160267445e00de23887b9c2717e9ee164ab92f636267b6b723f788d701d78a5ae668f95371fbeee5542b66ed5d5ff36c26c5aba89216175b5fe9067b0a42e3029e829a0c14a36bf0b2f62d514389f8249bad7cd362bd9a70e7b1bc658b07ee0d7342dd7325fb9b4ce9efb51c1bccfe1fe7b5f5ad11f00f728fcfb708a1022cd67595008d338fe2359d598ed7f5c593419910848155e95cd47542cb609470dcabfccf3f66dc8ed2100af1271f8f432d45f14e9749246ad281acc7e14058862abaf30385cac21d05226d4272cdc0beeb13d30df4e5c24851e2436b01f6234160600924d0c2d8389e74c4c4fb576e0f5ac6c5159b5de01c66f759daf01c0e903e84549b8e59d601f2570f738122f5c16f427b58e66d6c5b3dafc3811bb01b57ef36aecd05824cc6d7741a337a8917d66665d9e652487551b5ceefe71af1c41049d04987cc8232c068ebd1ac51bcd444b53d18df0d155446fcb560906c1a77e9c5a6d9ec5e5889a5934afc9f728b85fa4ffe9fd08b885638c64fd835b4054748fe6a070156b92b151128ca61ab5c3129d97ee03fbec8befd274cc05e7341941429ba4acb743f5720e7588c8878342698da5f4b7cb801b950c663dedf10a84c15f8041b3f35aca6159c49b00413a463047f27864e93542b067c1352d1c0e5f8df8e0e99a23a6dd98c2250c632d935dc396cf54a91caf9fa328c81419be3390f64273abce0360a0be6b0f2b4eecac8c26169ec9bfbcd769abc4e923ece94853e420ea2d9b63479e25874f422c490752ab7da32e8f01b58e2795450059b9d4c20891423475b5e34a41eadd7307502729ced754d0190f98d860f19ec27361ecea62eda9f81ee63c62efc1c47f703b9a2a42948215ca717d404afbf43459ed2bbd1b2196b3c46f1689ecdc2344197c44375b1429d4577fdc2a1992ed969dd5a3489242f9b154276045fd82f6845e9111d7c30720254634bfe8d8857e80c4bd018d0c543385685b7de59e731c9e857533cea8adbcf8c0724ccf2c31d397636353e6ac1f23e09b302fec1d2447043de7a1f8ccf1d346c00c5982ef0b5fba901b42e35dc6b4cb25c408224e4db50c6b92696e4b35921bd7b9c499f3ea0908fb64970794ebb11aef1c25db83e1eef88c7afb39d1881ad9ba7392998a9d3cc4dec186ed6df23401c50601186799c83a0fd0f47b156da742a85a7b6471398b2df21dfca870368ddcd32c5aa3d667e4dfb2f0c19b6332b330a3d7b40ecd62d8f54d7894abf9fa250e41356d451e42d7beb4690f06fa46136fb0eb20b5b128901f93ceef7dcc429eb4ed28367766d47a84878e1f47c05c6092f680d32af9d8e97eb0f5e260baee2a4074a1c2be8f947c8a46f000dd06f862c4edb842e2c5582e817124b0442b2d999ce885b122a6a77180d2c0f43e4f247b20523973a4ea3ab4fce5691f3861278b23f71716190bcdb69e1aaf1aba8d21486e95061d6c124b49295ef9dcd62cbce00d2032f91cbad499406bdda1cc5fd146f39cc702a0cd568766d01aa199747ab515839363e3c2e87f19c0c1cf76a848120eb8b347d09caebd254d498c4656d8d0b9d9866e1bec3c08c05d145cdd9ca8e9072eda05900a6772bfe183cc39849ff6a5d4eb640d11ae704814c9f090b92eda74670991ff8889358c6f498ac2c18fdac27445f355267e890407d3cd9d1df85b80f2ab3fb988e6136e5845f2a9ebcf12ca8f00e3abf7909202ed5431cb46f4480db4669c752f465d876be63b3f6694eff9d184cb2da3a7b389729fcaa9b9eb5d2f61a40959237c6291bda25c7af12cb96d81a204adc5168bbbaea7eec830a6dc7973a3bdd8b28aea4d2ba8a444cd71244a3945ac2d999ecfddcad53f4703484d7ceb6fe811488f6d8bbcaa6bd0c368a02adf728d679afc32a5f76b2adf16f7380d11dc77d700ec8000a8af891d69ba4a34e17e63eeb746b37e6237ec8e8b2cf9efd71f4e745084aea1028c830555e9f22ff1b791e724d15dc3f9b3d664593a3b98c822351a89a918a730013139ab0ecd89c7d5a82b32d4492c3ee9cefa21acff14c6ce0daa22ecac0917787a2766144981d9c1bb5fd137777303dbd2cee68c3a65fc919f5df33c660c6afd49845c0cb155347f643b54c45acb771cb3d8e4265d8978fe0e38908e47a037ae44c50a4d8cf3c0846cfab2cde4805f59cf8facfb6c15f8835c450a870a6a55fd06351967579d9cf2729277127d65f62119099c3b207a2dea168c552f834a3ec27c4094c0fcccb44a17385970ff311adcfbb8409d4b0ea879364fcb2e62c0cb9d3a6f6164c50ebb6a51172be42301bd04d26d7b403edfd97942b846d189690bd3226a35d8990c917f5fe411564667f6309463c5ebfdb6a0078621a7e3d491dccdb0d165e3399995ad6bc65cadedabfd22ecc3ccfd6f501053b423a72907753fdd237fa048661db6dcebad32fecab4686e0c5a8dd7f3471cb5a198291e2e9ab0f445d244dab38cc56dd105dbc2a0c6aac36572f939d889f16a03fe1cc91c77d29c8e838b61ba2da949c8e5f262c5a860a245fb4aa300d7e12306962b1b4e8602953c96b800390ffac3b63b63ed0b0206247aae3e5969bbb297928b96d2ab964b29a2052a7c6818d35c48d67d426efa7f2f1b3287f67a3b7d789865ff565f29fe2f04c7dfb2f60843528f0a27aba11621a7f3c16ce2844177906c511b7e40ee6b3a1917ee47f1df0fa4725aa7ae0e25e0f8b61a45cccb01df9fca2c9ed9942d3aa8a3213be885694d989cc5fb02ee801d61e2e5046e9ae6a5fff2935cc9ad4a8a61ff1131ffa667430d2a2e2a8c4961dba373e278de6cd4d3f014ab364dcdd450ae177eedb35b5d08ed74c789f79a7bbb0e5aa1c27bcc481926074984f89a660690bbdca3bfe4f26d2d5a1e525da5e953787109f3a572b88f5b1e964b7d2d130e3c99a0beec7ed53a4c69df6e752d07188fa106b66365eeeeb0c48992786800c6cf7d4feaf7d7170a48f99336733d46241a6168a4975985311242f1f465622a2552d4259989419754b17857c5aede791db7996e7e3ad294c0349df78d4a6065932a97e9963cc15a5d931a11f5a961b092283f890952891e84b822b64aa6ca383575761923364bb12eca8055f77d10268c2d7043f149e1d5b58ecffc974fbb7edd2a72170775d9c8477e793cbaf9eb0d39b3efcfb8c7a5b426ac66426bc2a73cfc57a05cf644e6d7e9ffb76aac4db2cc20ca47471089a0055c7556f4f3e029ac4bf65a37db598dc59296e3851934f358d29b30c8bd8174530ee89317e62442a3bedcda5475c8a6897f8d41faa1c4a466dd4127274316353d5b397cdbaa500186fdfa91f40088480de23bbbd94929d58636a0d91b258bcbeaa9474bfcf1356eb9851dce189e76cd66350504e1ce800717a1cd01a8446f67146747524b34bdaf4fed942651774f36a2d03e5772533b17735f28fd95f194a9322081298de1dc6dbb47afb76dd73fa4eb7ead9f36298dfa6269b761378e0b62e8b3baef439ad8748c2a223b5a54d5490089d7c92917dbcfae9800c5576d09cdaaf73269d066f29359ad339c95e1d976c1c109d532eda1b86f3883cc736c14207167b06c068f8aa79de675d270f71fb932b36990f4426d6a898857c703c69e91339a746d5484a9d92d3bceb35b2e896768f2ce0c826aab287c26968e9e8777ec69c9af85943d9dab2852aed6520a19db8f4d9e821f635321986321970cf48ab090cae26bf9ed5a8d244163c6d76c73d1bf0df01e6b7a735f42cd2bb748e9dcd1db64cc6ffd670910d795f86c38192d59cc997aa418ddc8ebfdfd66df684132207103a4eae33dbc474193f38dd69bf6b37f58875f72d4a7044160d9e491fc7888f28ceb75db098a1baa7d97d1ce62633a436053b5b6631216ba46c825f02ca1021c460fc5406a1e4ddfd006644cf7244afc30b3fdb802cc143887955a6a52f96a5676b4cd553d9daa687d81b82d646f4c899c1e8e1a04033f57db9929078cd4770fdcd7d530cfdbc64da1911ac7003ae28a1a7b7df48b450acf5df56dbc9e86a404527ee3023c048a8851a66b7bca132afa8ad7f2db25f689c3933adb6c017f06b249778825e4cb4312557af485de69b39de89530d4073873816d97ec2e673110140691d5d5b45529b69f67297b674e8819b8a5c04effe86e6fc50e6bd9db91016177fe6cf25f8b7534757e72290540379c186c3f81a79c2c5a623e98c49de51b1db60d50640408d041e8659294db06c64e1ed0f74431e834a29261eb213b60ede3c129fd521797ebe7181f0ff20ed1ac4f39d794e71b2a3486f9bc0a3ad64e6a91ff6e7eb53117834d1a65291190e5467d2fecd36d7441b6ff4bba7168c86208839fafabb1a0aff394d4910f6c33493af98d9e9a4dd73fa155c7b192083404ab3e6b68803379a8b8fdc447b2dde2fb3384620565811539d0b2cf1859408e0909dd60207fe939536120256fbbbe9ecbae2dbb46f1c3d2597b211abe7b89b88cdf74c865625adb36e68c577085c38dcd838c14dd5fa0a5a9b91fc3219dbe0d582ecf8719d5909826978a46f64cf4cea5a69745827cfda99bad391b8482c8ba351476019f6b2280599d3805c091b60be7986f3f2574c88c1f91ec306fc5e84b3d596ed203b40335c391443d4d9f224f68ccbc202cc849ba05186ea13496c82b86639655112dcd59</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>[AGC034E]Complete Compress</title>
    <url>/2019/11/12/%5BAGC034E%5DComplete%20Compress/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>树上有一些碎片，每次可以选择两个距离大于1的碎片在它们的最短路径上分别靠近一格，最终使得它们聚在任意一点</p>
<p>求最小的步数或告知不可能</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><a id="more"></a>
<p>对于一整棵树，如果根节点的所有子节点到它的距离和为偶数</p>
<p>且子树中到根距离和最大值不大于这棵整棵树到根的距离和的1/2，就是可行的</p>
<p><strong>注：等价于这个问题，有{\(a_i\)}，每次选择两个数各减去1，使最终和最小</strong></p>
<p><strong>如果\(2Max&gt;sum\)，最少距离和为\(2Max-sum\)，否则与原sum的奇偶性相同（0或1）</strong></p>
<p>因此每次要递归地尽量把到根距离和最大的子树的和变得最小</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>真的是做了整整一个晚上<del>机房好吵啊</del></p>
<p>用sdep[v]算到根的距离和没有考虑v是否也对距离和有贡献（s[v]==‘1’）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], sz[maxn], sdep[maxn], sum; <span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dep[cur] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">	sum += (dep[cur] - <span class="number">1</span>) * (s[cur] == <span class="string">'1'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v != fa)&#123;</span><br><span class="line">			dfs1(v, cur);</span><br><span class="line">			sz[cur] += sz[v] + (s[v] == <span class="string">'1'</span>);</span><br><span class="line">			sdep[cur] += sdep[v] + sz[v] + (s[v] == <span class="string">'1'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> link = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (sdep[v] + sz[v] + (s[v] == <span class="string">'1'</span>) &gt; sdep[link] + sz[link] + (s[link] == <span class="string">'1'</span>) || link == <span class="number">0</span>) link = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (link == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	dfs2(link, cur); sdep[cur] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">		<span class="keyword">if</span> (e[i].to != fa) sdep[cur] += sdep[e[i].to] + sz[e[i].to] + (s[e[i].to] == <span class="string">'1'</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">2l</span>l * (sdep[link] + sz[link] + (s[link] == <span class="string">'1'</span>)) &gt; sdep[cur]) sdep[cur] = <span class="number">2l</span>l * (sdep[link] + sz[link] + (s[link] == <span class="string">'1'</span>)) - sdep[cur];</span><br><span class="line">	<span class="keyword">else</span> sdep[cur] = sdep[cur] &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, ans = INF;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;u, &amp;v);</span><br><span class="line">		addedge(u, v); addedge(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> rt = <span class="number">1</span>; rt &lt;= n; rt++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); <span class="built_in">memset</span>(sz, <span class="number">0</span>, <span class="keyword">sizeof</span> sz); sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sdep, <span class="number">0</span>, <span class="keyword">sizeof</span> sdep);</span><br><span class="line">		dfs1(rt, <span class="number">0</span>); <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		dfs2(rt, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sdep[rt] == <span class="number">0</span>) ans = min(ans, sum &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans == INF) ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树</tag>
        <tag>递归</tag>
        <tag>调试很久</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNOI2012]矿场搭建</title>
    <url>/2019/11/12/%5BHNOI2012%5D%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在无向联通图中设置一些庇护所，使得任何1个点被删掉之后（同时在该地的庇护所也失效），所有点（包括删掉的这个点）都能到达至少一个庇护所</p>
<p>求最小的庇护所数及最优的方案数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><a id="more"></a>
<p>把所有的割点求出来，把这个图分为一些联通块</p>
<p>如果联通块里面割点个数为0，需要建两个，方案数为\(C_{cnt}^2\)</p>
<p>如果联通块里面割点个数为1，需要在除割点外建1个，方案数为\(cnt-1\)</p>
<p>如果联通块里面割点个数大于1，不论怎样都可以跑到其他联通块中，不用建</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>没写Case</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, _cnt, tdx;</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn];</span><br><span class="line"><span class="keyword">bool</span> cut[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	low[cur] = dfn[cur] = ++tdx;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dfn[v]) low[cur] = min(low[cur], dfn[v]);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			Tarjan(v); low[cur] = min(low[cur], low[v]);</span><br><span class="line">			<span class="keyword">if</span> (low[v] &gt;= dfn[cur] &amp;&amp; cur != <span class="number">1</span>) cut[cur] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (cur == <span class="number">1</span>) ++_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur == <span class="number">1</span>) cut[cur] = (_cnt &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">LL ans; <span class="keyword">int</span> Min, c, t, Col, vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	vis[cur] = Col;</span><br><span class="line">	++t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (!vis[v] &amp;&amp; !cut[v]) dfs(v, cur);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cut[v] &amp;&amp; vis[v] != Col) ++c, vis[v] = Col;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">	<span class="keyword">while</span> (m != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head); tot = <span class="number">0</span>; ans = <span class="number">1l</span>l, Min = <span class="number">0</span>; Col = <span class="number">0</span>; n = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn); <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low); _cnt = <span class="number">0</span>; tdx = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(cut, <span class="number">0</span>, <span class="keyword">sizeof</span> cut); <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">			addedge(u, v);</span><br><span class="line">			addedge(v, u);</span><br><span class="line">			n = max(n, max(u, v));</span><br><span class="line">		&#125;</span><br><span class="line">		Tarjan(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (!cut[i] &amp;&amp; !vis[i])&#123;</span><br><span class="line">				c = <span class="number">0</span>; t = <span class="number">0</span>; ++Col;</span><br><span class="line">				dfs(i, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (c == <span class="number">0</span>) ans *= <span class="number">1l</span>l * (t - <span class="number">1</span>) * t / <span class="number">2</span>, Min += <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (c == <span class="number">1</span>) ans *= t, Min++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d %lld\n"</span>, ++T, Min, ans);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HNOI</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>割点</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>[SOJ689]数字</title>
    <url>/2019/11/11/%5BSOJ689%5D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="输入密钥以查看该文档" />
    <label for="hbePass">输入密钥以查看该文档</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="de9b2db085a7dc49b7147f1cba5ef9eeebf287d79bc0f4714761ab76b66f840b">39b3ab97ad2fe4a6ababc42acd0b026e76dd316f9b0ae48f37a5a806e53974f1d0afda32c22f6aaa1dc8fb583635b686d93c44c4c0d8c790d8bd526bfdc4d9def1cd55af94208c87bffe4dddf6fa86729d11904da91f195d855910ce6ce1f7816dd66184a7be74a6abe99e54a96487ceccacb8a8906df4f02d3e3840a21135ee9f703d3a1a8b73b4ceffbcf117747d7a0e1251f9eec63bf23a6755498a714dd2cbfb52eff6137c58f9dae94238ee3f78f5b0c51595d64ca9ec2b642a63f303747871f1b2cafb77dba1539f5dcbdaa2494834aca8e712b444f187c12693e5bd30ec2f41f858b6067129003a7c24bb66d170bc763943e947de5d79583fa758f714add2f74b14cb7596e354aebf2e9634e9fc5a80b24198b0daee04e4c70b77096db6d4b9704dd30ad97562e6d9a951ce5166b4a6a50d8b0669831c4ff31a01c167258ecd5b38b35309ca854298daaf86723222d237c724dd7da787b32eae86b2622e1fc7b8345a0dfc769ab01c002dc5a97988853bf964eaaf5d62db36e4e4c89547ef5443f5e85675047a30cfb5cbebeb68b45199c45fc3d75f81809ebbd9a967f1a34ef8af81a47813c63b7b982673e99f632b212b59d312ad3694008df08037c93adbd3cb1567791a788af316b2574d8f762a0d55eefe370d921e041cc3e78646b043e084ccd24024d3a5387ecf8b5c31d9db7be32024d9135e28a3ff49a95dc5ee7ffc932a0edfe4de67ad9c56fa03950b3a0e53a87711b58254d1bbf6acad4744c8aac6be7e272c226a53696d63255836991492a04b060486e00eb16cc162acd9f4a53e99b40fbeec1a8dad1a6e4c299f130635919ec913feeb96915eed41811aca753b66fd63db9435efe97e45738f825fc1d540b18a1b01a9cf331fd2cbf1a1e6f79daf1132849c1cf68c4f5cfdc7d313c9f3d0bab503d594a382fe64b3a12c314b470ee3342921599624bdc8d99483354b046bf82447d7ee121ed28b0fe506c777bbf7701660383a187eb0b22cc2f63d018f3af5a9b9ef7267870038f8807ecc819ec5daa7f9947ef5b2b8f79f368f50d8322a62582055ace88b087b3ff39c0a78c20bbd2ce44c4986161682eed32c5901628111bf2b78396925e62e58ab6564a14aaafa98dcd97557ff61e2e48f373d1697479f5432f1cd2f2dadde40351c81f1f8c5abc1f4c0e9da5a097e0030897dc5cd291c85a51c9ac5fe2a05547fc8533f5c8148e91b17287d0fb809920560447cd8c74a22d1a68e5a7205501b81b1e5a14b2b1fa40828c9909bece13d5322b2d9ca6830de051580bb6fb77afa53fa428cd0719b4d92419d4fc0647777b29e3072d2a72f668bd59b516228995c85876946de041cc45b73590a89a28b548aeeb8f20a6e5c65ac3f6c22ed396f417525e30b6ee7529e3ec1942570e5229a434d5e3b826b2709a68337f40f52c26477c955421f17340c45a1eb1506d1cd97c815eb31e7e4794c6bf600d1decf575e8ca38aa51dc72c773ae2b825b8b7189055005c223ad879ea0e16bce9cc6680b70e072c91a129246b364b932c352ed95b055e9427cc3bcd3dbff8fefeb94a45e0672dc18f28316bd4c5b81a0f62916abe2d6817c50d312180df8e181c46d5850dc6853ce1118bab98aa7949be254f5b704ba58ce1de80bb0d21267a1a61094b11084ddea695c62a3d2f8b2924369b0d246c6299952c1b845e18e46ce762a8e4e653591dc9a766b320e38fd6c9bd167cf43a5e4ab3dccf063f0655e4b768a4423d6763fd9131f639d176478dfd9162631516c09a3e8635dc50457d4ad5277581786142127ba090b88798e9dfb8d50cc98bf41b64203ce1966c66d5fa97da256f525ee6d794ffb3607fdc9f5831131e82d81edf346b044c7b94120460a0d40dddb3ca45b118b57ccd7d966102ff4b908413b782c8b2ddbe7392c9e92d53ef47bdda51596c99c2b164816b08a85f05001aac022497d4a1ada1cbf11dbfa2fcc448ff39f3d94e861cf863b78563e1b6350f663cd37d7f422716f54c9c0836a0b1e0dbffde81104f6f251fb1486c67ee0f67d941c9a30492923fc6ec3ebbfd8e82d6ed87e36ae9a2825d0e7e0f558de596f3145b97dc67e1997535ea8c782c9ee847d257b389af7d75969e106732035bbda176d1f643d7733ab06a172ccb049193c9a32e31ef3e8981e6ba1c45da997403e05a6fbfa3054f1bf6618ebba0ab441ac7d702d60f648d8730085d9633d4c74f6764e1c70093698e0dc50d778c13d5d8c1f67481171840b6a04b331c67dcb1f7072f1f334f81b88651033ca04145dca0d1e9bef1d83ccdcb0104159e4ac6ef11105b8534f115b81c93c257dfc4d537ede5de77bbc8a936f8146471289e6175b0981cced5fb682a74931cf5e43d92daf10d2b70ca564ba0dc218305f967dd797025ab9e09f3acc94493737da5caa78d19b3aef9515e1468a1cb8df3f567600d1ea0f0c0adb89bceead5b9cd57406d96b9d01d894f989d10d7600b758cca2b5a12247a8de98d22ebfe8d428bdb0ff3b86bfc1b1e9ac04c78f9094c3f91175a366e0b66f873ddd015d5a59adecf9a46d6873473bd61beae2b52891b433887649e555b0cba9977f431925c2f8c3e7ae68e4f8804a8f21b6de36afea7f60776910904d5d778f5dc701d0fd69f7e613314c713ba01d519324023d0e042335455261d21cbabb6089cb4607c5cdafded183817192191e0e7b3193e0281bb2aa36bfc74b2c1f929dba3ac13ec7c34c8d500a42d12bbdfaad14eda8279378b5b983530e4c3dd174246707e4c045d84654dc4eb4f4869f692b95664401f1c5bea931dfbef15a60918dcec1999602177c46251b9c9949626bd1409ade52c363632a1bf2b15eaa385fbe5e6b17a21c934f98871b52c89fa7b46bc3a9314b2ea358bcff4cdd4ecaeec78df61d783f9ce14784dcfe75ac3f039ef1ec4d79995b58fef46f8ae8ca3d250195968dc3fe5f3d354b6246f92a363c61d76a374c2442123d9a22cba2849b7ce7ffc0169e5ec0934925a957ebd3e1c3b6a4ee0bd8e85ae545235f97befd2e4742aa1bd2b2b9c3fcd3a2714c0ef476be767e5cf316cc71ec85e7f213fd3e86c81f36ec35fe42811a28ee050f883931216d21764f2a6a3c3d168f3d3784b111e65d628692ce086d375a80efb456d3b51f571676b055ec42e08887235cf8ed2823ca120212146a35ef7294c12dfc7048d0dae7b0c8ae068708102b67c1d862fd557ff361d834d0f12bc9680049c04a26e738a5855b7a574535096604a2ff0f39c255fe3484e7ec6fb297b6d197afd49146d1f9493e068f8cfb3127a121f696d65be796d35e6470b676eeb1700dd4a80add5921452c88e767435cc4794f12f9f22a2014051db90327d17c6fb1e2157576da0c97ead37149c91634722457490b7400fa6d7fdedcbb046fe383cdd49f4a580a45f040ccfb891a076060bc1fcc296656d268392ee3134f8c3cf9052f429a0959b6aadd907e60dd6917dafb241df1458a03c0dff8a0eee7a7ac3b5dc4cda8e39e2c7d456ab97b0d46166c44bd18909ef4bd6844ba262785c14346cfee54906210a60c9ca1c1ff150d39a1971bc2e5fd187fe47402369cc3d03dfa9d4de8c2e85c7b3056e2e0a4d35633479086bfa2b8194ca85933115d665530203f726739e3fd1d39ff2e9785e17a371e51fcb9a9ca89547aadda8c7cf223a32b05c6e94602a9355ae4e7491c2cb72d121684cddb18ab3acf3ae9b77fb7ceb8a368873ad440eadb5e8ff19e1c683df9d707005c88cda1f1163a48c09964a6bdec8b3ef50c2f871cb64914c459b5d7ceca9b0fe6ebc34b2622df8fc08384301eff7579d28915a2dbb211341b7f75c1eeaae5150a6f3051b64dd164e5b8c4791ba7f30761bc2bc13c38387760810aacb1793c5930607c856fd4f9e5ff0e9b2c9e23fc46d62a65ed75ace9e488e578d8a88dc2088096aebc5e2665cf1db6d51c155c33c8d48515bf602b5398b89f2bb185ea29d10fae5af0d92855982a95d50cb916bfc21139073e32e3782b250e5f8358ad7eed7691baecfb7d38e863b7e40cb8c0b6522ae83bc6836ae4bb3d83671d2eb8f0c7b4ad04cfa272133be39d0c16b51a9abd433df3dd88024443ab801ea20bf1e86b23df27b2b14985aef1bef992ce90a9bed408ae28fe461577275884877ffc92ae5dbc45842c5fb719233c5139d8368868c04300da96df7272826d4fdd6458bb9652aad69f35eaae9b2a0eda27fb348b4809471a301fbdf7231f8297d7728378254c606cd8748e4670742464084f50dfe41fa8411c7b69e6970b95a000d22e63544555401554a95831eb2413d02f0957aac1a9dc381d6f94aa97f1b333b32961896c071a4f2ad79784cbf234165c1ec7d541aefce7820536e029fba12ac0096a232e1c2b022fac22ab702ea542270f3ea1c51300fc37f3c899b7cae761c0f2a689f038b29fe3eb12db1dd85001ea111faaddda198fb55fa06fa8a39a9f215d2eb787949d5ea551408d749b45b06b0b40fe0a904d4d70d1ec45e5caa426d4d63bd259f69957e38a4312088ac2e4ed64378d3083ce9d4852256c8c0e634613108997f498201952886be29426cff06645f85714cd48e740397cef4ce47384c82671032c9c16162829dfd60d289e971aa05fef4ebef728152d0d59b1ff70cbf9edf15a597a7196b8060c5fbc6e3e29fe984970fb3e538a453cdbcfda97081226e94d0fa700755b65d18d28ee081c566c82a0036160409b04588d5fa6ef8263b9bf6fae6d11adbcd2799e6b5ea3fdba5bb8c475d85afc253ecb0efbaa9defd5a013ce6f7e4e64eef58d0df2efce5a30f2961c54432a61967af83a727521101cffc814f0b76da91ed877fed54cba7b2e280fd73bb897b50572253bff8e3bf9dea11f71b860dc0fd168f47a8942d834700468b42d7bfe0c4b40b19e53e01d1fa7a3bd2fe508b682649e25308c68f5a5e4b448e9a36c90d76e9c94adb0d20e0c2e5149c5d63aa828fcde10b40f8b2105b15f63054a10a6554999b4fcb35a99d7f5e8d3d50ab79266b85d442a7198dfeb0d82ae33f9265fe89d52815ea376d95191c1290ae6d9c0bb8589585880581435d9677863a38f0e9b3bbc4b8b408ef1e4f822f74c05768c133d7d260e9d35450ab4a5add02a27f83769ba6dbbc85290ce79e8d7fe862918abc0fdbf1ef96a6d9d8a6a883e854abf6985525b8e659d796577b4ac2d7a16ece2f4dbfa747991749cbe3a03157e703d18dbeff6498c0bdfdad9e1fb74cc5d249692b33d2006736c04372f019e6b04cef54829b2034e4b69b0dfb880408363ba8db59be81e6bf01c820a93f37484aa85e6c36ccbbb6c21b950ebdbecc7f170a7933225214a9dc2047e5ba808eed81cd37ac4b4b5463b50ba376d297cad564d9ac657f562c3d96625ec806e315383ecc4e10be713322efdfa35b5cc63334a90ee2fd5174bf40afb7299e5ffc6b115f2f5badf067d9e2e803642e67633524b1cb4c2b8bc9278e80160f5ddb97427da5d0b89b351167c337e00692234eacd26863a1e67d534c60e09855a8e32493580a6b8341cd0cc29caa5f3b1adfaf808c6f2763cedea53a9e593fa4452b502db86d8b4430c5441dce2ede402eb9f18bb1488e13b39557e488686e7b5d1cbe8c74b1839faf973df0e69c2a3e3c107fb2dca4ea22e8bb303fc0cf3a0da949d3b5c226843fb3a996e4cc567da957f337bfa12a5c8310d93872ffb5c1504ea78c25a3d86110b0ed12731b02bc6d6fa74669d4bc123fe207f6f19852505965947f12825414fd1bbb53cdf7fd57503180d1faa73f19b346227f61cc1b765e3b85caf576e3ea376ec37b8b5080dfa03af3baae92d10e7a48957ed398fbf56b1c655962a576ee20879d232cf22c51d1610b9ad3bffe29ade335b4f47f274379da03c9ca53b8dc1ff004108516e63035d2dd5a3b3c342489d7398ea4800f56e4cafa7966d02cb1f4d4de146657e097130f8220ae79ce7a6754d0eca9871dd656dd1a60563b5c0c1caab52388f8cdccc6e8217483402a0dc1f02e28954eb8ab684010a8fd8078d4e0fc0dedc90534d9661e930dc5bd5122391dd5805fe474c456e3055b57531d2633c51499a2d5df09008ab654561fa6b48a59ad7d2d00bdbde58996f1a27b1a0cd49fd077e79189de6953f93cab71ea1bf6fb1f310a109131a66ea1507fff5f7aaa51ab54d9aed8f75ebfa6413d63a23d553a73c07accbab6bfef2289b546fae2e2f556bf1efec430f091a8b5c7c6208f16a0411fbd802220f8fce10787ca0e84b6a5764394b8bfaca0eeda921c403d63d9ab142c7dfa85f3be14fcbb37b21a1107b97e392d9480c34188b13db455ed5f1d275074ea7e3b42b376331308e9b6410affa5d66f6723b378d0c20d5b440de324e65598c21d1442525249c2acb681d7b68fcfdc0923b3476e182361434cf9fe79f479b74459221e7c582cc7eb3776b5a647b5e1a3caa0ce5274f06946673db468741bc94f860cf900e1a290fe4cfa2371a916bbe8a3ce660537ebc42cc25d454404607782b802a76dedb91f2dfce2d707c438470bb517bb1a56866fba6e2de0df64a6b957a1193421e66ab6c8c043686fcc5dc414b6bf05a5ee9f4bcab7c4dcb813963566925b5fe52b1f81dacbd02376ac96f583e2bd722f2d0c7f58c37413419f8a4876b024596658a90fe98b3610616d33283ad38aba7f07ba6fec7575e9341c58a4893486cccb1ecd00c0c5e774e3328043301c0797f6971bd45fba3ee55e69c40826e496cfa16113bad693e3a4b263f636a7e1c1e2ddd320a1034e17b4d85bd0225710a2ce24d821dc0d6240630f3c0470f6fcafe4306eb97d6c828215114561657174dd36221af912d3c529e9b31380adb3f28d8f67203086cd38618adccde653c04acd050098b746f70bcba86772be53e595dfe9e06b44724068261fe6186dc7b695376c5864cd4d3c9f9a2a5133acfac44b492992c1c18f26b2914b416d0d3ab0a5255c135cb61fd97ad0d0bec9f204c57946caf23480984c2b0d4653191484be96ef4195abd0f017a41e707a0c3b06edf1fec14bf0e4ffd0904f21de74387f59e542981c83946123deb3d261982a279457a23a29502e2bdef665b944f05332a962b0bcd45d26167ba87f347c9bd96f92abac2e00dffb32fdcbd44d0577f491063ed99ba5db7eef13d523388d1c52fc56cedf2e41be03f10eae2f9223e470ed297493bf2ad53bead7676d7ff33c62db435d0ff9108e43ff0be3497ebaca6c32216e893c571062de3b868122a3517453295cdae4cb5420dd073321a6b06879a4097d01b236eb4e6663e5138493c7f47f5f44020207819245aece1ae73ff028e179dac42c059f25725aee4ff77ce2e2725bd400dd1a63b26118f3bf87d4cae2b8760755a2616915abbbe19687f302e3203174b5e6f17b8443c4e225a7c88c3dabe1d8376e0437c9fae7b662552139ba0739a87c1d3ab3d65d5be0f28d2cb41d8e9cc301cfc9ef5c8786cc2c2ff51385b8326e30616ac3fd25f535df6463bcc7d567fde02f7471dbc394e5746cf6eb8aebba01da28049e4eb30f5c1be5ac7e1154cc1b47c08bb446c496d3804f102469df8365223905536c2252436e7a75e103388e3fb2690d3cfd1958aa4d64232c33b0df7ba2a6f0ad02386a3e540e3ee230faeaf748d3666eab177aaf7369457ba249c69aac95811dd75811d4d9a202bf4e07deb84469808726aa04e5391cc6f2a8be903cc8a10e3b4f2a27837cda7bc8552a935c186104fa8ee9661f365492eb445fb92d670e910b99e23f121644f0e88ea17843d4b743ba3ddee5a572eac3679f3244c6c61823bfa2136f229ba8ff5d90d558045860fda58d940d986c62134b2651b43d7bd6cc36ef1c552850ad2961db1138fab64561600e33b624b02e10e64cc94287626eacddf326e1d1f5269b9fc927931e49fa09d1c0d7b2c6f34711adb0942b3068dcaaec5e21f908d6d82b0c5c68de9aac439e85b511809ce377eec835250c79ad6b83c2532a04b146c31bd14149512c10b6051d7459864e7a30ce40e9f5c5ea8f50a9b09aa63691bc68d69944a55b04f1f36494539b7b8998b41a1ab5ea2b3d3bac3237d24942fe8bc5829302a8c4c5fde57afae5ec3d3d58ef8e32316057a2c1c2421c7b9e62609d54f63c8bf4e35ae6f9c0a0ccfb0ac5733a2513e7ca2af0a86d298374f0e0c871cbf36a49ecb90335433b72a2bd48fe651e545aa31e155028a6a7a50bf6239040d16b05e40b510b767f23dcf4f8a54c0d91f222e8b8c180a04ce9577e30f2bf0a47703aaf974f95de77fc40d3e958c6a24bbda7ea85112fbf3cf6a8b2eea3a7b657ffd8b13e70887e6fb44aca244f9526b6ace23a7fb5d87032a75d173326a67be6091bc5a7927a655b27daaed7d381b776392e17367a95fda23a60790f0223157d1bcf7fe62a90dc0ca15b29066c6ff5b6467271e0176ff9a20c8fc20b3d223b214a50d4e530d1a3e89a29fc9949440e9a2e8877b00d7273df194a4bc07a2449a3d13b0062cce9089ca80dda7ed90854e11b380e3c75a851cd9bc83ec046839dc9f907330d196ee650127f1cb884439fab7b4cb74fa080b8d1e8f7e1a11f27c4180b9cde0d6dfd8e9f4c46a0a68a4a024c0bc7279301fb2122ec75a75f73f795ad2d1e7b1411747887699b19529ef490d5ea25e2e17d15762f874abeec4fb7d3bc6c5fd19e0b9111902b08f8edc9fe7e832cef4f78caec16cc6c0c919394ec60f985c5486da8db05a437956897cff5f80f1254079b835077290149601b5f134614096df306413133fb48ba56e5a08301786294c3353ebec2c3c5c89f316a41d373b9048a39fa52a67bd9486fb924ee40429daf16500946139574d884279bdd0ac0935ec6c43d085d5eeec749fbed314a6718134c2c3ff180492475dba4bbf21acf39918e3ea3c1aac514d9c8544815a034b2bd8b665fba359c1d399117d602d59b86fce6963dad2279a6222f16ac516902e300abdcc1288815708d13e7e1d8a1bb6429160f40449cb0c59dca66156313c590d9ad3eccbeeb13b469812bbb0b41ac104d91877ad9e6f2b60422288402b71d238277e7eac1d48bd31f0e10584b314630c31440557f1b134bf80a5bb7e2f5505a5e4c35842ae9cb5bece5939c9752005c62141f1ae2d6734db7a5cd3e28d7d50ab83c777558593c10ae319355ac92ca0329195da23b9ac2425ffc38646aac49bd7b3c11fa0a674751dd30fb8ffdd94a03a4a0e5474d7e28dfb4a4d282774454050ec2bd2715d7de7b71d051686192f64b4c5d20139bb7164807c59304feb2b8156b94a61531474866df1892e927ff3587b239b61b05c214ea831ada4705f0c579850c7e583aba3d2f7cd40c5eb567614c0a5fe7ce34f930178ad14ccaf451821e854c1b7e18b19bd726ef2ccad71d95b3bed7fd1b6173fdfe5f8f6456c81ea88d10415b2ea880e70ac397a1c8f920bb5b109b9d5c5da9afbcf986270b4bf43de10f1ac99a115417cc5ce5850b94e1fe18223000cb7851b444cd14f509720b0c0b988d843a920875c8d72196d1405d6989ba8eaecf8e6d3189a329155a6965adc02e020b5e0405e68079ffc7b7151ac4f4caea26fac67bf77267258a2f482f85eeb404c2de4a1d4a80c6189b38a9929f194aca8da89787684711b3462bfe70d5fdfeee50c529a6dae5279be0ae0e3b5810e446a5f0db1f52b98d507334ccf7e26c6294cf40bae8c56d57e967b75949f17166d776a7231074188f103e45f30e114e79ddf4e53e3f6b89f88bf67175fe380ad19634cdb51e9f7bffca64f62164646b9e1030302972cf90ef85b6ea0abf81afc2f0e608b47c597aa0456d2d9df15f59e2ff7d5e4997da3377d8268e7f106fa893556d71d10bf6d589493d5af09af27697f835f49b3de30037c5fe171ebda534d5b0e1a0e5f82751f1ef38623e00c4e3a651c3ef6b97aa5e4b7c8db0dc24b82018ee6cf277e9f90af53d4cd99c75e0f29286b5066b806d67ba44f33d97e5ba94d63f56f1b0bfd8bb51b4efc67da210f10d2715b83901f5f4fc087bea0f914ff9a758aacec76cb6c096b03ded28e4efcc7628e874e0dc2274ff9f6fc05ac70e96dc57351a0a3bc8a05fd2e88e01d1bf9bf57c16ac037812e9afd392e1d5cd727cd64a60fd3c481ba53ab8c1b55dedd903ad48d1ff74e0f86ffab43970a97615e20f5920c876c12b33b3c5ce370c098405f1424ca952d6dc7dc0c8b36887a8a1c970da8c196033efffcf8f7e5e39da65dfcdd3aa7ca86e40b41aa4ad0d2a44973b5b59e6738b5206b4ea91d138825047185942c89e131b4d39a25ea69d67122685d1c435df6036e813c2c815765142389e328e66c5cdd8b8bfe755283c68b43ad7437792cc9ff0c84b7a165fdd15cbe047cfebace9ca9b8ef4f0f3618057cbcdc68871b216f6734d905fbb781387a46cfe271bcc8aeb5bdc0f067abce0ec26b5f89886f729287df8079f40779e1f563a28505339233cafb9737d095251e7db228fbffe7b951385aefb5d86ca88c9c52c5cde59</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[APIO2009]采油区域</title>
    <url>/2019/11/11/%5BAPIO2009%5D%E9%87%87%E6%B2%B9%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>在nm的非负权值网格中放3个k*k的不重叠正方形，求3个正方形的权值和最大值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><a id="more"></a>
<p><del>题解里说，过一个疯一个呢，我看没有</del></p>
<p>在矩形里放3个一共有6种情况</p>
<p>处理出对于每个点而言左上左下右上右下的二维前缀和与k*k的正方形的权值和</p>
<p>转移显然</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>一发过去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1505</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL s[maxn][maxn], a[<span class="number">4</span>][maxn][maxn], f[maxn][maxn], x[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, x[i] + j);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + x[i][j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m; j++)</span><br><span class="line">			f[i][j] = s[i][j] - s[i - k][j] - s[i][j - k] + s[i - k][j - k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			a[<span class="number">0</span>][i][j] = max(max(a[<span class="number">0</span>][i - <span class="number">1</span>][j], a[<span class="number">0</span>][i][j - <span class="number">1</span>]), f[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			a[<span class="number">1</span>][i][j] = max(max(a[<span class="number">1</span>][i + <span class="number">1</span>][j], a[<span class="number">1</span>][i][j - <span class="number">1</span>]), f[i + k - <span class="number">1</span>][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">			a[<span class="number">2</span>][i][j] = max(max(a[<span class="number">2</span>][i - <span class="number">1</span>][j], a[<span class="number">2</span>][i][j + <span class="number">1</span>]), f[i][j + k - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">			a[<span class="number">3</span>][i][j] = max(max(a[<span class="number">3</span>][i + <span class="number">1</span>][j], a[<span class="number">3</span>][i][j + <span class="number">1</span>]), f[i + k - <span class="number">1</span>][j + k - <span class="number">1</span>]);</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n - k + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">0</span>][i][j] + a[<span class="number">1</span>][i + <span class="number">1</span>][j] + a[<span class="number">2</span>][n][j + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n - k + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">0</span>][n][j] + a[<span class="number">2</span>][i][j + <span class="number">1</span>] + a[<span class="number">3</span>][i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n - k + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">1</span>][i + <span class="number">1</span>][j] + a[<span class="number">3</span>][i + <span class="number">1</span>][j + <span class="number">1</span>] + a[<span class="number">0</span>][i][m]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n - k + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">0</span>][i][j] + a[<span class="number">2</span>][i][j + <span class="number">1</span>] + a[<span class="number">3</span>][i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m - k + <span class="number">1</span>; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">0</span>][n][j - k] + a[<span class="number">2</span>][n][j + <span class="number">1</span>] + f[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n - k + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m; j++)</span><br><span class="line">			ans = max(ans, a[<span class="number">0</span>][i - k][m] + a[<span class="number">3</span>][i + <span class="number">1</span>][<span class="number">1</span>] + f[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>APIO</category>
      </categories>
      <tags>
        <tag>动态规划Dp</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>[Usage]1</title>
    <url>/2019/11/11/%5BUsage%5D1/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>usage</category>
      </categories>
      <tags>
        <tag>usage</tag>
      </tags>
  </entry>
  <entry>
    <title>[SOJ692]medians</title>
    <url>/2019/11/10/%5BSOJ692%5Dmedians/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求所有奇数长区间的两端点的编号乘积再乘上中位数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>中位数可以赋值1,-1来做</p>
<p>枚举中位数，求两侧前缀和相同的贡献和即可</p>
<p>注意到如果中位数相同，右端点相同，左边的贡献是可以直接加的</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>第j位的前缀和为b，它的贡献在第j+1位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn], cnt[<span class="number">2</span>][maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">LL ans = <span class="number">0</span>, tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		tmp = <span class="number">0</span>; <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) b[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (a[j] &gt; a[i]) b[j] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> b[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) b[j] += b[j - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) cnt[<span class="number">0</span>][b[j] + <span class="number">10000</span>] += (j + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">			tmp += <span class="number">1l</span>l * cnt[<span class="number">0</span>][b[j] + <span class="number">10000</span>] * j;</span><br><span class="line">		ans += <span class="number">1l</span>l * tmp * a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SOJ</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>[CTSC2008]祭祀</title>
    <url>/2019/11/08/%5BCTSC2008%5D%E7%A5%AD%E7%A5%80/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求有向图中最大的集合使得集合中的点两两不可到达</p>
<p>求集合的大小，输出1种可行的构造方案，并输出每个点能不能在点集中</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><a id="more"></a>
<p>第一问：由Diliworth定理，最长反链的长度=最小链覆盖的数量</p>
<p>本来是没有后两问的<del>哪个毒瘤写的spj</del></p>
<p>第二问：就是求二分图的最大独立集</p>
<p>第三问：把一个点以及和它相连的边和点都删掉，如果最小链覆盖-1，则可以</p>
<h3 id="关于第二问的构造方案"><a href="#关于第二问的构造方案" class="headerlink" title="关于第二问的构造方案"></a>关于第二问的构造方案</h3><p>首先不能直接选覆盖链的头或尾来构造，反例显然</p>
<p>这个问题等价于二分图的最大独立集的问题</p>
<p>最大独立集一定等于最小点覆盖的补集：1.它一定是最大的 2.该补集中一定没有连边，如果有的话不满足最小点覆盖</p>
<p>考虑如何求二分图的最小点覆盖：从左边的任何一个未匹配点开始，未匹配边-&gt;匹配边…，标记经过的所有点</p>
<p>左侧标记的点和右侧未标记的点就是最小点覆盖，如果i和i+n都在最大独立集里，就加入反链</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>不会构造方案<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f);</span><br><span class="line">	addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn], T;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">	q.push(<span class="number">0</span>); <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (!dep[e[i].to] &amp;&amp; e[i].f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">if</span> (dep[e[i].to] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(e[i].to, min(Max - flow, e[i].f));</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	maxflow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(<span class="number">0</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> link[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				link[i][j] |= (link[i][k] &amp; link[k][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) link[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[cur]) <span class="keyword">return</span>;</span><br><span class="line">	vis[cur] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (e[i].f == <span class="number">0</span> &amp;&amp; e[i].to != <span class="number">0</span>) dfs1(e[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur &gt; n)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (e[i].f == <span class="number">0</span> &amp;&amp; e[i].to != T) dfs1(e[i].to);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">int</span> ex[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		link[u][v] = <span class="number">1</span>;</span><br><span class="line">	&#125; T = n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; Floyd();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ins(<span class="number">0</span>, i, <span class="number">1</span>), ex[i] = tot - <span class="number">1</span>, ins(i + n, T, <span class="number">1</span>), ex[i + n] = tot - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (link[i][j]) ins(i, j + n, <span class="number">1</span>);</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - maxflow);</span><br><span class="line">	<span class="keyword">int</span> tmp = n - maxflow;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (e[ex[i + n]].f != <span class="number">0</span>) dfs1(i + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, (!vis[i] &amp; vis[i + n]));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= n; p++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head); tot = <span class="number">1</span>; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (i != p &amp;&amp; !link[i][p] &amp;&amp; !link[p][i]) ins(<span class="number">0</span>, i, <span class="number">1</span>), ins(i + n, T, <span class="number">1</span>), ++cnt;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (i != p &amp;&amp; j != p &amp;&amp; link[i][j]) ins(i, j + n, <span class="number">1</span>);</span><br><span class="line">		Dinic();</span><br><span class="line">		<span class="keyword">if</span> (cnt - maxflow == tmp - <span class="number">1</span>) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">	&#125; <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>调试很久</tag>
        <tag>网络流</tag>
        <tag>二分图</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]二分图最大匹配</title>
    <url>/2019/11/06/%5B%E6%A8%A1%E6%9D%BF%5D%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求二分图最大匹配</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>能协商就协商</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>每次bfs前要清空vis</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u];</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="keyword">int</span> match[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (!vis[v])&#123;</span><br><span class="line">			vis[v] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (!match[v][<span class="number">1</span>] || bfs(match[v][<span class="number">1</span>]))&#123;</span><br><span class="line">				match[v][<span class="number">1</span>] = cur;</span><br><span class="line">				match[cur][<span class="number">0</span>] = v;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="keyword">if</span> (u &gt; n || v &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">		addedge(u, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!match[i][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">			ans += bfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>[POJ1149]pigs</title>
    <url>/2019/07/15/%5BPOJ1149%5Dpigs/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有$n$个猪圈，有$m$个顾客会依次前来购买至多$M_i$只猪</p>
<p>每次顾客会打开$k$个猪圈，只有猪圈被打开的之后，被关上之前可以任意调换，最大化卖猪的数量</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每次顾客来卖猪的时候视为先把所有的指定猪圈里的猪<strong>寄存</strong>到顾客手上</p>
<p>之后再去那些猪圈买猪的时候直接从顾客手里买</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>bfs的时候只扩展e[i].f&gt;0的边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f); addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, keep[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i != <span class="number">-1</span>; i = e[i].nxt)</span><br><span class="line">			<span class="keyword">if</span> (!dep[e[i].to] &amp;&amp; e[i].f)&#123;</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[n + m + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == n + m + <span class="number">1</span>) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i != <span class="number">-1</span>; i = e[i].nxt)&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[e[i].to] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f)&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">int</span> flow = dfs(e[i].to, min(Max - flow, e[i].f)))&#123;</span><br><span class="line">				e[i].f -= flow;</span><br><span class="line">				e[i ^ <span class="number">1</span>].f += flow;</span><br><span class="line">				<span class="keyword">return</span> flow;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">int</span> tmp = dfs(<span class="number">0</span>, INF)) maxflow += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> f, i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f);</span><br><span class="line">		ins(<span class="number">0</span>, i, f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k, M; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> a, j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			<span class="keyword">if</span> (keep[a] == <span class="number">0</span>) ins(a, i + n, INF);</span><br><span class="line">			<span class="keyword">else</span> ins(keep[a], i + n, INF);</span><br><span class="line">			keep[a] = i + n;</span><br><span class="line">		&#125; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M);</span><br><span class="line">		ins(i + n, n + m + <span class="number">1</span>, M);</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]网络最大流（Dinic）</title>
    <url>/2019/07/14/%5B%E6%A8%A1%E6%9D%BF%5D%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%88Dinic%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求网络最大流</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>Dinic</p>
<h3 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h3><p>Max要减去flow，不然反例如下：</p>
<p><img src="https://i.loli.net/2020/01/30/fiJs8PEYlUcImOv.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt, f;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	e[++tot].to = v, e[tot].nxt = head[u], e[tot].f = f;</span><br><span class="line">	head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	addedge(u, v, f);</span><br><span class="line">	addedge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], now[maxn]; <span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep); dep[S] = <span class="number">1</span>; q.push(S);</span><br><span class="line">	<span class="built_in">memcpy</span>(now, head, <span class="keyword">sizeof</span> now);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!dep[e[i].to] &amp;&amp; e[i].f)&#123;</span><br><span class="line">				q.push(e[i].to);</span><br><span class="line">				dep[e[i].to] = dep[cur] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dep[T];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> Max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == T) <span class="keyword">return</span> Max;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = now[cur]; i; i = e[i].nxt)&#123;</span><br><span class="line">		now[cur] = i;</span><br><span class="line">		<span class="keyword">if</span> (flow == Max) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="keyword">if</span> (dep[e[i].to] == dep[cur] + <span class="number">1</span> &amp;&amp; e[i].f)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = dfs(e[i].to, min(Max - flow, e[i].f));</span><br><span class="line">			e[i].f -= tmp;</span><br><span class="line">			e[i ^ <span class="number">1</span>].f += tmp;</span><br><span class="line">			flow += tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (bfs())</span><br><span class="line">		maxflow += dfs(S, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u, v, f, i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;f);</span><br><span class="line">		ins(u, v, f);</span><br><span class="line">	&#125;</span><br><span class="line">	Dinic();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxflow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
</search>
